== Android and the Git Data API

You might not use your phone right now as a developer tool, but the
odds are that you will soon. At the moment, phones and tablets can be
great for reading code, but the editors we developers use on our
laptops have not yet been reimagined for mobile devices. We are
getting close though: the GitHub API is accessible through the well
written EGit client library for Java, and this library supports both reading
data stored on GitHub and writing data back into it. These are a
perfect set of building blocks to develop applications for the Android
platform, currently the world's most popular mobile OS.

In this chapter, we'll use the Java EGit libraries to develop a small 
Android application which posts to our blog hosted on GitHub. Our
blogging application will allow us to login to GitHub, and then ask us
for a quick note describing how we are feeling. The application will
then compose a Jekyll blog post for us and push the post into our blog
on GitHub.  

=== Setting Up

To build this application, we need to create a Jekyll blog and then
install the necessary Android build tools. 

==== Creating a Jekyll blog

We are writing an application which adds jekyll blog entries, and we
are writing tests to verify our application works as advertisted, so
we need a sandbox blog against which we can run commands. There are
various ways to create a new Jekyll blog. The simplest is to run a
series of Ruby commands documented here; if you want to know more
about Jekyll, it is covered in more depth in the Jekyll chapter.
There are a few items of note when establishing a Jekyll blog that
have some complexity, things like mapping a hostname properly and using the
correct branch inside git. For our purposes here, however, we won't need
to make sure all that is established. All we need is to make sure that
we have a sandbox repository that has the structure of a jekyll blog.

[source,bash]
-----
$ printf "source 'https://rubygems.org'\n\ngem 'github-pages'\ngem 'hub'" >> Gemfile
$ export BLOG_NAME=mytestblog
$ bundle
$ jekyll new $BLOG_NAME
$ cd $BLOG_NAME
$ hub create
$ git push -u origin master
-----

These commands install the correct libraries for using Jekyll (and one
for our tests as well), generate a new blog using the jekyll command
line tool, and then create a blog on GitHub with those files. On the
second line we specify the name of the blog; you are welcome to change
this to any name you'd like, just make sure the tests match the name.

[WARNING]
When you have finished running these commands, you should close the
terminal window. There are other commands later in this chapter which
should occur in a fresh directory and as such it is best not to run
those commands from within the same directory where you created your
jekyll blog. You've pushed all those files into GitHub, so you could
safely delete the local repository in this directory.

=== Android Development Tools

If you don't have a physical Android device, don't fret. You can follow
along with this chapter without having an actual Android device by doing
development and testing on a virtual device. 

==== Installing the Java SDK

Unfortunately there is no simple shell command to install Java in the
same way as there is for Ruby and NodeJS using RVM or NVM. 
Oracle controls the Java language and distribution of official SDKs,
and they restrict access to downloads other than from java.oracle.com.
Java is freely available, but you need to visit java.oracle.com and
find the correct download for your needs. Android works with either
the 1.6 or 1.7 versions of Java.

==== Installing the Android SDK

For this application we only need the Android SDK and not the full
bundle of Android Studio. Go to https://developer.android.com/sdk and
download the appropriate ZIP or TGZ file for your platform. You will
need to establish the proper environment variables so make sure to
follow the README included in the archive.

==== Creating AVDs for Development

Once you have installed the Android SDK, you can create a virtual device
called an AVD (Android Virtual Device). To create an AVD, run the
`android avd` command from a shell prompt. You'll see the AVD manager,
and can create new devices and manage existing ones. Mine has multiple
AVDs already created; yours will be empty the first time.

image::images/android-avd.png[The Android Virtual Device (AVD) Manager]

To create a new AVD, click on the "New.." button and follow the
prompts.

image::images/android-new-avd.png[Creating a new Android Virtual Device]

You are generally free to choose whatever settings you like. Google
produces a real device called the Nexus 5. This is the Android
reference device, and is a good option for a generic device with good
support across all features. You can choose this one if you are
confused about which to use. 

Once you have created an AVD, start it up. It will take a few minutes
to boot; AVDs emulate the chipset in software and
booting up can take a few minutes, unfortunately. There are
alternative tools that speed up AVD boot time (Genymotion is one of
those), but there are complexities if you stray away from the stock
Android tools, so we will stick with AVD. After your AVD has completed booting, you 
can test to see if it is correctly started and available using the adb
command line tool.

[source,bash]
$ adb devices -l
* daemon not running. starting it now on port 5037 *
* daemon started successfully *
List of devices attached
emulator-5554          device product:sdk_google_phone_armv7  ...

Running the adb command starts a daemon service which communicates
with your device. In this case the daemon reported that I have a
single device available, the emulated Nexus 5 device.

==== Creating a New Project

Let's now create our Android project. The following commands will
setup a directory structure and create the basic files necessary to
compile an Android application.

[source,bash]
$ mkdir ghru # GitHub R U?
$ cd ghru
$ android create project --target android-21 \
--name GHRU --path . \
--activity GitHubRu --package com.ghru
$ mkdir -p app/src/main/res
$ mkdir -p app/src/main/java
$ mkdir -p app/src/test/java/com/ghru
$ mv res/* app/src/main/.

These commands create the files, and then modify the directory
structure to model what the Gradle tools expect to see for an Android
project. We could have adjusted our gradle build files to handle the
structure generated by the stock Android tools (the `android create` command),
but adjusting for Gradle means our project structure will match what
other Android projects look like (especially those created by Android Studio).

[NOTE]
You may not have the same installation of Android targets necessary to
run this command. In this case you might get an error like `Error:
Target id is not valid. Use 'android list targets' to get the target
ids.`. If you receive this error, run the command `android list
targets` and use a different target. Generally any target beyond
android-21 should work with this code.

===== Adding Gradle support

Gradle is a build system for Java and has become the offical build
system for the Android platform. Using a simple `build.gradle` file (well,
two actually) we can build an entire Android application from the
command line. Gradle is well supported with more advanced editors, so
you can always import an Android project using Gradle and use it with
editors like Eclipse or Android Studio. 

First, install Gradle.

[source,bash]
$ mkdir ~/gradle
$ cd ~/gradle
$ curl -L \
https://services.gradle.org/distributions/gradle-2.7-all.zip -o gradle.zip
$ unzip gradle.zip
$ export PATH=$PATH:~/gradle/gradle-2.7/bin

This downloads the latest gradle and installs the gradle executable (a
shell script actually) into your path so you can run `gradle` from
anywhere.

Once we have gradle installed, we can create our gradle build
files. We need two: a top level file, and our app specific file.

Our top level file should be called `build.gradle` and sits in the
root of the ghru directory.

[source,groovy]
-----
// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:1.3.0'

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

allprojects {
    repositories {
        jcenter()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}

-----

This file is mostly boilerplate.

Inside our app directory, we create the Android gradle build file (also
called `build.gradle`).

[source,groovy]
-----
apply plugin: 'com.android.application' //  <1>

android {
    compileSdkVersion 23 //  <2>
    buildToolsVersion "23.0.1"

    defaultConfig { //  <3>
        applicationId "com.ghru"
        minSdkVersion 21
        targetSdkVersion 23
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" //  <4>
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}

dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    testCompile 'junit:junit:4.12' //  <5>
    testCompile 'com.squareup.okhttp:okhttp:2.5.0'
    compile 'com.android.support:appcompat-v7:23.0.1'
    compile 'org.eclipse.mylyn.github:org.eclipse.egit.github.core:2.1.5' //  <6>
    compile( 'commons-codec:commons-codec:1.9' ) //  <7>
    androidTestCompile 'com.android.support.test:runner:0.4' //  <8>
    androidTestCompile 'com.android.support.test:rules:0.4'
    androidTestCompile 'com.android.support.test.espresso:espresso-core:2.2.1'
}
-----

<1> We load the Android gradle plugin.
<1> Here we specify the Android toolset to use in compilation.
<2> We then apply the boilerplate Android setup code, standard in any
gradle based Android project. 
<2> In order to write UI tests, we need to specify a test runner
called the `AndroidJUnitRunner`
<1> We tell gradle to load some support libraries for our tests, the
OkHttp library from Square (which gives us a simple interface to
making HTTP calls in our tests) and the JUnit testing library. Gradle
will download the proper JAR files from the Maven repository and build
them into our application using this dependency declaration. 
<2> This declaration installs the EGit library, our interface to the GitHub API
from within Java. 
<3> Commons codec is an Apache Foundation library which helps to
encode content into Base64, one of the options for storing data inside
a GitHub repository using the API.
<2> Lastly, we install the espresso libraries, the Google UI testing
framework. The first line installs the test runner which we configured
above. 

We also need a `gradle.settings` file that just has this inside it:
`include ':app'`

===== Default Android Main

When we use the above commands to create a new android application, it
creates a sample entry point which is the starting point of our
Android application. 

[source,java]
-----
<manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.ghru">

    <uses-permission android:name="android.permission.INTERNET" />

    <application android:allowBackup="true" android:label="@string/app_name"
        android:icon="@mipmap/ic_launcher" android:supportsRtl="true"
        android:theme="@style/AppTheme">

        <activity android:name="MainActivity"
            android:label="@string/app_name">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

    </application>

</manifest>

-----

When the application is launched, the Android OS will launch this
activity and then call the `onCreate` function for us. Inside this
function, our application calls our parent's implementation of
`onCreate`, and then inflates the layout for our application. This
layout corresponds to an automatically generated XML file which
resides in our layouts directory called `main.xml`. This application
requires that we login, so we know we at least need a field and a
descriptive label for the username, a password field (and associated
descriptive label) for the password, a button to click that tells our
app to attempt to login, and a status field which indicates success or
failure of the login. So, let's modify the generated `main.xml` to
specify this user interface. 

[source,java]
-----
<?xml version="1.0" encoding="utf-8"?> <!-- <1> -->
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    > <!-- <2> -->
<TextView
    android:layout_width="fill_parent"
    android:layout_height="wrap_content"
    android:text="GitHub Username:"
    />
<EditText
    android:layout_width="fill_parent"
    android:layout_height="wrap_content"
    android:id="@+id/username"
    />

<TextView
    android:layout_width="fill_parent"
    android:layout_height="wrap_content"
    android:text="GitHub Password:"
    />

<EditText
    android:layout_width="fill_parent"
    android:layout_height="wrap_content"
    android:id="@+id/password"
    android:inputType="textWebPassword"
    /> <!-- <3> -->

<Button
    android:layout_width="fill_parent"
    android:layout_height="wrap_content"
    android:text="Login"
    android:id="@+id/login"
    /> <!-- <4> -->

<TextView
    android:layout_width="fill_parent"
    android:layout_height="wrap_content"
    android:id="@+id/login_status"
    />

</LinearLayout>
-----

You may have complicated feelings about XML files (I know I do), but
the Android layout XML files are a straightforward way to design
layouts declaratively, and there is a great ecosystem of GUI tools
that provide sophisticated ways to manage them. Scanning this XML
file, it should be relatively straightforward to understand what is
happening here.

<1> The entire layout is wrapped in a `LinearLayout` which simply
  positions each element stacked vertically inside it. We set the 
  height and width layout attributes to `fill_parent` which means this
  layout occupies the entire space of the screen.
<2> We then add the elements we described above: pairs of `TextView`
  and `EditView` for the label and entry options necessary for the
  username and password. 
<3> The password field customizes the type to be a password field,
  which means the entry is hidden when we enter it. 
<4> Some elements in the XML have an ID attribute, which allows us to
  access the items within our Java code, such as when we need to assign
  a handler to a button or retrieve text entered by the user from an
  entry field. We will demonstrate this in a moment.

We also need a layout once we have logged in. Create a file called
`logged_in.xml` inside the `app/src/main/res/layout` directory. Once
logged in, the user is presented with a layout asking them to choose
which repository to save into, asks them to enter their blog post into
a large text field and then click a button to submit that blog
post. We also leave an empty status box beneath the button to 
provide context while saving the post.

[source,java]
-----
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    >
  <TextView
      android:layout_width="fill_parent"
      android:layout_height="wrap_content"
      android:text="Logged into GitHub"
      android:layout_weight="0"
      android:id="@+id/loggedIn" />

  <EditText
      android:layout_width="fill_parent"
      android:layout_height="wrap_content"
      android:hint="Enter the blog repository"
      android:id="@+id/repository"
      android:layout_weight="0"
      />

    <EditText
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:hint="Enter the blog title"
        android:id="@+id/title"
        android:layout_weight="0" />

    <EditText
      android:gravity="top"
      android:layout_width="fill_parent"
      android:layout_height="fill_parent"
      android:hint="Enter your blog post"
      android:id="@+id/post"
      android:layout_weight="1"
      />
  
  <Button
      android:layout_width="fill_parent"
      android:layout_height="wrap_content"
      android:layout_weight="0"
      android:id="@+id/submit"
      android:text="Send blog post"/>
    
  <TextView
      android:layout_width="fill_parent"
      android:layout_height="wrap_content"
      android:id="@+id/post_status"
      android:layout_weight="0"
      android:text=""/>
  
</LinearLayout>


-----

Most of this should be familiar once you have reviewed the `main.xml`
file (and be sure to copy this from the associated sample repository
on GitHub if you don't want to copy it in yourself).

Now that we have our XML established, we can ready our application for
testing.

=== Android Automated Testing

Android supports three types of tests: unit tests, integration tests,
and user interface (UI) tests. Unit tests validate very tightly
defined and isolated pieces of code, while integration tests and UI tests test
larger pieces of the whole. On Android, integration tests generally
mean instantiation of data managers or code that interacts with
multiple components inside the app, while UI testing permits testing
of user facing elements like buttons or text fields.
In this chapter we will create a unit test and UI test. 

One important note: Unit tests run on your development machine, not the Android 
device itself. UI tests run on the Android device (or emulator). There
can be subtle differences between the Java running on your development
machine and the Dalvik interpreter running on your Android device, so
it is worthwhile to use a mixture of the three types of tests. 

==== Unit Tests for our GitHub Client

Let's start by defining a unit test. Since the unit test runs on our
development machine, our test should not touch any Android specific
classes. This forces us to isolate functionality outside of the
Android interface. We will define a helper class which will handle all
the interaction with the GitHub API but does not know about Android
whatsoever. Then, we can write a test harness that takes that class,
instantiates it and validates our calls to GitHub produce the right
results.

[NOTE]
You might legitimately ask: is a unit test the right place to verify
an API call? Will this type of test be fast, given that slow running
unit tests are quickly ignored by software developers? Would it be
better to mock out the response data inside our unit tests? These are
all good questions! 

Inside the `app/src/test/java/com/ghru` directory, add a file called
`GitHubHelperTest.java` that looks like the following.

[source,java]
-----
package com.ghru;

import com.squareup.okhttp.OkHttpClient; //  <1>
import com.squareup.okhttp.Request;
import com.squareup.okhttp.Response;

import org.hamcrest.Description; //  <2>
import org.hamcrest.TypeSafeMatcher;
import org.junit.Test;

import java.util.Date;

import static java.lang.Integer.parseInt;
import static org.junit.Assert.*;

/**
 * To work on unit tests, switch the Test Artifact in the Build Variants view.
 */
public class GitHubHelperTest { //  <3>
    @Test
    public void testClient() throws Exception {

        String login = "BurningOnUp"; //  <4>
        String password = System.getenv("GITHUB_HELPER_PASSWORD");
        String repoName = "BurningOnUp.github.io";

        int randomNumber = (int)(Math.random() * 10000000); //  <5>
        String randomString = String.valueOf( randomNumber );
        String randomAndDate = randomString + " " + (new Date()).toString() ;

        GitHubHelper ghh = new GitHubHelper( login, password ); //  <6>
        ghh.SaveFile(repoName, 
		     "Some random title", 
		     "Some random body text", 
		     randomAndDate );

        Thread.sleep(3000); //  <7>

        String url = "https://api.github.com/repos/" +  //  <8>
	    login + "/" + repoName + "/events";
        OkHttpClient ok = new OkHttpClient();
        Request request = new Request.Builder()
                .url( url )
                .build();
        Response response = ok.newCall(request).execute();
        String body = response.body().string();

        assertTrue( "Body does not have: " + randomAndDate,   //  <9>
		    body.contains( randomAndDate ) );
    }

}
-----

<1> First, we import the OkHttp library. We will use this to verify
that our GitHub calls made it all the way into GitHub.
<2> Next, we import a set of matchers, which allow us to make
assertions inside our code, and which JUnit will then verify or flag
an error. The remaining imports should be evident.
<3> We create a class called `GitHubHelperTest`. In it, we define a
sole test case `testClient`. We use the `@Test` annotation to indicate
to JUnit that this is a test case.
<4> Now we specify our login information and the repository we want to
test against. In order to keep the password out of our source code, we
use an environment variable which we can specify when we run the
tests.
<6> Next we build a random string. This unique string will be our
commit message, a beacon that allows us to verify our commit made it
all the way through and was stored on GitHub, and differentiate from
other commits made recently by other tests.
<7> Now, to the meat of the test: we instantiate our GitHub client
with login credentials, then use the `SaveFile` function to save the
file. The last parameter is our commit message, which we will verify
later.
<7> There can be times when the GitHub API has registered the commit
but the event is not yet displayed in the API; sleeping for a few
seconds fixes this.
<7> Next we go through the steps to make an HTTP call with the OkHttp
library. We load a URL which provides us with the events for a
specified repository, events which will have the commit message when
it is a push type event. This repository happens to be public so we
don't require authentication against the GitHub API to see this data.
<8> Once we have the body of the HTTP call, we can scan it to verify
the commit message is there. 

The final steps deserve a bit more investigation. If we load the event
URL from cURL, we see data like this.

[source,bash]
-----
$ curl https://api.github.com/repos/burningonup/burningonup.github.io/events
[
  {
    "id": "3244787408",
    "type": "PushEvent",
    ...
    "repo": {
      "id": 44361330,
      "name": "BurningOnUp/BurningOnUp.github.io",
      "url":
      "https://api.github.com/repos/BurningOnUp/BurningOnUp.github.io"
    },
    "payload": {
      ...
      "commits": [
        {
          "sha": "28f247973e73e3128737cab33e1000a7c281ff4b",
          "author": {
            "email": "unknown@example.com",
            "name": "Unknown"
          },
          "message": "207925 Thu Oct 15 23:06:09 PDT 2015",
          "distinct": true,
          "url":
	  "https://api.github.com/repos/BurningOnUp/BurningOnUp.github.io/commits/28f247973e73e3128737cab33e1000a7c281ff4b"
        }
      ]
    }
...
]
-----

This is obviously JSON. We see the type is "PushEvent" for this event,
and it has a commit message which matches our random string format. We
could reconstitute this into a complex object structure, but scanning
the JSON as a string works for our test.

We can run these tests using this command.

[source,bash]
-----
$ GITHUB_HELPER_PASSWORD=MyPwd123 gradle testReleaseUnitTest
:app:preBuild UP-TO-DATE
:app:preReleaseBuild UP-TO-DATE
:app:checkReleaseManifest
...

com.ghru.GitHubHelperTest > testClient FAILED
    java.lang.AssertionError at GitHubHelperTest.java:42

1 test completed, 1 failed
:app:testReleaseUnitTest FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':app:testReleaseUnitTest'.
> There were failing tests. See the report at:
file:///Users/xrdawson/Projects/ghru/app/build/reports/tests/release/index.html

* Try:
Run with --stacktrace option to get the stack trace. Run with --info
or --debug option to get more log output.

BUILD FAILED

Total time: 5.432 secs
-----

Gradle will build your code, run the tests, and then provide you with
an output report if the tests did not succeed. 

image::images/android-unit-tests-fail.png[Failing Unit Tests]

==== Android UI Tests

Let's now write a UI test. Our test will start our app, find the
username and password fields, enter in the proper username and
password text, then click the login button, and finally verify that we
have logged in by checking for the text "Logged into GitHub" in our
UI.

Android uses the Espresso framework to support UI testing. We
already installed Espresso with our Gradle configuration, so we can
now write a test. Espresso tests are written in Java. Tests are
written by deriving from a generic test base class
(`ActivityInstrumentationTestCase2`). Any public function defined
inside the test class is run as a test.

[source,java]
-----
package com.ghru; // // <1>

import android.support.test.InstrumentationRegistry; // // <2>
import android.test.ActivityInstrumentationTestCase2;
import static android.support.test.espresso.Espresso.onView;
import static android.support.test.espresso.action.ViewActions.*;
import static android.support.test.espresso.assertion.ViewAssertions.matches;
import static android.support.test.espresso.matcher.ViewMatchers.*;

public class MainActivityTest  // // <3>
    extends ActivityInstrumentationTestCase2<MainActivity> {

    public MainActivityTest() {
        super( MainActivity.class ); // // <4>
    }

    public void testLogin() { // // <5>
        injectInstrumentation(InstrumentationRegistry.getInstrumentation()); // // <6>
        MainActivity mainActivity = getActivity();
        onView( withId( R.id.username )) // // <7>
	    .perform(typeText("BurningOnUp"));
        String password = mainActivity.getString(R.string.github_helper_password); // // <8>
        onView(withId(R.id.password)) // // <9>
	    .perform(typeText(password));
        onView(withId(R.id.login))
	    .perform(click());
        onView( withId( R.id.loggedIn ))
	    .check( matches( withText("Logged into GitHub")) ); // // <10>
    }
}
-----

<1> We use the same package name as our other activity classes.
<2> We then import the instrumentation registry (for instrumenting the
tests of our app), the base class, and matchers which will be used to
make assertions in our tests.
<3> We create a test class which derives from the
`ActivityInstrumentationTestCase2` generic. 
<4> The constructor of an Espresso tests implementation needs to call
the parent constructor with the class of the Activity for test, in
this case `MainActivity`. 
<5> Our test verifies that we can login to GitHub, so we name it accordingly.
<5> We then load the instrumentation registry, and also call
`getActivity`, which actually instantiates and starts the activity. In
many espresso tests these two steps will occur in a function annotated as
a `@Before` function if they are used across multiple tests (in which
case they will be run before each test). Here to simplify our funciton
count we can call them inside the single test function.
<6> We now are interacting with the UI of our application under
test. With the `onView` function we can interact with a view (for
example: a button or text field). `withId` finds the view using the
resource identifier inside the XML layout files. Once we have the
view, we can then perform an action (using the `perform` function)
like typing in text. This chain of calls enters the GitHub username
into the first text field.
<8> It is never a good idea to store credentials inside of a code
repository, so we retrieve the password from a resource XML file using the
`getString` function available using the activity. We will show the
contents of this secret file presently.
<9> We then complete our interaction with the UI, entering in the
password and then clicking the login button.
<10> If all is successful, we should see the text "Logged into
GitHub".

To provide a password to our test and to keep this password out of our
source code, create a file called `secrets.xml` inside our `strings`
directory inside the resource folder. This file should look like this.

[source,java]
-----
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="github_helper_password">MyPwd123</string>
</resources>

-----

Make sure this is not checked into your source code by
adding an exception to `.gitignore`. Run the command `echo
"secrets.xml" >> .gitgnore` to do this.

We can now run our tests with the command `gradle
connectedAndroidTest`. Much like before, as we have not yet
implemented the code to back these tests, we will get a failure
report, similar to the one we saw with our unit tests.

We have created our tests; let's now build the application itself to
pass these tests.

=== Application Implementation

Now we can start writing some Java code. Our `MainActivity` now can
implement the functionality to use the two layouts we defined early on.

[source,java]
-----
package com.githubru;

import android.app.Activity;
import android.os.Bundle;
import android.widget.Button;
import android.widget.LinearLayout;
import android.widget.EditText;
import android.widget.TextView;
import android.view.View;

public class MainActivity extends Activity
{
    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main); 

        Button login = (Button)findViewById( R.id.login ); // <1>
        login.setOnClickListener(new View.OnClickListener() {
                public void onClick(View v) {
                    login(); // <2>
                }
            });
    }

    private void login() {

        setContentView(R.layout.logged_in); // <3>

        Button submit = (Button)findViewById( R.id.submit );
        submit.setOnClickListener(new View.OnClickListener() {
                public void onClick(View v) {
                    doPost(); // <4>
                }
            });
    }

    private void doPost() {
        TextView tv = (TextView)findViewById( R.id.status ); // <5>
        tv.setText( "Successful jekyll post" );
    }

}

-----

This code mocks out the functionality we will be building and shows us
exactly what the UI will look like once that code is completed.

<1> We register a click handler for our login button.
<2> When the login button is clicked, we call the `login()` function.
<3> Once we have logged in, we inflate the logged in layout, suitable
for making a blog post.
<4> We then setup another click handler for the submit button; when
clicked, we call the `doPost()` function.
<5> Our `doPost()` function updates the status message at the bottom
of our application.

Even though our code is not functionally complete, this application will
compile. This is a good time to play with this application and verify
the UI looks appropriate. Were we to click the
login button, we would see that our blog post form looks like this.

image::images/android-calabash-logged-in.png[A simple UI for making blog post entries]

Our UI test will pass were we to run it now. Our unit test will not as
we have not yet implemented access to the GitHub API.

==== Code to Login to GitHub

Let's first work on the `login()` function. Poking into the
https://github.com/eclipse/egit-github/tree/master/org.eclipse.egit.github.core[EGit
libary reference], we can write GitHub login code that is as simple as
the following.  

[source,java]
-----
//Basic authentication
GitHubClient client = new GitHubClient();
client.setCredentials("user", "passw0rd");
-----

The context in which the code runs makes as much a difference as the
code. The Android OS disallows any code from making network
connections unless it runs inside a background thread.
If your eyes are starting to spin at the thought of learning about
threading using Java, dispell your worries. The Android SDK provides a
great class for managing background thread code called `AsyncTask`. We
implement a class which supports this interface by overriding at least one function
which runs our background thread code (called `doInBackground()`). 

Before we implement the login, we need to update our `onCreate`
function to register a click  handler that will call the login task we
will define. 

[source,java]
-----
...
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main); 

        Button login = (Button)findViewById( R.id.login ); 
        login.setOnClickListener(new View.OnClickListener() {
                public void onClick(View v) {
                    EditText utv = (EditText)findViewById( R.id.username ); 
                    EditText ptv = (EditText)findViewById( R.id.password );
                    username = (String)utv.getText().toString();
                    password = (String)ptv.getText().toString(); // // <1>
                    TextView status = (TextView)findViewById( R.id.login_status ); 
                    status.setText( "Logging in, please wait..." ); // // <2>
                    new LoginTask().execute( username, password );  // // <3>
                }
            });
    }
...
-----

<1> We retrieve the username and password from our UI elements. 
<2> Our UI should notify the user that a login is occurring in a
background task, so we grab the status text element and update the text in it. 
<2> We then start the background thread process to do our login. This
syntax creates a new thread for us with the username and password as
parameters. Android will manage the lifecycle of this thread for us,
including starting the new thread separate from the main UI thread.

Now we can implement `LoginTask`. 

[source,java]
-----
...
    class LoginTask extends AsyncTask<String, Void, Boolean> {   // // <1>
        @Override
            protected Boolean doInBackground(String... credentials) { // // <2>
            boolean rv = false;
            UserService us = new UserService();
            us.getClient().setCredentials( credentials[0], credentials[1] ); 
            try {
                User user = us.getUser( credentials[0] );  // // <3>
                rv = null != user;
            }
            catch( IOException ioe ) {}
            return rv;
        }
        
        @Override
            protected void onPostExecute(Boolean result) {
            if( result ) {
                loggedIn();  // // <4>
            }
            else { // // <5>
                TextView status = (TextView)findViewById( R.id.login_status );
                status.setText( "Invalid login, please check credentials" ); 
            }
        }
    }
...
-----

<2> Here we define the derived AsyncTask class. The three types in the
generics signature provide a way to parameterize our instantiated task;
we need to provide a username and password to the background task, and
the first type in the signature allows us to pass an array of Strings.
You can see in the actual function definition that the ellipsis notation
provides a way to parameterize a function with a variable number of
arguments (called varargs). Inside our defined function we expect we
will send two Strings in, and we make sure to do that in our call.
<5> Once inside the `doInBackground()` function, we instantiate a
`UserService` class, a wrapper around the GitHub API which interacts
with the user service API call. In order to access this information,
we have to retrieve the client for this service call and provide the
client with the username and password credentials. This is the syntax
to do that.
<6> We wrap the call to `getUser()` in a try block as the function
signature can throw an error (if the network were down, for example).
We don't really need to retrieve information about the user using the
User object, but this call verifies that our username and password are
correct and we store the result of the call in our return value.
GitHub will not use the credentials you set until you make an API
call, so we need to use our credentials to access something in order
to verify those credentials work.
<7> We renamed the `login()` function to more accurately reflect the
fact that when we call this, we are already logged into GitHub.
<8> If our login was a failure, either because of network failure, or
because our credentials were incorrect, we indicate this in the status
message. A user can retry if they wish.

`loggedIn` updates the UI once logging in has completed and then makes
the post on GitHub. Once again, we will need to implement `doPost` in an
asynchronous task since it makes network connections.

[source,java]
-----
...
    private void loggedIn() {

        setContentView(R.layout.logged_in);  // // <1>

        Button submit = (Button)findViewById( R.id.submit );
        submit.setOnClickListener(new View.OnClickListener() {
                public void onClick(View v) {
                    doPost();  // // <2>
                }
            });
    }
...
-----

<1> Change the UI to reflect the fact we are now logged in.
<2> If we click on the button, make the post to the server.

Building out `doPost` should be more familiar now that we have
experience with AsynchronousTasks.

[source,java]
-----
...
    private void doPost() {
        new PostTask().execute( username, password ); 
    }

    class PostTask extends AsyncTask<String, Void, Boolean> {  

        @Override 
        protected Boolean doInBackground(String... credentials) {
            String login = credentials[0]; 
            String password = credentials[1];

            EditText post = (EditText)findViewById( R.id.post );
            String postContents = post.getText().toString();

            EditText repo = (EditText)findViewById( R.id.repository ); 
            String repoName = repo.getText().toString();

            GitHubHelper ghh = new GitHubHelper( login, password ); // // <1>
            return ghh.SaveFile( repoName, postContents );
        }
        
        @Override
        protected void onPostExecute(Boolean result) {
            TextView status = (TextView)findViewById( R.id.post_status );
            if( result ) {
                status.setText( "Successful jekyll post" );
            }
            else {
                status.setText( "Post failed." ); 
            }
        }
    }
...
-----

<1> We will create a helper class that will wrap our interactions with
GitHub. We'll call it `GitHubHelper`.

We need to import the support
classes. The JARs and classes for EGit have already been added to our project
automatically using gradle. Make sure you add these `import`
statements to the top of the file, under the other imports.

[source,java]
-----
...
import android.view.View;
import android.os.AsyncTask;
import org.eclipse.egit.github.core.service.UserService;
import org.eclipse.egit.github.core.User;
import java.io.IOException;
...
-----

Now we are ready to write the code to write data into GitHub.

==== Code to talk to GitHub

Our last step is to write the code which handles putting content into GitHub.
This is not a simple function, because the GitHub API requires you
build out the structure used internally by Git. A great reference for learning more about
this structure is the free and open source book called "Pro Git" and
specifically the last chapter called
http://git-scm.com/book/en/Git-Internals[Git Internals]. 

In a nutshell, the GitHub
API expects you to create a git "tree" and then place a "blob" object
into that tree. You then wrap the tree in a "commit" object and then
create that commit on GitHub using a data service wrapper. In
addition, writing a tree into GitHub requires knowing the base SHA
identifier, so you'll see code which retrieves the last SHA in the
tree associated with our current branch. This code will work
regardless of whether we are pushing code into the master branch, or
into the gh-pages branch, so this utility class works with real
Jekyll blogs. It would be lovely if the GitHub API provided more
"porcelain" (the Git term for user friendly verbs that insulate you
from knowing the internals of Git) instead of only this "plumbing" API.
Having the API work like this does give you full control over your
repository and gives you the same power you would have with a local 
repository. 

We'll write a helper class called `GitHubHelper` and add a single
function which writes a file to our repository.

The GitHub API requires that files stored in a repositories be
either Base64 encoded or UTF-8. The Apache Foundation provides a suite of tools
published to Maven (the same software repository where we grabbed the
EGit libraries) which can do this encoding for us, and which were
already installed in our Gradle file above (the "commons-codec" declaration).

Our new helper class is verbose but at least provides a simple wrapper
around the complicated GitHub API for us. 

[source,java]
-----
package com.ghru;

import android.util.Log;

import org.eclipse.egit.github.core.*;
import org.eclipse.egit.github.core.client.GitHubClient;
import org.eclipse.egit.github.core.service.CommitService;
import org.eclipse.egit.github.core.service.DataService;
import org.eclipse.egit.github.core.service.RepositoryService;
import org.eclipse.egit.github.core.service.UserService;
import org.apache.commons.codec.binary.Base64;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.io.IOException;
import java.util.*;

class GitHubHelper {

    String login;
    String password;

    GitHubHelper( String _login, String _password ) {
        login = _login;
        password = _password;
    }

    public void SaveFile( String _repoName, 
			  String _title, 
			  String _post, 
			  String _commitMessage ) throws IOException {
        post = _post;
        repoName = _repoName;
        title = _title;
        commitMessage = _commitMessage;

        generateContent();
        createServices();
        retrieveBaseSha();
        createBlob();
        generateTree();
        createCommitUser();
        createCommit();
        createResource();
        updateMasterResource();
    }

...
-----

The `SaveFile` function goes through each step of writing data into
a repository using the GitHub API. We will walk through each of these
functions. As you can see, the `SaveFile` function has the same
signature as our unit test uses.

Let's implement each of the functions specified in the
GitHubHelper class.

=== Writing the blog content

First, we implement `generateContent()`. The following code snippet
shows functions defined to generate the content which we will place
into our remote git repository stored on GitHub.

[source,java]
-----
...
    String commitMessage; // // <1>
    String postContentsWithYfm;
    String contentsBase64;
    String filename;
    String post;
    String title;
    String repoName;

    private void generateContent() { // // <2>
        postContentsWithYfm =  // // <3>
	    "---\n" +
	    "layout: post\n" +
	    "published: true\n"
	    "title: '" + title + "'\n---\n\n" +
	    post;
        contentsBase64 =  // // <4>
	    new String( Base64.encodeBase64( postContentsWithYfm.getBytes() ) );
        filename = getFilename();
    }

    private String getFilename() {
        String titleSub = title.substring( 0,  // // <5>
					   post.length() > 30 ? 
					   30 : 
					   title.length() );
        String jekyllfied = titleSub.toLowerCase() // // <6>
	    .replaceAll( "\W+", "-")
	    .replaceAll( "\W+$", "" );
        SimpleDateFormat sdf = new SimpleDateFormat( "yyyy-MM-dd-" ); // // <7>
        String prefix = sdf.format( new Date() );
        return "_posts/" + prefix + jekyllfied + ".md"; // // <8>
    }
...
-----

You will notice many similarities between this Java code and the
Ruby code we used in the Jekyll chapter when generating filenames
and escaping whitespace.

<1> First, we setup several instance variables we will use when
storing the data into GitHub: the commit message, the full post
including the YAML Front Matter (YFM), the post contents encoded as
Base64, the filename, the post itself (which we saved when we called
`SaveFile`), the title (also a parameter to `SaveFile`) and the
repository name (again, a parameter to `SaveFile`).
<2> The `generateContent` function creates the content for our
addition: the filename, and the raw contents and the contents Base64 encoded.
<3> Here we create the YAML Front Matter (see the <<Jekyll>> chapter for more
details on YFM). This YAML specifies the "post" layout and sets
publishing to "true". We need to terminate the YAML with two newlines.
<4> Base64 encode the contents of the blog post
itself using a utility class found inside the Apache Commons
library. Contents inside a git repository are stored either as UTF-8
content or base64; we could have used UTF-8 since this is text content
but base64 works losslessly and you can always safely use base64
without concerning yourself about the content.
<5> Next, inside `getFilename()`, create the title by using the first
30 characters of the post.
<6> Convert the title to lowercase, and replace whitespace with
hyphens to get the Jekyll post title format.
<7> Jekyll expects the date to be formatted as `yyyy-MM-dd`, so use
the java `SimpleDateFormat` class to help in creating a string of that format.
<8> Finally, create the filename from all these pieces, prepending
`_posts` to the filename, where Jekyll expects posts to reside.

One exercise for the reader: what happens if there is no "master"
branch? It is a convention, not a guarantee, that a repository has a
"master" branch, but this code relies on the assumption it is
there. For production code, we probably want to create a test that
validates this edge case and adjust our function to handle it gracefully
if the "master" branch does not exist.

=== Services 

Next, we implement `createServices()`. There are several services
(wrappers around git protocols) which we need to instantiate. We don't
use them all immediately, but we will need them at various steps
during the file save process. The `createServices` call manages these
for us. 

[source,java]
-----
...
    RepositoryService repositoryService;
    CommitService commitService;
    DataService dataService;

    private void createServices() throws IOException {
        GitHubClient ghc = new GitHubClient();
        ghc.setCredentials( login, password );
        repositoryService = new RepositoryService( ghc );
        commitService = new CommitService( ghc );
        dataService = new DataService( ghc );
    }

...
-----

=== The Base SHA from the Repository and Branch

Now we implement `retrieveBaseSha()`. A git repository is a directed acrylic graph (DAG) and as such, each
node in the graph must have a starting point. When we append content
to our graph, we need to determine the starting point on that
graph. `retrieveBaseSha` does this: it finds the SHA hash for our
starting point, a SHA hash which is functionally an address inside our
tree. To determine this address, our applications needs to have a reference to the
repository, and we use the repository service we instantiated
earlier to get this reference. Once we have the repository, we need to look inside the
correct branch: `getBranch` does this for us. 

[source,java]
-----
...

    Repository repository;
    RepositoryBranch theBranch;
    String baseCommitSha;
    private String retrieveBaseSha() throws IOException {
        // get some sha's from current state in git
        repository =  repositoryService.getRepository(login, repoName);
        theBranch = getBranch(); 
        return theBranch.getCommit().getSha();
    }

    public RepositoryBranch getBranch() throws IOException {
	List<RepositoryBranch> branches = repositoryService.getBranches(repository);
	RepositoryBranch master = null;
	// Iterate over the branches and find gh-pages or master
	for( RepositoryBranch i : branches ) {
	    String theName = i.getName().toString();
	    if( theName.equalsIgnoreCase("gh-pages") ) {
		theBranch = i;
	    }
	    else if( theName.equalsIgnoreCase("master") ) {
		master = i;
	    }
	}
	if( null == theBranch ) {
	    theBranch = master;
	}
	return theBranch;
    }

...
-----

=== Creating the Blob

Contents inside a git repository are stored as blobs. `createBlob`
manages storing our content as a blob object, and then uses the
dataService to store this blob into a repository. Until we have called
`dataService.createBlob`, we have not actually placed the object
inside GitHub. Also, remember that blobs are not linked into our DAG
by themselves; they need to be associated with our DAG vis-a-vis a
tree and commit object, which we do next.

[source,java]
-----
...

    Blob blob;
    Tree baseTree;
    private void createBlob() throws IOException {
	Random random = new Random();
	blob = new Blob();
	blob.setContent(contentsBase64);
	blob.setEncoding(Blob.ENCODING_BASE64);
	dataService.createBlob(repository, blob);
    }
    
...
-----

=== Generating a Tree

Next, we generate a tree by implementing `generateTree()`. A tree
wraps a blob object and provides basically a path to our object:
you can think of a tree as the filename path and the blob as an inode 
object. Our data service manager uses a repository name and a base SHA
address, one that we retrieved earlier, to validate that this is a
valid starting point inside our repository. Once we have a tree, we
fill out the necessary tree attributes, like tree type (blob) and and
tree mode (blob), and set the SHA from the previously created blob
object along with the size. Then we store the tree into our GitHub
account using the data service object. 

[source,java]
-----
...
    Tree baseTree;
    private void generateTree() throws IOException {
        baseTree = dataService.getTree(repository, baseCommitSha);
	TreeEntry treeEntry = new TreeEntry();
	treeEntry.setPath( filename );
	treeEntry.setMode( TreeEntry.MODE_BLOB );
	treeEntry.setType( TreeEntry.TYPE_BLOB );
	treeEntry.setSha(blobSha);
	treeEntry.setSize(blob.getContent().length());
	Collection<TreeEntry> entries = new ArrayList<TreeEntry>();
	entries.add(treeEntry);
	newTree = dataService.createTree( repository, entries, baseTree.getSha() );
    }

...
-----

=== Creating the Commit

We are getting close to actually finalizing the creation of content:
next, implement `createCommit()`. We have created
a blob which stores the actual content, and created a tree which
stores the path to the content (more or less), but since git is a
version control system, we also need to store information about who
wrote this object and why. A commit object stores this
information. The process should look familiar coming from the previous
steps: we create the commit and then add relevant metadata, in this case the
commit message. The "who" of this commit is inferred from our login:
GitHub knows that we authenticated and assigns this commit to us on
the server side. We then use the data service to create the commit
inside our repository in GitHub at the correct SHA address.

[source,java]
-----
...
    Commit newCommit;
    private void createCommit() throws IOException {
        // create commit
        Commit commit = new Commit();
        commit.setMessage( commitMessage );
        commit.setTree( newTree );
        List<Commit> listOfCommits = new ArrayList<Commit>();
        listOfCommits.add(new Commit().setSha(baseCommitSha));
        commit.setParents(listOfCommits);
        newCommit = dataService.createCommit(repository, commit);
    }

...
-----

Unfortunately, right as this book went into early release on the
O'Reilly website, this code stopped working.

=== Using MITM Proxy

Murphy's law says: "Whatever can go wrong, will go wrong." At the
eleventh hour, right at the moment when this book was entering
technical review, GitHub made a subtle change to their API which broke
the code in the previous section. Printing out the error from the response noted nothing
more than: "Invalid request. nil is not a string. nil is not a
string. (422)."  To troubleshooting the error I reached out to GitHub
support. GitHub support will not debug code samples, so they requested I send
them the API calls I made using cURL. The Java EGit GitHub library is
somewhat opaque and I was unable to determine a way to get back the
raw requests and responses from each service object
request. Fortunately, there is an easy way to capture and investigate
these network calls: utilize a man-in-the-middle proxy. 

We'll use a "mitmproxy," an open source man-in-the-middle
proxy. mitmproxy is written in Python, and installation is
straightforward with `pip` (Python package management system). To
install mitmproxy, use `pip install mitmproxy`. mitmproxy does require
that certain cryptographic libraries are installed, so if `pip install
mitmproxy` does not work, refer to the excellent documentation at
https://mitmproxy.org/[the mitmproxy website]. mitmproxy runs on OSX
or Linux, and you can install it on the same laptop on which runs your
Android emulator (which we recommend here).

Once mitmproxy is installed, usage is trivial: run the command
`mitmproxy` and then connect your proxy client to it. Android can
then be configured to use mitmproxy with the following command:

[source,bash]
-----
$ emulator -avd AvdName -http-proxy http://10.0.0.5:8080
-----

You would use your IP address instead of "10.0.0.5". mitmproxy works
by intercepting traffic from your device and then relaying it to the
intended destination. For this to work over HTTPS (the protocol on
which the GitHub API operates) you need to install the generated proxy
certificate. Visit the site "mitm.it" and if your device is configured
to use the proxy correctly, you will see a screen inviting you to
install the proxy certificate (you are not actually connecting to
mitm.it but to the mitmproxy). 

image::images/android-mitm-cert.png[Installing the mitmproxy certificate]

If you do not see this screen, and instead see a message stating "If
you can see this, traffic is not passing through mitmproxy." then you
are actually visiting the real site mitm.it and need to review your
network settings.

After choosing the Android icon, you will be prompted to save the
certificate; give it a name ("mitmproxy" fits) and click "OK." Now all
device network traffic will be routed through the proxy.

image::images/android-mitm-cert-name.png[Naming the mitmproxy certificate]

mitmproxy shows each HTTP protocol request sent, and has several
keyboard commands which allow you to inspect this traffic. Each
request is listed, and the up and down arrows keys move between the
different requests (or you can use "j" and
"k", the "VI" editor keybindings). 

image::images/android-mitm-login.png[Multiple requests inside of mitmproxy]

Once you have a request you are
interested in, hitting the "enter/return" key selects that
request. You are then presented with a request/response viewer. Using
the tab key will move between the full request, the full response
(allowing you to scroll down to see any of the headers, and the
response), as well as details of the connection, like SSL certificates.

image::images/android-mitm-inspect.png[Inspecting JSON using mitmproxy]

Using mitmproxy in between clients requests and API responses is a
great way to see what is actually sent by your client and what
is actually returned by the server. Once you have this raw
information in hand, it is easy to convert it into a cURL request if
necessary (like what you need when you contact GitHub support). 

With this information in hand, I was able to send off the raw request
and GitHub helped me isolate the issue to missing information inside
the commit object. A few months prior, GitHub did not require commits
to have an author name or email, but they now do. So, let's fix our
code to pull this information out of the user object and annotate our
commit request with it.

=== Fixing "createCommit"

[source,java]
-----
...
    CommitUser commitUser;
    private void createCommitUser() throws IOException {
        UserService us = new UserService(); // // <1>
        us.getClient().setCredentials( login, password );
        commitUser = new CommitUser(); // // <2>
        User user = us.getUser(); // // <3>
        commitUser.setDate(new Date());
        String name = user.getName();
        if( null == name || name.isEmpty() ) { // // <4>
            name = "Unknown";
        }

        commitUser.setName( name ); // // <5>
        String email = user.getEmail();
        if( null == email || email.isEmpty() ) {
            email = "unknown@example.com";
        }
        commitUser.setEmail( email );
    }

    Commit newCommit;
    private void createCommit() throws IOException {
        // create commit
        Commit commit = new Commit(); // // <6>
        commit.setMessage( commitMessage );
        commit.setAuthor( commitUser); // // <7>
        commit.setCommitter( commitUser );
        commit.setTree( newTree );
        List<Commit> listOfCommits = new ArrayList<Commit>();
        newCommit = dataService.createCommit(repository, commit);
    }
...
-----

<1> Create a user service object. We will use this to get back user
data for the logged in user from GitHub. 
<2> We then create a commit user. This will be used to annotate the
commit object (twice in fact, as we will use it for both the author
and committer).
<3> Retrieve the user from the service, loading it from GitHub.
<4> Now, attempt to get the name for the logged in user. If the name
does not exist (the user has not set a name in their GitHub profile)
set the name to unknown. Then, store the name in the commit user
object.
<5> Do the same process to establish the email for the commit user.
<6> Now, return to the `createCommit` function and create a commit
object. 
<7> Now, as our tests and troubleshooting proves, we need to use an
author and committer, so pass in the commit user we created in the
`createCommitUser` function. 

Now that we have a working commit structure created, we are almost
complete with our git data API call. We just need to create a resource
and update master with that information.

=== Creating the Resource and Updating the Master

Finally, we create `updateMasterResource()`. We need to adjust
"master" or "gh-pages", the branch from which GitHub will generate
your Jekyll blog. Previously, we determined the correct branch against which to apply our additions. GitHub
follows this convention when generating your Jekyll blog, using either
master or gh-pages as the checkout point for retrieving your content
and then doing a site rebuild from a working copy there. In our code,
we use the commit we created and stored in the previous code to
generate a commit resource, set the URL, and then use our data service
to update the reference inside the repository inside GitHub.

[source,java]
-----
...
    TypedResource commitResource;
    private void createResource() {
        commitResource = new TypedResource();            
        commitResource.setSha(newCommit.getSha());
        commitResource.setType(TypedResource.TYPE_COMMIT);
        commitResource.setUrl(newCommit.getUrl());
    }

    private void updateMasterResource() throws IOException {
        // get master reference and update it
        Reference reference = dataService.getReference(repository, "heads/" + theBranch.getName() );
        reference.setObject(commitResource);
        Reference response = dataService.editReference(repository, reference, true) ;
    }

...
-----

=== Implementing Our Final doPost

Finally, we can now implement the `doPost()` function inside our
`MainActivity` class.

[source,java]
-----
...
    private void doPost() {
        new PostTask().execute( username, password ); 
    }

    class PostTask extends AsyncTask<String, Void, Boolean> {  

        @Override 
            protected Boolean doInBackground(String... credentials) {
            String login = credentials[0]; 
            String password = credentials[1];

            EditText post = (EditText)findViewById( R.id.post );
            String postContents = post.getText().toString();

            EditText repo = (EditText)findViewById( R.id.repository ); 
            String repoName = repo.getText().toString();

            GitHubHelper ghh = new GitHubHelper( login, password );
            return ghh.SaveFile( repoName, postContents );
        }
        
        @Override
            protected void onPostExecute(Boolean result) {
            TextView status = (TextView)findViewById( R.id.post_status );
            if( result ) {
                status.setText( "Successful jekyll post" );
            }
            else {
                status.setText( "Post failed." ); 
            }
        }
    }


    
-----

Our `doPost()` command now does one thing: instantiates a new
PostTask. As we are performing network operations, we again create a
subclass of `AsyncTask` which handles these operations automatically
on a background thread. We pass in the username and password which we
retrieved earlier along with the post contents and the repository name
we specified. We've isolated our GitHub code into our helper class;
our MainActivity class does only the necessary steps to retrieve items
from UI elements and pass them on to our helper class.

=== Passing all our tests

Now, we can run both our unit tests and our UI tests and both will
pass. 

[source,bash]
-----
$ GITHUB_HELPER_PASSWORD=MyPwd123 gradle testDebugUnitTest
...
:app:mockableAndroidJar UP-TO-DATE
:app:assembleDebugUnitTest UP-TO-DATE
:app:testDebugUnitTest UP-TO-DATE

BUILD SUCCESSFUL
$ gradle connectedAndroidTest
...
:app:compileDebugAndroidTestNdk UP-TO-DATE
:app:compileDebugAndroidTestSources
:app:preDexDebugAndroidTest
:app:dexDebugAndroidTest
:app:packageDebugAndroidTest
:app:assembleDebugAndroidTest
:app:connectedDebugAndroidTest

BUILD SUCCESSFUL
-----

We can also install the application to our emulator or a real
device and play with it to write Jekyll blogs into GitHub.

[source,bash]
-----
$ gradle assembleRelease
$ adb install app/build/outputs/apk/app-release-unsigned.apk
-----

[NOTE]
If you want to see a more complicated version of the GitHub API on
Android, take a look at https://github.com/xrd/TeddyHyde.git[Teddy
Hyde] (also available on the Google Play Store). Teddy Hyde uses OAuth
to login to GitHub, and has a much richer set of features for editing
Jekyll blogs.

=== Summary

This application will allow you to write into a real Jekyll blog,
adding posts, upon which GitHub will regenerate your site. This little
application manages quite a few things: formatting the filename
correctly, encoding the data for submission to GitHub, and we have a
user interface test which verifies the functionality. We even
demonstrate how to write user interface tests which verify that the
result of a GitHub API call is proper handled on the server side.

In the next chapter we will look at building a single page application
that edits information inside a GitHub repository using JavaScript and
the GitHub.js library talking to the Pull Request API.