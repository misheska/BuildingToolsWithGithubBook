== Gollum

=== Using Gollum

Gollum is the GitHub contribution to open source wikis. A wiki is
defined as "a website that allows collaborative editing of its content
and structure by its users." Just as Git has revolutionized
collaborative editing of code, Gollum wikis layer the benefits of Git
onto a proven publishing metaphor.

==== Installing Gollum locally

You can edit Gollum wikis hosted on GitHub using only any web browser.
If you want to run Gollum locally, and there are many benefits to
doing so, then you need to install the gollum command line tools. 

[source,bash]
-------
$ gem install gollum
-------

You will then see the `gollum` command in your path.

[NOTE]
There is a difference between the `gollum` command (what you run from
the command line) and the suite of technologies that make up Gollum as
a project. To differentiate between them, remember that we are talking
about the suite when the word is capitalized ("Gollum"), and the command line
tool when the word is lowercased and fixed width font (`gollum`).

==== Many Editing Modalities

Editing Gollum content is flexible in that there are many ways to do
it, depending on what editing metaphor you prefer. Gollum wikis are editable locally
within a web browser: run the `gollum` command locally on your laptop
(which spawns a mini web server hosting your wiki) and then browse to
http://localhost:4567. Gollum wikis are editable remotely using a web
browser: edit on GitHub as just another repository using the standard
GitHub web enabled editor tools. And, gollum wikis can be edited at
the file system level using your favorite editor, allowing you the
flexibility of staying within the same workflow you use to edit any
other file within a local repository. 

You might use a hybrid approach to editing your Gollum wiki, switching
back and forth  between editing within the web browser interface and
jumping into the command line and using your editor to create or
modify files when you need to use "power commands."  

[WARNING]
Remember that Gollum only processes files that have been checked into
the repository; files which are only in the working directory or which
have been added to the index but not yet commited are *not* processed
by gollum. So, if you add a file using your editor or from the command
line, make sure you `git add` and `git commit` the files to see them
to make sure you see them in the browser interface.  

==== Editing Gotchas with the Command Line

To illustrate this "gotcha" let's imagine adding a sidebar to our wiki. Adding a sidebar means you need to create a file called _Sidebar.md. This is a special file which Gollum recognizes and generates a sidebar for you; the first part of the name is fixed, but you can change the extension to whatever extension you prefer for your wiki files. If we use the "open" command (available on Mac or Linux) to open the Wiki in our default browser, you will see that only once we have committed the change to our repository do we actually see the sidebar.

[source,bash]
-----
$ gollum & # Start gollum, will run on port 4567.
$ printf "## Warning\nPlease note this is subject to change" > _Sidebar.md
$ open http://localhost:4567/ # We won't see our sidebar yet...
$ git add _Sidebar.md 
$ open http://localhost:4567/ # We still don't see our sidebar...
$ git commit -m "Add sidebar"
$ open http://localhost:4567/ # Eureka, now we will see our sidebar!
-----

If you edit within the web browser interface, the underlying grit
libraries do all the work to commit new files into the repository. If
you use the command line, you'll need to remember to commit files
manually to see them inside your wiki.

==== Editing Gollum Wikis Anytime, Anywhere

Gollum adds all the powerful features that automatically come with
usage of a DCVS; you can edit your files offline, which is simply not
the case with most wikis. If you check out your gollum repository and
then hop on a plane without a wifi connection, you can edit files as
you would any other Git repository. Once you have landed, you do the
normal pull/push sequence as you would do with any other repository.
If others have modified the repository, you use your standard tools
within a normal Git workflow to merge those changes and deal with
conflicts.

A word of caution when using the gollum command in server mode to edit
files locally inside a web browser. If you start the gollum server
from the command line you do have the capability to edit the files
from any computer within the same network. In other words, you could
find your IP address and use that address from your Chromebook or your
tablet to view and edit your wiki. However, remember that the gollum
server command does not have an authentication system built into it,
which means that gollum thinks anyone accessing the wiki is the same
user that started the gollum command. This is fine if you are in the
other room editing on your tablet while gollum runs on your work
laptop. However, the gollum server is not a good solution for offering
a wiki up to many people within a subnet. If multiple people edit
files, there is no way that gollum can track the different user
contributions in the change log. This is not a problem when editing
your Gollum wiki inside GitHub.com: the GitHub site knows who you are
and properly assigns your changes to your username inside the
change log.  

==== Hacking Gollum

Gollum is a great way to build up living documentation of any project.
As everything is built on Git, you get history for free, and more
importantly, a way to extract that history using all your familiar Git
tools, either within the command line, or from GitHub. We've explored
how easy it is to edit Gollum wikis: from within the command line,
from the web browser, or from within GitHub. However, there might be
times when you need to provide an entirely customized editing modality. As long
as you write files into the repository in the way the gollum libraries
understand, you can write your own editing interface to suit your own
needs. Let's build one and dive deeper.

===== Adding Authentication 

There are solutions to managing authentication if you self host a
Gollum wiki. As Gollum is built on top of Sinatra (a ruby library) you
can utilize authentication gems like `omnigollum` or write your own
authentication handler and run gollum inside that. 
http://stackoverflow.com/questions/9634703/strong-access-control-for-gollum/13357591#13357591:[This
thread on StackOverflow]
explains how to install your own handler:
 
[source,ruby]
-------
# authentication.rb
module Precious
  class App < Sinatra::Base
    use Rack::Auth::Basic, "Restricted Area" do |username, password|
      [username, password] == ['admin', 'admin']
    end
  end
end
-------

And, then run it using this command:

[source,bash]
-----
gollum --config authentication.rb
-----

You'll then be prompted for the username and password, and can use
"admin" and "admin". 

Hackers love to use puns and wordplay within their code. If you peek
into the Gollum code itself, you'll see that the Gollum libraries use
a namespace called "Precious" (the word used to refer to the ring by
the character Gollum in the Lord of the Rings books) as the base class
for the Gollum wrapper around Sinatra. This code extends the instance
of Sinatra running your Gollum wiki and adds an authentication layer.

===== Documenting Wireframe Discussions: Needs versus Reality

If you do much software development within a team
you will find this idealized scenario: a
business person develops the structure of the application with
higher-up stakeholders, these ideas are passed down to a  UI/UX
designer who then creates wireframes and mockups of the interactions,
and then a software developer takes these wireframes and builds the
software. Put another way, executives figure out what features provide
the most value to users, which then trickles 
down into the wireframes as real interactions. Many hidden blocking
paths are fleshed out here, places where the application would confuse
the user, and time is saved because the software developer does not
have to waste time building something that would not work anyway. By
the time it reaches the developer, the UI interaction is streamlined
and the costly and inflexible stage of building software has all the
inefficiencies optimized away. The developer can simply work on a
piece of software and know there are no changes, changes which would
be extremely costly to implement. 

In practice, this process is never so smooth. What typically happens
is the business people never completely understand all the
requirements, and ask for changes, which trickle down into the
designs. The mockups are changed and this then needs to be
communicated to the developer, who has already started building
something that was "set in stone." Or, the developer, as they build
the software, realize there are missing steps to get to places inside
the application, and they need to communicate this back to the
designer. If you have multiple people doing software development on a
project, this information then needs to fan out to them if their areas
are affected by these changes. This information must traverse many
different people, with many different methods of communication. 

Wikis are a great way to store this information. Information which changes. Information which must be retrieved
by many people and edited by many people. What better than to manage
these informational transitions than a change tracking system like
Git, and what better way to absorb this information than a Wiki built
on top of Git, hosted on GitHub.

===== A Simple Wireframe Review Tool

Let's build a simple tool which stores these types of changes. We'll build an image editor that hosts changes 
to UI mockups. This will give our executives a place where they can see changes and updates. This will allow
our UI designer a place to store their images and annotate them with vital information. And, we'll have a place
where developers can retrieve information without reviewing their email and wondering "Do I have the most
up-to-date mockups?" We'll buid a special interface which allows quickly editing and reviewing these files locally. 
And all of it can be published into GitHub for review (though we won't allow editing of the information there,
since GitHub has its own editing modality.)

Gollum is built on ruby and uses the grit library underneath. It is
simplest to use Ruby to build this, so let's use Sinatra, a super
simple web server framework for Ruby. In fact, coincidentally, the
`gollum` command is a customized wrapper around Sinatra, so getting to
know Sinatra better is not a bad thing anyway.

This will be a dual purpose repository. We can use it with gollum as
a standard wiki. And, we can use it with our application to enter data
in a more powerful way than gollum permits from its default interface.
The data will still be compatible with gollum and will be hosted on
GitHub.

To begin, initialize our repository.

[source,bash]
$ mkdir images
$ cd images
$ git init .
$ printf "### Our home" > Home.md
$ git add Home.md
$ git commit -m "Initial checking"

We've just created a wiki compatible with gollum. Let's see what it
looks like inside gollum. run the `gollum` command then open
`http://localhost:4567/` in your browser.

image::images/gollum-first-view.png[]

As you can see, this tiny set of commands was enough to create the
basics of the gollum wiki structure.

Create our sinatra script called `image.rb`, and then we can install
the necessary gems and run our server application.

[source,ruby image.rb]
require 'sinatra'
require 'gollum-lib'
wiki = Gollum::Wiki.new(".")
get '/pages' do
  "All pages: \n" + wiki.pages.collect { |p| p.path }.join( "\n" )
end

[source,bash]
$ printf "source 'https://rubygems.org'\n\ngem 'sinatra'\ngem 'gollum-lib'" >> Gemfile
$ bundle install
$ ruby image.rb
$ open http://localhost:4567 # or whatever URL is reported from Sinatra

Once you open this in your browser, you'll see a report of the files
that exist in our Gollum wiki right now. We've only added one file,
the `Home.md` file.

#### Unpack Images from a Zip File

Let's add to our server. We want to support uploading ZIP files into
our system that we will then unpack and add to our repository, as well
as adding a list of these files to our wiki. Modify our image.rb
script to look like this:

[source,ruby]
-----
require 'sinatra'
require 'gollum-lib'
require 'tempfile'
require 'zip/zip'
require 'rugged'

def index( message=nil )
  response = File.read(File.join('.', 'index.html'))
  response.gsub!( "<!-- message -->\n", "<h2>Received and unpacked #{message}</h2>" ) if message
  response
end

wiki = Gollum::Wiki.new(".")
get '/' do
  index()
end

post '/unpack' do
  @repo = Rugged::Repository.new('.')
  @index = Rugged::Index.new

  zip = params[:zip][:tempfile]
  Zip::ZipFile.open( zip ) { |zipfile|
    zipfile.each do |f|
      contents = zipfile.read( f.name )
      filename = f.name.split( File::SEPARATOR ).pop
      if contents and filename and filename =~ /(png|jp?g|gif)$/i
        puts "Writing out: #{filename}"
      end
    end
    build_commit()
  }
  index( params[:zip][:filename] )
end  

-----

This server
script receives a POST request at the `/unpack` mount point and
retrieves a ZIP file from the parameters passed into the script. It
then opens the ZIP file (stored as a temp file on the server side),
iterates over each file in the ZIP, and writes them to the images
directory, stripping the file names down to a simple name without
subdirectories and converting whitespace to underscores. Pretty
advanced for 21 lines of code, no?

We need to add an additional ruby library to enable this application,
so update the required gems using the following commands, and then re-run
our Sinatra server script.

[source,bash]
$ printf "gem 'rubyzip'\n" >> Gemfile
$ bundle install
$ ruby image.rb

If we visit `http://localhost:4567/` in our browser we will see a
crash. Our sinatra script complains that the `index.html` file does
not exist. Let's create that file, named `index.html`.

[source,html]
------
<html>
<body>
<form method='POST' enctype='multipart/form-data' action='/upload'>
Choose a zip file: 
<input type='file' name='zip'/>
<input type='submit' name='submit'>
</form>
</body>
</html>
------