== Gollum

=== Using Gollum

Gollum is the GitHub contribution to open source wikis. A wiki is
defined as "a website that allows collaborative editing of its content
and structure by its users." Just as Git has revolutionized
collaborative editing of code, Gollum wikis layer the benefits of Git
onto a proven publishing metaphor.

==== Installing Gollum locally

You can edit Gollum wikis hosted on GitHub using only any web browser.
If you want to run Gollum locally, and there are many benefits to
doing so, then you need to install the gollum command line tools. 

[source,bash]
-------
$ gem install gollum
-------

You will then see the `gollum` command in your path.

[NOTE]
There is a difference between the `gollum` command (what you run from
the command line) and the suite of technologies that make up Gollum as
a project. To differentiate between them, remember that we are talking
about the suite when the word is capitalized ("Gollum"), and the command line
tool when the word is lowercased and fixed width font (`gollum`).

==== Many Editing Modalities

Editing Gollum content is flexible in that there are many ways to do
it, depending on what editing metaphor you prefer. Gollum wikis are editable locally
within a web browser: run the `gollum` command locally on your laptop
(which spawns a mini web server hosting your wiki) and then browse to
http://localhost:4567. Gollum wikis are editable remotely using a web
browser: edit on GitHub as just another repository using the standard
GitHub web enabled editor tools. And, gollum wikis can be edited at
the file system level using your favorite editor, allowing you the
flexibility of staying within the same workflow you use to edit any
other file within a local repository. 

You might use a hybrid approach to editing your Gollum wiki, switching
back and forth  between editing within the web browser interface and
jumping into the command line and using your editor to create or
modify files when you need to use "power commands."  

[WARNING]
Remember that Gollum only processes files that have been checked into
the repository; files which are only in the working directory or which
have been added to the index but not yet commited are *not* processed
by gollum. So, if you add a file using your editor or from the command
line, make sure you `git add` and `git commit` the files to see them
to make sure you see them in the browser interface.  

==== Editing Gotchas with the Command Line

To illustrate this "gotcha" let's imagine adding a sidebar to our wiki. Adding a sidebar means you need to create a file called _Sidebar.md. This is a special file which Gollum recognizes and generates a sidebar for you; the first part of the name is fixed, but you can change the extension to whatever extension you prefer for your wiki files. If we use the "open" command (available on Mac or Linux) to open the Wiki in our default browser, you will see that only once we have committed the change to our repository do we actually see the sidebar.

[source,bash]
-----
$ gollum & # Start gollum, will run on port 4567.
$ printf "## Warning\nPlease note this is subject to change" > _Sidebar.md
$ open http://localhost:4567/ # We won't see our sidebar yet...
$ git add _Sidebar.md 
$ open http://localhost:4567/ # We still don't see our sidebar...
$ git commit -m "Add sidebar"
$ open http://localhost:4567/ # Eureka, now we will see our sidebar!
-----

If you edit within the web browser interface, the underlying grit
libraries do all the work to commit new files into the repository. If
you use the command line, you'll need to remember to commit files
manually to see them inside your wiki.

==== Editing Gollum Wikis Anytime, Anywhere

Gollum adds all the powerful features that automatically come with
usage of a DCVS; you can edit your files offline, which is simply not
the case with most wikis. If you check out your gollum repository and
then hop on a plane without a wifi connection, you can edit files as
you would any other Git repository. Once you have landed, you do the
normal pull/push sequence as you would do with any other repository.
If others have modified the repository, you use your standard tools
within a normal Git workflow to merge those changes and deal with
conflicts.

A word of caution when using the gollum command in server mode to edit
files locally inside a web browser. If you start the gollum server
from the command line you do have the capability to edit the files
from any computer within the same network. In other words, you could
find your IP address and use that address from your Chromebook or your
tablet to view and edit your wiki. However, remember that the gollum
server command does not have an authentication system built into it,
which means that gollum thinks anyone accessing the wiki is the same
user that started the gollum command. This is fine if you are in the
other room editing on your tablet while gollum runs on your work
laptop. However, the gollum server is not a good solution for offering
a wiki up to many people within a subnet. If multiple people edit
files, there is no way that gollum can track the different user
contributions in the change log. This is not a problem when editing
your Gollum wiki inside GitHub.com: the GitHub site knows who you are
and properly assigns your changes to your username inside the
change log.  

==== Hacking Gollum

Gollum is a great way to build up living documentation of any project.
As everything is built on Git, you get history for free, and more
importantly, a way to extract that history using all your familiar Git
tools, either within the command line, or from GitHub. We've explored
how easy it is to edit Gollum wikis: from within the command line,
from the web browser, or from within GitHub. However, there might be
times when you need to provide an entirely customized editing modality. As long
as you write files into the repository in the way the gollum libraries
understand, you can write your own editing interface to suit your own
needs. Let's build one and dive deeper.

==== Limits of Gollum Locally

Gollum is a great tool when working locally. However, there is a bug
currently where images are not displayed, so although you can fully
edit files using the local `gollum` command, you will not be be able
to view them when viewing your wiki on you local machine. To view
files, publish them into GitHub.

===== Adding Authentication 

There are solutions to managing authentication if you self host a
Gollum wiki. As Gollum is built on top of Sinatra (a ruby library) you
can utilize authentication gems like `omnigollum` or write your own
authentication handler and run gollum inside that. 
http://stackoverflow.com/questions/9634703/strong-access-control-for-gollum/13357591#13357591:[This
thread on StackOverflow]
explains how to install your own handler:
 
[source,ruby]
-------
# authentication.rb
module Precious
  class App < Sinatra::Base
    use Rack::Auth::Basic, "Restricted Area" do |username, password|
      [username, password] == ['admin', 'admin']
    end
  end
end
-------

And, then run it using this command:

[source,bash]
-----
gollum --config authentication.rb
-----

You'll then be prompted for the username and password, and can use
"admin" and "admin". 

Hackers love to use puns and wordplay within their code. If you peek
into the Gollum code itself, you'll see that the Gollum libraries use
a namespace called "Precious" (the word used to refer to the ring by
the character Gollum in the Lord of the Rings books) as the base class
for the Gollum wrapper around Sinatra. This code extends the instance
of Sinatra running your Gollum wiki and adds an authentication layer.

===== Documenting Wireframe Discussions: Needs versus Reality

If you do much software development within a team
you will find this idealized scenario: a
business person develops the structure of the application with
higher-up stakeholders, these ideas are passed down to a  UI/UX
designer who then creates wireframes and mockups of the interactions,
and then a software developer takes these wireframes and builds the
software. Put another way, executives figure out what features provide
the most value to users, which then trickles 
down into the wireframes as real interactions. Many hidden blocking
paths are fleshed out here, places where the application would confuse
the user, and time is saved because the software developer does not
have to waste time building something that would not work anyway. By
the time it reaches the developer, the UI interaction is streamlined
and the costly and inflexible stage of building software has all the
inefficiencies optimized away. The developer can simply work on a
piece of software and know there are no changes, changes which would
be extremely costly to implement. 

In practice, this process is never so smooth. What typically happens
is the business people never completely understand all the
requirements, and ask for changes, which trickle down into the
designs. The mockups are changed and this then needs to be
communicated to the developer, who has already started building
something that was "set in stone." Or, the developer, as they build
the software, realize there are missing steps to get to places inside
the application, and they need to communicate this back to the
designer. If you have multiple people doing software development on a
project, this information then needs to fan out to them if their areas
are affected by these changes. This information must traverse many
different people, with many different methods of communication. 

Wikis are a great way to store this information. Information which changes. Information which must be retrieved
by many people and edited by many people. What better than to manage
these informational transitions than a change tracking system like
Git, and what better way to absorb this information than a Wiki built
on top of Git, hosted on GitHub.

===== A Simple Wireframe Review Tool

Let's build a simple tool which stores these types of changes. We'll build an image editor that hosts changes 
to UI mockups. This will give our executives a place where they can see changes and updates. This will allow
our UI designer a place to store their images and annotate them with vital information. And, we'll have a place
where developers can retrieve information without reviewing their email and wondering "Do I have the most
up-to-date mockups?" We'll buid a special interface which allows quickly editing and reviewing these files locally. 
And all of it can be published into GitHub for review (though we won't allow editing of the information there,
since GitHub has its own editing modality.)

Gollum is built on ruby and uses the grit library underneath. It is
simplest to use Ruby to build this, so let's use Sinatra, a super
simple web server framework for Ruby. In fact, coincidentally, the
`gollum` command is a customized wrapper around Sinatra, so getting to
know Sinatra better is not a bad thing anyway.

This will be a dual purpose repository. We can use it with gollum as
a standard wiki. And, we can use it with our application to enter data
in a more powerful way than gollum permits from its default interface.
The data will still be compatible with gollum and will be hosted on
GitHub.

To begin, initialize our repository.

[source,bash]
$ mkdir images
$ cd images
$ git init .
$ printf "### Our home" > Home.md
$ git add Home.md
$ git commit -m "Initial checking"

We've just created a wiki compatible with gollum. Let's see what it
looks like inside gollum. run the `gollum` command then open
`http://localhost:4567/` in your browser.

image::images/gollum-first-view.png[]

As you can see, this tiny set of commands was enough to create the
basics of the gollum wiki structure.

Create our sinatra script called `image.rb`, and then we can install
the necessary gems and run our server application.

[source,ruby image.rb]
require 'sinatra'
require 'gollum-lib'
wiki = Gollum::Wiki.new(".")
get '/pages' do
  "All pages: \n" + wiki.pages.collect { |p| p.path }.join( "\n" )
end

[source,bash]
$ printf "source 'https://rubygems.org'\n\ngem 'sinatra'\ngem 'gollum-lib'" >> Gemfile
$ bundle install
$ ruby image.rb
$ open http://localhost:4567 # or whatever URL is reported from Sinatra

Once you open this in your browser, you'll see a report of the files
that exist in our Gollum wiki right now. We've only added one file,
the `Home.md` file.

#### Unpack Images from a Zip File

Let's add to our server. We want to support uploading ZIP files into
our system that we will then unpack and add to our repository, as well
as adding a list of these files to our wiki. Modify our image.rb
script to look like this:

[source,ruby]
-----
require 'sinatra'
require 'gollum-lib'
require 'tempfile'
require 'zip/zip'

def index( message=nil )
  response = File.read(File.join('.', 'index.html'))
  response.gsub!( "<!-- message -->\n", "<h2>Received and unpacked #{message}</h2>" ) if message
  response
end

wiki = Gollum::Wiki.new(".")
get '/' do
  index()
end

post '/unpack' do
  @repo = Rugged::Repository.new('.')
  @index = Rugged::Index.new

  zip = params[:zip][:tempfile]
  Zip::ZipFile.open( zip ) { |zipfile|
    zipfile.each do |f|
      contents = zipfile.read( f.name )
      filename = f.name.split( File::SEPARATOR ).pop
      if contents and filename and filename =~ /(png|jp?g|gif)$/i
        puts "Writing out: #{filename}"
      end
    end
  }
  index( params[:zip][:filename] )
end  

-----

We'll need an `index.html` file as well, so add that.

[source,ruby]
-----
<html>
<body>
<!-- message -->
<form method='POST' enctype='multipart/form-data' action='/unpack'>
Choose a zip file: 
<input type='file' name='zip'/>
<input type='submit' name='submit'>
</form>
</body>
</html>

-----

This server
script receives a POST request at the `/unpack` mount point and
retrieves a ZIP file from the parameters passed into the script. It
then opens the ZIP file (stored as a temp file on the server side),
iterates over each file in the ZIP, strips the full path from the
filename, and then prints out that filename (if it looks like an image)
to our console. Regardless of whether we are accessing the 
root of our server, or have just posted to the `/unpack` mount point,
we always need to render our index page. When we do render it after
unzipping, we replace a comment stored in the index file with a status
message indicating the script received the correct file we posted.

We need to add an additional ruby library to enable this application,
so update the required gems using the following commands, and then re-run
our Sinatra server script.

[source,bash]
$ printf "gem 'rubyzip'\n" >> Gemfile
$ bundle install
$ ruby image.rb

Then, we can open `http://localhost:4567/` and test uploading a file
full of images. You'll see output similar to this in your console
after uploading a file.

[source,bash]
----
...
[2014-05-07 10:08:49] INFO  WEBrick 1.3.1
[2014-05-07 10:08:49] INFO  ruby 2.0.0 (2013-05-14)
[x86_64-darwin13.0.0]
== Sinatra/1.4.5 has taken the stage on 4567 for development with
backup from WEBrick
[2014-05-07 10:08:49] INFO  WEBrick::HTTPServer#start: pid=46370
port=4567
Writing out: IMG1234.png
Writing out: IMG5678.png
Writing out: IMG5678.png
...
----

#### Adding Git Support

Our end goal for this script is to add files to our Gollum wiki, which
means adding files to the repository which backs our Gollum wiki.
The Rugged library handles the grunt work of this type of task easily. 
Rugged is the successor to the original Ruby library for Git (called
Grit). Rugged provides a binding between the libgit2 library,
a "portable, pure C implementation of the Git core methods" but Rugged is
written in Ruby and gives you the simple elegance of Ruby. As you
might expect, Rugged is maintained by several employees of GitHub. 

To change our script to modify our Git repository, modify the `puts`
statement inside the zip loop to call a new method called
`write_file_to_repo`. And, at the end of the zip block, add a method
called `build_commit` which builds the commit from our new files. Our
new file (omitting the unchanged code at the head of the file) looks
like this.

[source,ruby]
-----
post '/unpack' do
  @repo = Rugged::Repository.new('.')
  @index = Rugged::Index.new

  zip = params[:zip][:tempfile]
  Zip::ZipFile.open( zip ) { |zipfile|
    zipfile.each do |f|
      contents = zipfile.read( f.name )
      filename = f.name.split( File::SEPARATOR ).pop
      if contents and filename and filename =~ /(png|jp?g|gif)$/i
        write_file_to_repo contents, filename # Write the file
      end
    end
    build_commit() # Build a commit from the new files
  }
  index( params[:zip][:filename] )
end  

def get_credentials
  contents = File.read File.join( ENV['HOME'], ".gitconfig" )
  @email = $1 if contents =~ /email = (.+)$/
  @name = $1 if contents =~ /name = (.+)$/
end

def build_commit
  get_credentials()
  options = {}
  options[:tree] = @index.write_tree(@repo)
  options[:author] = { :email => @email, :name => @name, :time => Time.now }
  options[:committer] = { :email => @email, :name => @name, :time => Time.now }
  options[:message] ||= "Adding new images"
  options[:parents] = @repo.empty? ? [] : [ @repo.head.target ].compact
  options[:update_ref] = 'HEAD'

  Rugged::Commit.create(@repo, options)
  
end

def write_file_to_repo( contents, filename )
  oid = @repo.write( contents, :blob )
  @index.add(:path => filename, :oid => oid, :mode => 0100644)
end
-----

As you can see from the code above, Rugged handles a lot of the grunt
work required when creating a commit inside a Git repository. Rugged has a
simple interface to creating a blob inside your Git repository
(`write`), adding files to the index (the `add` method), and
then has a simple and clean interface to build the tree object
(`write_tree`) and then build the commit (`Rugged::Commit.create`). 

The astute observers among you will notice a method called
`get_credentials` which loads up your credentials from a file located
in your home directory called `.gitconfig`. You probably have this if
you have used Git for anything at all on your machine, but if this
file is missing, this method will fail. On my machine this file looks
like the following code snippet. The `get_credentials` method simply loads up this
file and parses it for the name and email address. If you wanted to
load the credentials using another method, or even hard code them, you
can just modify this method to suit your needs. The instance variables
`@email` and `@name` are then used in the `build_commit()` method.

[source,ini]
----
[user]
        name = Chris Dawson
        email = xrdawson@gmail.com
[credential]
        helper = cache --timeout=3600
...
----

Just to double check that everything worked properly, let's verify
that things are working correctly after uploading a ZIP file. Jumping
into a terminal window after uploading a new file, imagine running
these commands:

[source,bash]
----
$ git status
----

To our surprise, we will see something like this:

[source,bash]
-----
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

  deleted:    images/3190a7759f7f6688b5e08526301e14d115292a6e/IMG_20120825_164703.jpg
  deleted:    images/3190a7759f7f6688b5e08526301e14d115292a6e/IMG_20130704_151522.jpg
  deleted:    images/3190a7759f7f6688b5e08526301e14d115292a6e/IMG_20130704_174217.jpg

-----

We just added those files; why is Git reporting them as deleted?

To understand why this happens, remember that in Git there are three
places where files can reside: the working directory, the staging
area or index, and the repository itself. Your working directory is
the set of local files which you are working on. The `git status`
command describes itself as "show the working tree status." Rugged
operates on the repository itself, and our Rugged calls above operated
on the index and then built a commit. This is important to note
because our files will not exist in our working directory if we only
write them using the Rugged calls, and if we do this, we cannot
reference them inside our wiki page when we are running Gollum
locally. We'll fix this in the next section.

##### Adding to our Wiki

We've now added the files to our repository, but we have not exposed
these files inside our wiki. Let's modify our server script to write
out each file to a wiki page for review. As we mentioned in the
previous section, we need to make sure that we write the files to both
the working index and the repository (using the Rugged library `write`
call). Then we can generate a Review file which details all the images
uploaded.

##### Git Handles Duplicates Gracefully

Often while a designer is receiving feedback from stakeholders, they
will incorporate that feedback into the UI comps, and then resend the
set of comps, with only a tiny change in one file, where the remaining
dozens or even hundreds of files have been left unchanged. We might
assume that our code, as it writes these files to a different path on
disk inside the repository (the path is the parent SHA hash to make it
unique) and we could therefore be adding the same 
file multiple times, and creating a big wasteful repository. However,
the nature of git permits us to add the same file multiple times
without incurring any additional storage cost beyond the first
addition. When a file is added to git repository, a SHA hash is
generated from the file contents. For example, generating the SHA hash
from an empty file will always return the same SHA
hash.footnote:[This is explained
beautifully in the blog
http://alblue.bandlem.com/2011/08/git-tip-of-week-objects.html.]

[source,bash]
-----
$ echo -en "blob 0\0" | shasum
e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
$ printf '' | git hash-object -w --stdin
e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
-----

Adding a zip file with a bunch of files where only one
or two differs from the prior zip file means that Git will properly
reference the same file multiple times. Unfortunately, GitHub does not provide
an interface for reviewing statistics of Wikis in the same way that
they do for regular repositories. We can, however, review our
repository size from within the local repository by running the
count-objects Git subcommand. As an example, I uploaded a ZIP file
with two images inside of it. I then use the 
count-objects command and see this:

[source,bash]
-------
$ git gc
...
$ git count-objects -v
count: 0
size: 0
in-pack: 11
packs: 1
size-pack: 2029
prune-packable: 0
garbage: 0
size-garbage: 0
-------

Inspecting the first ZIP file, I see these statistics about it.

[source,bash]
-----
$ unzip -l ~/Downloads/Photos\ \(4\).zip 
Archive:  /Users/xrdawson/Downloads/Photos (4).zip
  Length     Date   Time    Name
 --------    ----   ----    ----
  1189130  01-01-12 00:00   IMG_20130704_151522.jpg
   889061  01-01-12 00:00   IMG_20130704_174217.jpg
 --------                   -------
  2078191                   2 files
-----

I then use another ZIP file which has one additional file, with the
other two included files exactly identical.

[source,bash]
-----
unzip -l ~/Downloads/Photos\ \(5\).zip 
Archive:  /Users/xrdawson/Downloads/Photos (5).zip
  Length     Date   Time    Name
 --------    ----   ----    ----
  1189130  01-01-12 00:00   IMG_20130704_151522.jpg
   566713  01-01-12 00:00   IMG_20120825_164703.jpg
   889061  01-01-12 00:00   IMG_20130704_174217.jpg
 --------                   -------
  2644904                   3 files

-----

Then, I upload the second ZIP file. If I re-run the count-object
command (after running `git gc`, a command which packs files
efficiently and makes our output more human readable), I see this:

[source,bash]
----
$ git gc
...
$ git count-objects -v
count: 0
size: 0
in-pack: 17
packs: 1
size-pack: 2578
prune-packable: 0
garbage: 0
size-garbage: 0
----

Notice that our packed size has only changed by about half a MB, which
is the compressed size of the additional third file.

If we upload the secondary file yet again, we will regenerate and
commit a new version of the `Review.md` file, but no new files will
need to be created inside our Git repository object store from the
images directory (even though their paths have changed), so our 
impact on the repository will be minimal.

[source,bash]
-----
$ git gc
...
$ git count-objects -v
count: 0
size: 0
in-pack: 21
packs: 1
size-pack: 2578
prune-packable: 0
garbage: 0
size-garbage: 0
-----

As you can see, our packed-size has barely changed, an indication that
the only changes were a new Git tree object and commit object. We
still do have the files located in our repository at a variety of
paths so our review pages will work no matter what revision we are accessing.

[source,bash]
-----
$ find images
images
images/7507409915d00ad33d03c78af0a4004797eec4b4
images/7507409915d00ad33d03c78af0a4004797eec4b4/IMG_20120825_164703.jpg
images/7507409915d00ad33d03c78af0a4004797eec4b4/IMG_20130704_151522.jpg
images/7507409915d00ad33d03c78af0a4004797eec4b4/IMG_20130704_174217.jpg
images/7f9505a4bafe8c8f654e22ea3fd4dab8b4075f75
images/7f9505a4bafe8c8f654e22ea3fd4dab8b4075f75/IMG_20120825_164703.jpg
images/7f9505a4bafe8c8f654e22ea3fd4dab8b4075f75/IMG_20130704_151522.jpg
images/7f9505a4bafe8c8f654e22ea3fd4dab8b4075f75/IMG_20130704_174217.jpg
images/b4be28e5b24bfa46c4942d756a3a07efd24bc234
images/b4be28e5b24bfa46c4942d756a3a07efd24bc234/IMG_20130704_151522.jpg
images/b4be28e5b24bfa46c4942d756a3a07efd24bc234/IMG_20130704_174217.jpg
-----

Git and Gollum can efficiently store the same file at different paths
without overloading the repository.

#### Reviewing on GitHub

The raison d'etre for this wiki is to annotate a development project.
Since you are reading a book about GitHub, let's assume that you are
hosting the code for this project on GitHub. Now that we have started
adding images into our wiki, we might want to share that wiki in a
public and more accessible way with our
stakeholders on GitHub. The easiest way to synchronize our local
repository-as-wiki with a GitHub repository is to visit the
code repository, and click on the wiki link, and then create a new
wiki. For example, imagine I am working on a project called
"android-project1". My username is "xrd", so on GitHub I would
reference this project at the URL
`http://github.com/xrd/android-project1`. 

image::images/gollum-android-project1.png[]

Notice that in the right column a link called "Wiki". Clicking on this
shows us the entry page for our wiki which is empty. We can create a
new wiki by clicking on the button marked "Create the first page". It
might seem strange to do this given that we already have a wiki in our
local repository, but GitHub needs to perform initialization on its
end before it permits us to push our repository into it.

image::images/gollum-android-project1-create.png[]

Clicking on the button brings us to an editor page which allows us to
enter the first version of the Home page of our wiki. We don't need to
do anything here, but we could offer instructions to less technical
people about how to use the review pages, etc. But, it is acceptable
to just click the "Save Page" button at the bottom of the page. Once
you have done this, you will see the wiki home page, and more
importantly, a box with the clone URL labeled "Clone this wiki
locally". In our example case, this URL is
`git@github.com:xrd/android-project1.wiki.git`. 

Entering our terminal window we can then add a remote URL to our local
repository which allows us to synchronize our repositories and publish
our changes to GitHub.

[source,bash]
-----
$ git remote add origin git@github.com:xrd/android-project1.wiki.git
$ git pull # This will require us to merge the changes...
$ git push
-----

When we pull, we will be asked to merge our changes since GitHub
created a `Home.md` file which did not exist in our local repository.
We can just accept the merge as-is. The `git push` publishes our
changes. If we then visit the wiki, we'll see an additional file
listed under the pages sidebar to the right. Clicking on the review
page, we can see the images we've added most recently.

image::images/gollum-android-project1-review.png[]

Not sure why our designer is providing us with an image of a couch,
but I am sure he has his reasons.

If you note the "3 commits" listed under the "Review" title, this is
where we can review changes made. 

image::images/gollum-android-project1-revisions.png[]

Clicking on any of the SHA hashes will display the page at that
revision in our history and show us the state of the app at any given
moment in history. Unfortunately, jumping back and forth between
revisions requires two clicks, one from the review page to the list of
revisions, and then another click to jump into the revision we want,
but this permits us to review changes between the comps provided from
our designer. It would be nice if GitHub provided a simple way to jump
from a revision to the parent (older) revision, but they don't expose
this in their site as of this writing. But, we can fix this.

#### Improving Revision Navigation

We only have three revisions right now, and all share the same commit
message ("Adding new images"). This is not very descriptive and makes
it challenging to understand the differences between revisions,
critical when we are trying to understand how things have changed
between comps. We can improve this easily.

First, let's add a commit message field to our upload form.

[source,html]
-----
<html>
<body>
<!-- message -->
<form method='POST' enctype='multipart/form-data' action='/unpack'>
Choose a zip file: 
<input type='file' name='zip'/>
<input type='text' name='message' placeholder='Enter commit message'/>
<input type='submit' name='submit'>
</form>
</body>
</html>

-----

Then, let's adjust the commit message inside our `image.rb` script,
which is a one line change to the options hash, setting the value of
it to the parameter we are now passing in for "commit".

[source,ruby]
-----
  ...
  options[:committer] = { :email => @email, :name => @name, :time => Time.now }
  options[:message] = params[:message]
  options[:parents] = @repo.empty? ? [] : [ @repo.head.target ].compact
  ...
-----

Now, if our designer posts a new version of the UI comps, they can
specify what changes were made, and we have a record of that in our
change log, exposed on the revisions section of our wiki hosted on GitHub.

#### Fixing Linking Between Comp Pages

We noted that there is no quick way to jump between comps once we are
inside a review revision. However, if you recall we used the parent
SHA hash to build out our image links. We can use this to build out a
navigation inside our comp page when we are on a revision page while
viewing the history.

Again, it is a simple change: one line within the `write_review_file`
method. After the block which creates each link to the image files,
add a line which builds a link to the parent document
via its SHA hash. This link will allow us to navigate to prior
revisions in our history.

[source,ruby]
-----
  ...
  files.each do |f|
    contents += "### #{f} \n[[#{dir}/#{f}]]\n\n"
  end
  contents += "[Prior revision (only when viewing history)](#{@repo.head.target})\n\n"

  File.write review_filename, contents
  oid = @repo.write( contents, :blob )
  ...
-----

Now, when we view the Review file history, we see a file with a link
at the bottom to the link to each prior version. Is it possible to
provide a link to the next version in our history? Unfortunately, we
have no way to predict the SHA hash of the next commit made to the
repository, so we cannot build this link inside our `Review.md` file
with our ruby script. However, we do get something just as good for
free because we can simply use the back button to jump back to the
prior page in the history stack of our browser. It would be nice if we
could generate this link alongside the link we placed into the wiki
markup, and we could do this using a link that runs an onclick handler
delegating to a JavaScript command like
`window.history.back()`, but Gollum foils us again by
stripping JavaScript from our markup files. This is a good thing
generally, as we don't want to permit rogue markup inside our wiki
pages, but it does limit our options in this situation.

Unfortunately, these links do not work when you are viewing the review file itself
(clicking on them brings you to a page which asks you to create this
as a new page). Gollum, unlike Jekyll, does not support Liquid
tags which would permit building a link using the username and
repository. Right now we don't have access to these variables, so our
link needs to be relative, which works when we are in history review,
but not in the normal review. It does not affect viewing the files so
this would require educating your stakeholders on the limitations of
this link.

### Summary

Gollum provides a powerful front end to wikis. Combining the power of
a distributed versioning system, and simple Git libraries like Rugged,
offers an elegant way to manage content for both highly technical
people and those less technical.