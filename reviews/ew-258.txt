CHAPTER 10: CoffeScript, Hubot and the Activities API


                          These requests all failed; our Probot is not correctly configured to handle re-
                       al HTTP requests from GitHub. This does show that GitHub is trying to do some-
                       thing when a pull request is received. We’ll work on getting our handler code

                       written and pushed into Heroku, and then issue another PR.


                       Handling PR Notifications as Post Requests over HTTP


                       Let’s build our HTTP handler when PRs notifications arrive from GitHub. At first
                       glance, we might take the easy route, adding it directly into the top level script.

                       But, given the fact that JavaScript handles events inside of callbacks and the
                       fact that Hubot extensions only export a single constructor (using the  mod-

                       ule.exports   syntax) it is easier to create, and more importantly test, a sepa-
                       rate module which we require in our main extension script.

                          We start by writing our tests. We’ve already created a test which verifies the
                       call torobot.router.post    . Our new functionality will actually handle the PR

                       notification, so let’s add a new grouping using the describe syntax and call it
                       “#pr”. The new functionality is simple: if the Probot receives the proper parame-
                       ters (most importantly that the internal secret matches the secret sent on the

                       request) then we accept the PR as valid and message our room with further in-
                       structions, namely inviting some user to review this pull request. Our handler

                       then needs to expose two methods:    prHandler   which is where we delegate
                       any information coming from an HTTP request to the   /pr route, and a method

                       where we can configure the secret, which we callsetSecret  . Once we have es-
                       tablished this internal signature for our handler library, we can add two simple

                       tests and then our library.
                          We have two tests: one which handles the correct flow and one which han-

                       dles the incorrect flow. In a before block (this happens before each test) we set-
                       up a fake robot, and set the secret on our handler module. Our faked robot im-
                       plements the same methods that a real Hubot robot does (the “messageRoom”

                       and “send” methods), but we create Jasmine spies to verify these functions are
                       called inside our implementation code.


                          describe "#pr", ->
                                   secret = "ABCDEF"
                                   robot = undefined

                                   res = undefined

                                   beforeEach ->
                                            robot = {
                                                    messageRoom: jasmine.createSpy()

                                                    }
                                            res = { send: jasmine.createSpy() }
                                            Handler.setSecret secret




        258