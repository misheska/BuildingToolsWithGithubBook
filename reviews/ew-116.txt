CHAPTER 6: DotNet and the Commit Status API


                        Summary


                        Even if you haven’t written a lot of code during this chapter, you’ve learned a lot
                        of concepts.

                           You’ve seen the commit status API, and you’ve seen how it’s used by contin-
                        uous integration software, but you know that it can be used for much more. You

                        can read and write statuses, and you know how the API server coalesces many
                        statuses into a single pass/fail value, and you also know how to write your own
                        multi-status calculation if the default one doesn’t meet your needs. You also

                        know what’s behind the green checkmarks and red X’s you see in your pull re-
                        quests.

                           You’ve learned how the OAuth web flow works, and why it’s designed the
                        way it is. OAuth is the key to many other capabilities of the GitHub API, and it’s
                        the right thing to do with regards to trust and permissions. This will allow you

                        to write truly world-class GitHub-interfacing applications, whether running on
                        the web or on a user’s device.

                           You’ve gained a passing knowledge of C#, including its package system, at
                        least one IDE, lambda functions, object initializers, and more. C# really is a nice

                        language, and if you use it for a while, you’ll probably miss some of its features
                        if you write in anything else.
                           You’ve seen NuGet, the .NET package manager, and had a peek at the multi-

                        tudes of packages in this ecosystem. The capability you have here is astound-
                        ing; libraries exist for many common activities, and lots of uncommon ones too,

                        so no matter what you need to do, you’re likely to find a NuGet package to help
                        you do it.

                           You’ve learned about Nancy, with which you can quickly build any HTTP ser-
                        vice, from a REST API to an HTML-based interface, and all with a compact syn-
                        tax and intuitive object model. If you’ve never been exposed to the Sinatra view

                        of the world, this probably makes you think about web servers a bit differently,
                        and if you have, you’ll have a new appreciation for how this model can be idio-

                        matically implemented.
                           And you’ve had an introduction to Octokit, a type-safe implementation of a
                        REST API, with built-in asynchrony and OAuth helpers. This toolkit really does

                        make working with the GitHub API as simple and straightforward as using
                        any .NET library, including the ability to explore it using Intellisense.

                           In the next chapter we will look at using Ruby to create and build Jekyll
                        blogs.











        116