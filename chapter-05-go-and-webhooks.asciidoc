== Go and Github Webhooks

=== Why Go and GitHub?

Go was originally developed as a systems language and it still serves
that purpose well. Yet, beyond just hidden system tools, there is a
niche developing where forward facing developers want to put GitHub to
work in other more integrated ways. Go stands as a competent language
for wiring together developer tools and processes. With very little
effort and with elegant code, Go acts as a perfect glue language for
systems programming tasks like wiring in an issue tracker API to a
continuous integration system. And, the GitHub API has great language
bindings for Go.

In this chapter we will explore creating a webhook using Go and the
GitHub libraries. Along the way we will show how the GitHub libraries
for Go support common Go idioms and dig deeper into the way these
libraries work.

=== About Go

Over the last couple years the Go programming language has been on a
meteoric rise in popularity. Conceived in 2007 Go's main purpose was
to increase a programmers efficiency in their day-to-day work. Go's
standard library comes with built in modern tools to excel in today's
web focus clustered multicore environments.

Go is all about making the programmer's life easier. With built in
support for JSON, HTML, HTTP, templating and concurrency Go is ready
for any project.

Describing Go to another programmer often feels like being the host of
infomercial. Remember those long compile times? Gone! Remember the
endless bickering over formatting and documentation? Gone!

Documentation and formatting are taken care of at the language level.
Getting the documentation for a particular library is as easy as going
to godoc.org. Making sure your code is formatted properly is as easy
as `go fmt`.

=== Go Getting Started

Luckily if you're new to Go it's has a very user friendly installation
process.

Visit: http://golang.org/doc/install

I would recommend using an installer. You can also download an archive
or source and install it manually. The package install is nice in that
it will take care of almost everything for you. You can download it
at:

http://golang.org/dl/

I would also recommend the latest "stable" version. At the time of
writing this the latest stable version is 1.3.1. Also make sure you
grab the right one for your architecture and OS.

=== GOPATH

There is one very important environment variable that we will discuss
next: GOPATH

The `GOPATH` environment variable is a comma delimited list of
locations where go will look for packages. It is where the source for
your code with live alone with the code you need to import to run your
code. Each location in the `GOPATH` needs to have three specific
directories in it: bin, src and pkg.

The `bin` directory is where the compiled binaries live.

The `pkg` directory has all the installed package objects. You'll
rarely have to go into the pkg directory yourself. If peek in you'll
find a subdirectory for each operating system and architecture the
packages that were build for it.

Finally the `src` directory. This is where you'll spend most of your
time. Nested in the `src` directory is the import path for each
package.

For our use case we're going to keep it simple and have just one
location in our `GOPATH`. Depending on how you installed Go you might
already have GOPATH set.

To check run:

[source,bash]
-----
  $ echo $GOPATH
-----

This will print of the current value of the GOPATH environment
variable. Lets set our GOPATH to a subdirectory in our `HOME`
directory:

[source,bash]
-----
  $ export GOPATH=$HOME/go
-----

This would be a good time to add the line above your bash/zsh profile
so when you start your next terminal session GOPATH is set for you.

=== Introduction to Github webhooks

Until now most of the interaction we've had with Github is pushing,
viewing or requesting information from github. Us telling github what
to do. Webhook are the opposite. Github will send our server
information when events happen on Github's servers.

https://developer.github.com/webhooks/

Github webhooks provide the ability for your service to get data
pushed from Github. When and event happens on Github your service will
get notified. By setting up a webhook you're telling github: when
something happens tell me. There are a couple ways to setup these
hooks but we're going to ask Github to send us JSON describing the
event. The JSON or "payload" Github will send us will contain
information about what event happened, when and to which repository.

To view all supported events visit:
https://developer.github.com/webhooks/#events

=== Our Project

You can use these webhooks to start builds, notifiy your team on
commits or anything else your mind can come up with. For our project
we are going to make a server that will run `make test` on any new
commit. Anytime we push a new commit to our repositoty Github will
send our server the information about the new commit, our
server will pull down the code an run the test to make sure we haven't
broken anything.

Think of it as our own custom travis CI.

To make our web server we'll need to be able to connect and interact
with the Github api. For this we'll use `go-github` written by Google.
You can find the sounce code here:

https://github.com/google/go-github

To get you acclimatized to Go's ecosystem lets look at the godoc for
this libary. To view the documentation **prepend** "godoc.org" into
the url:

https://godoc.org/github.com/google/go-github

GoDoc has he ability to generate documentation for Go packages hosted
on Bitbucket, GitHub, Launchpad and Google Project Hosting. It's an
amazing tool. One, if you plan on taking up Go, you should get
accustom to.

We will only be using one of the sections in the package.

WebHookPayload: http://godoc.org/github.com/google/go-github/github#WebHookPayload

But take a minute to look over the `github` package documentation. You
can see just about everything in Github's API is mapped out here.

## Go get

** TODO `go get`

## Project structure

Time to start writing some Go code. Let setup our workspace so we can
get started.

The go tool is setup to work with open source software. When you
import packages into you actually use the public location of the
code in your code to import the package.

For example when we import Google's go-github package we will write:

```go
import "github.com/google/go-github"
```

The location of the package locally mirrors the package's location on
the public internet. Inside our `src` directory Google's go-github
package will be located in:


[source,bash]
-----
src/github.com/google/go-github
-----

As you can see go code's directory structure is intrinsically linked
to the public location of the code. Our project should do the same.
On Github create a new project call "gowebhooks". The URL for your
project should be 'http://github.com/{yourusername}/gowebhooks'.

[source,bash]
-----
src/github.com/jpoz/gowebhooks
-----

To create the directory we will run:

[source,bash]
-----
$ mkdir -p $GOPATH/src/github.com/{yourusername}/gowebhooks
-----

And move into our project directory:

[source,bash]
-----
$ cd $GOPATH/src/github.com/{yourusername}/gowebhooks
-----

Now lets talk about the structure of the files within our project
directory. We going to build a web server. The webserver will be able
to be run by an executable. The executable will be build with a package
we will import.

We will also have a 'public' directory to host static files such as the
output of our server running the test for a project.

Below is how we'll have our project structured:

[source]
-----
.
├── cmd
│   └── gowebhooks-server
│       └── gowebhooks.go
├── public
└── server.go
-----

To create the structure above run the following commands:

[source,bash]
-----
  $ touch server.go
  $ mkdir -p cmd/gowebhooks-server
  $ mkdir -p public
  $ touch cmd/gowebhooks-server/gowebhooks.go
-----

We could write our whole server in one file but then we would be
restricted to only using the 'main' package. We want to create an
executable and all executables need to be in the 'main' package.
Building our server and related code in its own package allows it to
have the ability to be imported into other projects. Maybe not totally
needed for this project but is a good practice.

Our executable will be pretty simple. Just a file to load in our
package and start it up.

cmd/gowebhooks-server/gowebhooks.go

[source,go]
-----
package main

import (
	"fmt"

	"github.com/{yourusername}/gowebhooks"
)

func main() {
	err := gowebhooks.StartServer()
	fmt.Println(err)
}
-----

[Warning]
Remember to replace '{yourusername}' with your username.

Our `server.go` file will have the code actually needed to startup our
server. To start lets make sure Go is installed properly and setup a
very simple webserver.

server.go

[source,go]
-----
package gowebhooks

import (
	"fmt"
	"net/http"
)

func StartServer() {
	staticFileServer := http.FileServer(http.Dir("./public"))
	http.Handle("/", staticFileServer)

	fmt.Println("Listening on 4567")
	http.ListenAndServe(":4567", nil)
}
-----

This server will host all the files in './public'. Lets add a hello
file for testing purposes.

[source,bash]
-----
$ echo "Hello from Go!" > public/hello
-----

Lets run our project to make sure we've got everything working. In our project
directory lets run:

[source,bash]
-----
$ go run cmd/gowebhooks-server/gowebhooks.go
-----

Navigate your browser to http://localhost:4567/hello and you should
see a page greeting you.

## Receiving webhooks from Github

First step in receiving webhooks is turning them on at github.com.
Navigate to your gowebhooks repository on Github.

In the settings panel you'll find "Webhooks & Services". There you
should find a "Add Webhook" button. Click it and lets get started.

image::images/go-webhook.png[]

### Setting up a tunnel

To create our webhook we need to provide a "Payload URL". In this case
we're going to want github to send webhooks to our local computer.
Giving github "localhost" won't do us any good. Since we're not on the
same network as github's servers. We need a public address for our
local computer. To allow github to have connectivity to our local
computer we'll need to tunnel a public address to our local computer.

The Github documentation recommends "ngrok.com" for this task. Ngrok
runs a small daemon on our local machine that tunnels traffic back and
forth to a public address on their site. So any traffic that hits the
given unique address provided by ngrock will be proxied from ngrok.com
to our local machine. Visa versa, if we send anything to the daemon it
will be proxied to ngrok.com and sent by their servers.

To get ngrok install follow the instructions at
"https://ngrok.com/download". Or if you're a homebrew user:

[source, bash]
-----
brew install ngrok
-----

We want to proxy all traffic from port 80 (default http port) from
ngrok to our server's port locally, port 4567.

[NOTE]
Quick warning before we start up ngrok.
When we start ngrok port 4567 on our local machine will be accessible
to the **entire** internet. Sound a little scary but ngork gives us a
unique subdomain and we can always shutdown the daemon to close the
connection.

To start tunneling traffic run:

[source, bash]
-----
$ ngrok 4567
-----

You should see the tunnel starting up and tunnel status of "online".
Below that should be your unique ngrok url. The url should look
something like: http://1a2b3c4d.ngrok.com/hello

Leave ngrok running in a terminal window. In another terminal window
navigate back to your project directory and restart your server:

[source, bash]
-----
$ go run cmd/gowebhooks-server/gowebhooks.go
-----

Now navigate your browser to your unique ngrok url. You should see the
same page as when you connected to the sever locally.

### Setting the Payload URL

We can now tell Github where to send our webhooks. Go back to your
repository's "Add webhook" page and enter in your unique ngrok url
followed by `/webhook`. For me that's: `http://1a2b3c4d.ngrok.com/webhook`.

Make sure the content type is `application/json` and set the secret to
something you'll remember. Something like: "DangerZone". We'll just be
working with push events. So you can leave "Just the push event"
selected. Click "Add webhook" to save your settings.

image::images/go-webhook-payload-url.png[]

## Setting up our webhooks endpoint

We that Github has the ability to `POST` to us via the tunnel. Now we
need to decide what we want to do with the information Github gives us.

We will need to do a few things in our `webhookHandler`

1. Check what type of Event we're getting from Github.
2. Read the body of JSON in the request.
3. Parse the JSON into something Go can use.
4. Pass the parsed JSON on to something that can run the tests.

Below is the entire `server.go`. Notice it has some lines commented out.

Those lines will be explained later.

[source, go]
----
package gowebhooks

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"

	"github.com/google/go-github/github"
)

func webhookHandler(w http.ResponseWriter, r *http.Request) {
	eventHeader := r.Header.Get("X-GitHub-Event")

	fmt.Printf("Received: %s\n", eventHeader)

	switch eventHeader {
	case "ping":
		fmt.Fprint(w, "pong")
	case "push":
		body, err := ioutil.ReadAll(r.Body)
		if err != nil {
			fmt.Println(err)
			return
		}

		payload := github.WebHookPayload{}
		json.Unmarshal(body, &payload)

    // We will uncomment this once you've defined GithubProject
		// githubProject := GithubProject{payload}

    // We will uncomment these once you've defined ProjectTestRunner
		// runner := ProjectTestRunner{githubProject}
		// runner.RunAndWriteTo("./public")

		fmt.Fprintf(w, "Recieved and Parsed %s", *payload.HeadCommit.ID)
	default:
		fmt.Fprintf(w, "Don't know how to handle a %s event\n", eventHeader)
	}
}

func StartServer() error {
	publicFileServer := http.FileServer(http.Dir("./public"))
	http.Handle("/", publicFileServer)
	http.HandleFunc("/webhook", webhookHandler)

	fmt.Println("Listening on 4567")
	return http.ListenAndServe(":4567", nil)
}
----

### Key take aways for server.go

#### Handler arguments

In Go you can pass functions as arguments. In the `StartServer` function
we're passing the `webhookHandler` function as the second argument. We
can do this because the function conforms to the method signature defined
in `http.HandleFunc`.

If `webhookHandler` did not take a `http.ResponseWriter` as the first
argument and a `*http.Request` as the second argument we would get a
compilation error.

The `http.ResponseWriter` is used to respond and how `webhookHandler`
sends information back to Github. The ResponseWriter conforms to the
io.Writer interface. We'll go over interfaces a bit more later,
but conforming to the io.Writer interface basically means
`http.ResponseWriter` has a `Write(byte)` function.

We will use the Fprintf function in the 'fmt' package (which takes a
`io.Writer` as its first argument) to write back to Github.

The `http.Request` holds all the information Github posted over to us.

[NOTE]
For more information on the net/http package: http://golang.org/pkg/net/http/

#### io/ioutil

The `io/ioutil` package defines a bunch of helpful functions to deal
with files and other io objects. In `server.go` the package is used
to read the JSON body sent from Github so it can be parsed.

#### JSON parsing

JSON is built into the standard Go library via the `encoding/json`
package. To decode JSON you first declare what type of data you're
expecting. This is usually done by defining a struct with "tags" to
define the JSON the struct will be populated by.

The `github.com/google/github-go` package has already defined a struct
that can be populated by a webhook payload.

Look at the godoc for the WebHookPayload struct:

[soruce,go]
----
type WebHookPayload struct {
    After      *string         `json:"after,omitempty"`
    Before     *string         `json:"before,omitempty"`
    Commits    []WebHookCommit `json:"commits,omitempty"`
    Compare    *string         `json:"compare,omitempty"`
    Created    *bool           `json:"created,omitempty"`
    Deleted    *bool           `json:"deleted,omitempty"`
    Forced     *bool           `json:"forced,omitempty"`
    HeadCommit *WebHookCommit  `json:"head_commit,omitempty"`
    Pusher     *User           `json:"pusher,omitempty"`
    Ref        *string         `json:"ref,omitempty"`
    Repo       *Repository     `json:"repository,omitempty"`
}
----

https://godoc.org/github.com/google/go-github/github#WebHookPayload

Each field on the struct has a "struct tag" that maps the JSON key to
the field in the Go struct. For example the `Repo` field in the Go struct
will be populated with the `repository` key's value in the JSON. Each
tag also has `omitempty` which will omit the field if the value is
empty.

#### Type of Payload

You also need to check it what type of Event Github has sent us. This
information is held in the "X-GitHub-Event" header in the `Request` object.

The `http.Request` Header has a `Get` function to access header
values.

[source,go]
-----
eventHeader := r.Header.Get("X-GitHub-Event")
-----

== Makefile

Haven't heard of a Makefile? Don't worry, you've probably already used them and
had no idea. Ever type `make install` while going through a tutorial? Well that's
you running the "install" target with the Make utility.

Makefiles are simple in their structure.

* A target
* The dependencies of that target
* System command(s) to build that target

[source]
-----
target: dependencies
[tab] system command(s)
-----

For our project we're going to make two targets: run and test

The `run` target will startup our web server. We will also make this the first
target. This will make the `run` target the default, allowing us to just call
`make` to startup our server

The second target, `test`, will run our test suite.

Both the `run` and the `test` targets do not output files. This makes them both
phony targets. We need to make sure the Make utility know this. If we did not
mark them as phony targets and had a file named "run", our make task would never
be able to run.

[source,Makefile]
-----
.PHONY: run test
run:
	go run cmd/gowebhooks-server/main.go
test:
	go test
-----

[NOTE]
The space before each system command must be a **tab** charachtor. Make sure
your editor isn't turning tabs into spaces.







