== A Single Page App using the GitHub API with JavaScript

Now that you know the basics of the GitHub API, let's build something
interesting with it. GitHub offers libraries which work within other
programming languages and frameworks, and later we will talk about
using the GitHub API on the server side. To start, however, let's
build a single page app with everything hosted on GitHub and using the
GitHub API. You've already learned about the `gh-pages` branch and now
know about how the API works and we'll use that background knowledge
as a foundation for this next chapter. 

=== Using the GitHub API with JavaScript

This chapter focuses on using the GitHub API with client side
JavaScript. JavaScript is the lingua franca of the web, invented in
1995 as a scripting language embedded inside the first web browsers.
JavaScript has recently found its way to the server side as well with
NodeJS, an innovative toolkit for building high performance network
servers. JavaScript is a useful language to know no matter where your
interests lie, whether they be on the server side or strictly client
side web development. 

The main weakness of JavaScript has always been testability. Mainly
due to the asynchronous nature of JavaScript, writing tests has never
been easy; polling for changes when a callback returns was until
recently the best way to test code which was nonlinear. But, recent
toolkits like AngularJS and promise-based libraries have made testing
not only easy but elegant as well. Building applications on top of
third party services makes testing even more important than it already
was, and we'll make sure to add testing to our application to verify
the functionality works as we expect.

===== Building our coffee shop database

The Japanese have a word "otaku"; it describes a person obsessed with
something, often computers or technology. Many software developers
would happily call themselves otaku. Interestingly, in many of the
software development shops where I have worked in Portland, there is
an equally, almost disturbing, obsession with coffee. I suffer from
the same malady, and it means I will drag my poor wife and infant son
with me as I visit new cities, through the slime and filth of strange
neighborhoods, just to find the perfect brew and complementary gluten
free desserts. 

Google Maps is a great help on these quests, in that it will find me a
coffee shop and reviews, but the granularity of information about that
coffee shop is often poor and limited in scope. Do they offer rice
milk as a dairy free alternative?  What special details should I know when considering a place?
Many guidance and mapping applications exist, but if they don't fit my
own personalized informational niche, I might miss a unique
experience. With such a pressing and dire problem in front of us, let's use
the GitHub API to solve it.

We'll build a coffee shop single page web app which allows anyone to add
information on coffee shops, information which is flexible and
dynamic, and search and filter through that information about a coffee
shop. All files, such as the HTML, images  and JavaScript will be
hosted on GitHub. And, we'll be using the GitHub API to allow
contributors to add data to our database, a database which we will
also host on GitHub. And, as GitHub developers write code with tests,
we will write tests to validate our JavaScript code as well as the
expectations we have of the GitHub API.

More specifically, we'll use these technologies:

* GitHub API JavaScript library:https://github.com/michael/github
* AngularJS: a superpowered framework for writing JS applications that
  are testable
* Bootstrap: a CSS library which simplifies building beautiful webapps

You don't need to know these technologies in advance of working on this chapter.

===== Bootstrapping

To create our app, let's first create our main web page and push it into our repository.

[source,bash]
$ mkdir coffeete.ch
$ cd coffeete.ch
$ git init 
$ git checkout -b gh-pages
$ printf "<html>\n<body>Hello from CoffeeTe.ch</body>\n</html>\n" > index.html
$ git commit -m "Add starting point index.html" -a
$ git config push.default gh-pages

Notice that we created a new repository, and then created and entered the gh-pages branch. We'll do all our work there. And, by using the git config command, we specified that we want the default push branch to be gh-pages. This allows us to use `git push` to push our branch up instead of the longer `git push origin gh-pages`.

===== Mapping our site to a live hostname

As we discussed in the Jekyll chapter, once we publish these files
into GitHub inside a repository we can connect the repository to a
real hostname. There are two steps to take to do this:

* Add a CNAME file which tells GitHub under which server name this service should resolve. 
* Setup DNS records so that the hostname maps to the correct IP
  address at GitHub. [TODO: add specific information on IP address
  according to this link:
  https://help.github.com/articles/setting-up-a-custom-domain-with-pages ]

Imagine you have the hostname myspecialhostname.com. If you map this
repository to a subdomain called coffeetech, then you would do
something like this.

[source,bash]
$ echo 'coffeetech.myspecialhostname.com' > CNAME
$ git commit -m "Added CNAME mapping" -a
$ git push

Remember that you need to wait about ten minutes before GitHub
regenerates their database to establish the connection between your
gh-pages site and the mapping on their front end servers. Also,
generally it takes several hours to even a few days to propagate DNS
settings out into the wild, so make sure you choose and setup a
hostname far in advance of needing a site live.

===== Adding the support libraries

As we mentioned we will use the GitHub.js library, AngularJS, and
Bootstrap. Let's add those to our project now. Using whatever editor
you prefer, edit the index.html file to look like this:

[source,html index.html]
<html>
<head>
<title>CoffeeTe.ch</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" type="text/css" href="bootstrap.min.css"></link>
</head>
<body ng-app>
<div class="container">
{{'Welcome to Coffeete.ch'}}
</div>
<script src="angular.js"></script>
<script src="github.js"></script>
</body>
</html>

Then, download the necessary files locally using these commands. We
include AngularJS, Github.js and Bootstrap CSS

[source,bash]
$ wget https://ajax.googleapis.com/ajax/libs/angularjs/1.2.10/angular.js
$ wget https://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css
$ wget https://github.com/michael/github/raw/master/github.js

I am assuming you have a firm grasp on most HTML concepts, but a few
of the advanced topics here:

* The `meta` tag makes our page work well with mobile browsers and
  complements the resposive features of Bootstrap.
* The `ng-app` attribute in the body tag tells AngularJS to initialize
  and compile our page from the body tag downward. 
* The `{{ }}` (double brackets) are an AngularJS two-way data binding
  directive. This sanity checks whether AngularJS is working for us;
  if we see "Welcome to Coffeete.ch" without the braces then we know
  AngularJS is loading and working properly. If we see the braces,
  then there is some error in our setup to resolve.

===== Adding GitHub to our Single Page App

Now that we have our page setup, let's add some GitHub data to it.

Create a new file called `coffeetech.js` in the root of your repository

[source,javascript]
-----
var mod = angular.module( 'coffeetech', [] )
mod.controller( 'GithubCtrl', function( $scope ) {
  var github = new Github({} );
  var repo = github.getRepo( "gollum", "gollum" );
  repo.show( function(err, repo) {
    $scope.repo = repo;
    $scope.$apply();
  }); 
})
-----

Modify our `index.html` to utilize this new code:

[source,html index.html]
<html>
<head>
<title>CoffeeTe.ch</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" type="text/css" href="bootstrap.min.css"></link>
</head>
<body ng-app="coffeetech">
<div class="container" ng-controller="GithubCtrl">
{{ repo | json }}
</div>
<script src="angular.js"></script>
<script src="github.js"></script>
<script src="coffeetech.js"></script>
</body>
</html>

Let's talk about these changes starting with the HTML file first.

We added or changed just three lines. In reverse geographic order, we
added a reference to our `coffeetech.js` file beneath our other JS
references. And, then we removed our databinding to the `Welcome to
CoffeeTech` string and replaced it with a binding to the variable
`repo` filtered by the JSON filter. Finally, we changed the `ng-app`
reference to use the module we defined in our `coffeetech.js` file.

If you have never used AngularJS before, you are probably thoroughly
confused about the `coffeetech.js` file. Before we dive into the
syntax, understand the following features of AngularJS, and then
you'll understand the significant problems solved by those same features:

* AngularJS utilizes something called two-way databinding. AngularJS
  solves the problem you have with building JS apps: marshalling data
  from your JS code into your HTML templates, marshalling data from
  your AJAX calls into your JS code and then marshalling that into
  your HTML templates. Marcia, Marcia, Marcia! Enough already:
  allow AngularJS to do this heavy lifting. To use it, we just
  define a variable on the AngularJS scope, and then place a reference
  to the scope in our HTML using the `{{ }}` databinding directives.
  In this case we set a variable called `repo` on our scope once we
  return from the show() method callback in the Github.js API call.
  Notice we don't have to do anything to place data inside the HTML
  once the `repo.show()` callback has completed other than notifying
  AngularJS that data has changed using the `$apply()` method. We only
  need to call `$apply()` if we are using a third party library that
  uses callbacks, anything defined within AngularJS is wrapped inside
  the `$apply()` block.
* Inspecting a JS object inside your webpage can be complicated; do
  you extract information from the object, put them into <div>s, doing
  all the marshalling we just realized is a royal pain in the lives of
  most modern JavaScript developers? If we are using AngularJS it does not
  have to be. AngularJS provides a filter which you can apply (using the pipe
  character) that produces a pretty printed object in your webpage. You
  see that with the `repo | json` code. `json` is a filter AngularJS
  provides by default. We'll use filters later in a powerful way.
* Many people see this kind of two way databinding and assume it
  cannot be performant, arguing that AngularJS must be polling the JavaScript
  objects to see changes. Not true! AngularJS is written in a smart
  way and only processes and changes the DOM when changes are noticed
  inside a digest cycle. If you put all your code properly into your
  scope, AngularJS will handle tracking changes for you. As we
  mentioned briefly above, if you use a
  third party library which uses callbacks, like the Github.js library
  does, then you need to notify AngularJS that there has been a change
  by manually calling the `$apply` function on the `$scope` object once
  you have completed adding data to the scope inside the callback.
* AngularJS allows you to break application functionality into
  isolated components which makes your application more testable. When
  we call `angular.controller` we are creating a controller which has
  functionality defined on it and encapsulated inside itself.

Now that we understand the benefits of using AngularJS, a few more
specifics about the implementation details of our `coffeetech.js`
file. 

* We create a new Github() object using the constructor. This
  constructor can take user credentials, but for now, we can just
  create it without those since we are accessing a public repository.
* Once we have our `github` object, we call the method `getRepo()` with
  a owner and a name. This returns our repository object. To actually
  load the data for this repository object, we call the show method
  and pass it a callback which uses the two parameters `err` and
  `repo` to handle errors or otherwise provide us with details of the
  repository specified. In this case we are using the Gollum wiki
  public repository to display some sample data.

So, Github.js handles making the proper request to Github for us, and
AngularJS handles putting the results into our web page.

If you load this up in your browser, you will see something like this:

image::images/javascript-gollum.png[]

Yikes, that is a lot of data. AngularJS's JSON filter pretty printed
it for us, but this is a bit too much. 

Modify the HTML to show just a few vital pieces of information.

[source,html index.html]
<html>
<head>
<title>CoffeeTe.ch</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" type="text/css" href="bootstrap.min.css"></link>
</head>
<body ng-app="coffeetech">
<div class="container" ng-controller="GithubCtrl">
<div>Subscriber count: {{ repo.subscribers_count }}</div>
<div>Network count: {{ repo.network_count }}</div>
</div>
<script
src="angular.js"></script>
<script src="github.js"></script>
<script src="coffeetech.js"></script>
</body>
</html>

No we see something more palatable.

image::images/javascript-gollum-precise.png[]

We've just extracted the subscriber and network count from the gollum
repository hosted on GitHub using the GitHub API and placed it into
our single page app.

===== Visualize Application Data Structure

Now, let's build our application. First, consider how we
will structure our data. We are going to use GitHub as our data store.
GitHub is built on top of Git, a technology that could not be better suited for
storing content. However, there is a major difference between
accessing data stored inside a Git repository and a traditional database:
searchability. Git repositories are great for storing data, and
GitHub exposes storing data through their API. While Git itself
has many ways to search and retrieve data, the GitHub API does not
easily allow searching our repository data. Let's make sure to
design and store the data in a structured way so that we can search
it on the client side.

This application allows us to search coffee shops. These coffee shops
will be, for the most part, in larger cities. If we keep all the data 
stored as JSON files named after the city, we can keep data located in
a file named after the city, and then either use geolocation on the
client side to retrieve a set of the data, or ask the user to choose
their city manually.

If we look at the Github.js javascript documentation on Github
[https://github.com/michael/github] we can see that there are some
options for us to pull content from a repository. We'll store a data
file in JSON named after the city inside our repository and retrieve
this from that repository. It looks like the calls we need to use are
`github.getRepo( username, reponame )` and once we have retrieved the
repository, `repo.contents( branch, path, callback )`. 

==== Writing tests

Before we get deep into writing the code to pull this data, let's add
some tests. Testing not only builds better code by making us think
clearly about how our code will be used from the outside, but makes it
easier for an outsider (meaning other team members) to use our code.
Testing facilitates "social coding."

We'll use a tool called `karma`. Karma simplifies writing JavaScript
tests. We need to first install the tool, then write a test or two.
Karma can easily be installed using NPM, which we document in the
first chapter.

[source,bash]
-----
$ npm install karma -g
$ karma init karma.config.js
$ wget https://ajax.googleapis.com/ajax/libs/angularjs/1.2.7/angular-mocks.js
-----

Then, create a file called `karma.config.js` and enter the following contents:

[source,javascript karma.config.js]
-----
module.exports = function(config) {
  config.set({
    basePath: '',
    frameworks: ['jasmine'],
    files: [
        'angular.js',
        'fixtures-*.js',
        'angular-mocks.js',
        'github.js',
        '*.js'
    ],
    reporters: ['progress'],
    port: 9876,
    colors: true,
    logLevel: config.LOG_INFO,
    autoWatch: true,
    browsers: ['Chrome'],
    captureTimeout: 60000,
    singleRun: false
  });
};

-----

To write the test, let's clarify what we want our code to do:

* When a user first visits the application, we should use the
  geolocation features of their browser to determine their location.
* Pull a file from our repository which contains general latitude and
  longitude locations of different cities.
* Iterate over the list of cities and see if we are within 25 miles of
  any of the cities. If so, set the current city to the first match.
* If we found a city, load the JSON data file from GitHub

We'll use a `ng-init` directive which simply tells AngularJS to call the
function specified when the controller has finished loading. We'll
call this function `init` so let's test it below.

[source,javascript coffeetech.spec.js]
-----
describe( "GithubCtrl", function() {
    var scope = undefined;
    var ctrl = undefined;
    var gh  = undefined;
    var repo = undefined;
    var geo = undefined;

    function generateMockGeolocationSupport( lat, lng ) {
        response = ( lat && lng ) ? { coords: { lat: lat, lng: lng } } : { coords: CITIES[0] };
        geo = { getCurrentPosition: function( success, failure ) {
            success( response );
        } };
        spyOn( geo, "getCurrentPosition" ).andCallThrough();
    }

    function generateMockRepositorySupport() {
        repo = { read: function( branch, filename, cb ) {
            cb( undefined, JSON.stringify( filename == "cities.json" ? CITIES : PORTLAND ) );  
        } };
        spyOn( repo, "read" ).andCallThrough();

        gh = new Github({});
        spyOn( gh, "getRepo" ).andCallFake( function() {
            return repo;
        } );
    }

    beforeEach( module( "coffeetech" ) );

    beforeEach( inject( function ($controller, $rootScope ) {
            generateMockGeolocationSupport();
            generateMockRepositorySupport();
            scope = $rootScope.$new();
            ctrl = $controller( "GithubCtrl", { $scope: scope, Github: gh, Geo: geo } );
        } )
    );

    describe( "#init", function() {
        it( "should initialize, grabbing current city", function() {
            scope.init();
            expect( geo.getCurrentPosition ).toHaveBeenCalled();
            expect( gh.getRepo ).toHaveBeenCalled();
            expect( repo.read ).toHaveBeenCalled();
            expect( scope.cities.length ).toEqual( 2 );
            expect( scope.city.name ).toEqual( "portland" );
            expect( scope.shops.length ).toEqual( 3 );
        });
    });
});
-----

This JS test file has the boilerplate code used in any AngularJS test.
You setup the scope and instantiate the
controller with that scope, and then can manually call the methods on
the scope to simulate interaction with our app. As we are calling into
a JavaScript function inside of the Github JS object which uses an
asynchronous callback, we will likely have to wait for an AJAX call to
return. Simulating this is difficult in a test, so instead we will
create a mock object for Github and then inject it into our
`GithubCtrl` controller. Instead of having our controller make real
calls to Github, we can call into our mock object and verify the
correct calls are made. The real meat of of
our test is inside the `describe` and `it` blocks: we initialize the
scope. We then expect that the functions on our mocked objects will be
executed. And, we verify the data is correctly set on our scope.

Specifically, our test does these things:

* Calls the `init` function defined in our controller (which will be
  handled using our `ng-init` directive in the HTML).
* Verify that the geolocation service was called.
* Verify that we called `getRepo` on our mocked Github object.
* Verify that we called `read` on the repo we returned from the
  `getRepo` call.
* Verify that we used the data returned from the read to fill our
  cities object inside our scope object.
* Verify that we calculated the correct current city as Portland.
* Verify that we have loaded the JSON data file for the current city

Now that we have a set of tests, run the test suite from the command
line and watch them fail.

[source,bash]
------
$ karma start karma.conf.js
Chrome 32.0.1700 (Mac OS X 10.9.1) GithubCtrl #init should initialize, grabbing current city FAILED
	Error: [$injector:modulerr] Failed to instantiate module coffeetech due to:
	Error: [$injector:nomod] Module 'coffeetech' is not available! You either misspelled the module name or forgot to load it. If registering a module ensure that you specify the dependencies as the second argument.
...
------

Now we can write the code to support the tests we have written.

First add support fixtures, data files which have test data. Add the `fixtures-cities.js` file.

[source,javascript]
-----
var CITIES = [ { name: "portland", latitude: 45, longitude: 45 },
  { name: "seattle", latitude: 47.662613, longitude: -122.323837 } ];

-----

And, the `fixtures-portland.js` file.

[source,javascript fixture-portland.js] 
-----
var PORTLAND = [ { "name" : "Very Good Coffee Shop", "latitude" : 45.52292,  "longitude" : -122.643074 },
{ "name" : "Very Bad Coffee Shop", "latitude" : 45.522181, "longitude" : -122.63709 },
{ "name" : "Mediocre Coffee Shop", "latitude" : 45.520437, "longitude" : -122.67846 } ]

-----

Then add the `coffeetech.js` file:

[source,javascript]
----
var mod = angular.module( 'coffeetech', [] );

mod.factory( 'Github', function() {
    return new Github({});
});

mod.factory( 'Geo', [ '$window', function( $window ) {
    return $window.navigator.geolocation;
} ] );

mod.controller( 'GithubCtrl', [ '$scope', 'Github', 'Geo', function( $scope, ghs, Geo ) {
    $scope.messages = []

    $scope.init = function() {
        $scope.getCurrentLocation( function( position ) {
            $scope.latitude = position.coords.latitude;
            $scope.longitude = position.coords.longitude;
            $scope.repo = ghs.getRepo( "xrd", "spa.coffeete.ch" ); // # <1>
            $scope.repo.read( "gh-pages", "cities.json", function(err, data) { // # <2>
                $scope.cities = JSON.parse( data ); // # <3>
                // Determine our current city
                $scope.detectCurrentCity();

                // If we have a city, get it
                if( $scope.city ) {
                    $scope.retrieveCity();
                }

                $scope.$apply();
            });
        });
    };

    $scope.retrieveCity = function() {
        $scope.repo.read( "gh-pages", $scope.city.name + ".json", function(err, data) { 
            $scope.shops = JSON.parse( data );
            $scope.$apply();
        });
    }

    $scope.getCurrentLocation = function( cb ) {
        if( undefined != Geo ) {
            Geo.getCurrentPosition( cb, $scope.geolocationError );
        } else {
            console.error('not supported');
        }
        
    };

    $scope.detectCurrentCity = function() {
        // Calculate the distance from our current position and use
        // this to determine which city we are closest to and within
        // 25 miles
        for( var i = 0; i < $scope.cities.length; i++ ) {
            var dist = $scope.calculateDistance( $scope.latitude, $scope.longitude, $scope.cities[i].latitude, $scope.cities[i].longitude );
            if( dist < 25 ) {
                $scope.city = $scope.cities[i];
                break;
            }
        }
    }

    toRad = function(Value) {
        return Value * Math.PI / 180;
    };
    
    $scope.calculateDistance = function( latitude1, longitude1, latitude2, longitude2 ) {
        R = 6371;
        dLatitude = toRad(latitude2 - latitude1);
        dLongitude = toRad(longitude2 - longitude1);
        latitude1 = toRad(latitude1);
        latitude2 = toRad(latitude2);
        a = Math.sin(dLatitude / 2) * Math.sin(dLatitude / 2) + Math.sin(dLongitude / 2) * Math.sin(dLongitude / 2) * Math.cos(latitude1) * Math.cos(latitude2);
        c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        d = R * c;
        return d;
    }

    $scope.loadCity = function( city ) {
        $scope.repo.read( "gh-pages", city + ".json", function(err, data) { // # <2>
            $scope.shops = JSON.parse( data ); // # <3>
            $scope.$apply();
        });
    }
    
    $scope.geolocationError = function( error ) {
        console.log( "Inside failure" );
    };
    

} ] );


----

<1> We extract the Github library into an AngularJS factory. This
allows us to inject our mocked GitHub object inside our tests; if we
had placed the GitHub instance creation code inside our controller,
we would not have been able to easily mock it out in our tests.
<1> We extract the geolocation support into an AngularJS factory. As
we did with the GitHub library mock, we can now inject a fake one into
our tests.
<1> Set the username and repository. If you are putting this into
your own repository, modify this appropriately, but you can use these
arguments until you do post this into your own repository.
<1> We use the `read` method to pull file contents from the
repository. Notice we use the `gh-pages` branch since we are storing our
single page app and all the data there.
<1> Once our data is returned to us, it is simply a string. We need to
reconstitute this data back into a JavaScript object using the
`JSON.parse` method.
<1> After we retrieve our data from the repository, we can use the
data inside the cities array to determine our current city.
<1> Since we are calling outside of AngularJS and returning inside a
callback, we need to call `scope.$apply()` like we showed in prior examples.

At first glance, the calculate distance function looks confusing, no?
Unless you are a geocoding geek, how do we know this works as
advertised? Well, let's write some tests to prove it. Add these lines
to the bottom of your coffeetech.spec.js, just within the last `});`
closing braces

[source,javascript]
-----
    describe( "#calculateDistance", function() {
        it( "should find distance between two points", function() {
            expect( parseInt( scope.calculateDistance( 14.599512, 120.98422, 10.315699, 123.885437 ) * 0.61371 ) ).toEqual( 354 );
        });
    });

-----

To build this test, I searched for "distance between Manila" and
Google autocompleted my search to "Cebu". It says they are 338 miles
apart. I then grabbed latitude and longitudes for those cities and
built the test above. I expected my test to fail as my coordinates
were going to be off by a few miles here or there. But, the test
showed that our distance was 571. Hmm, perhaps we calculated in kilometers, not miles?
Indeed, I had forgotten this algorithm actually calculated the
distance in kilometers, not miles. So, we need to multiply the result
by 0.621371 to get the value in miles, which ends up being close
enough to what Google reports the distance to be. 

Now, let's expose the new data inside the `index.html` file like so:

[source,html]
-----
<html>
<head>
<title>CoffeeTe.ch</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" type="text/css" href="bootstrap.min.css"></link>
</head>
<body ng-app="coffeetech">

<div class="container" ng-controller="GithubCtrl" ng-init="init()">

<h1>CoffeeTe.ch</h1>

<h3 ng-show="city">Current city: {{city.name}}</h3>

<div class="row=">
<div class="col-md-6"><h4>Shop Name</h4> </div>
<div class="col-md-6"><h4>Lat/Lng</h4> </div>
</div>
<div class="row" ng-repeat="shop in shops"> <!--1-->
<div class="col-md-6">   <!--2-->
{{ shop.name }}  <!--3-->
</div>
<div class="col-md-6"> {{ shop.latitude }} / {{ shop.longitude }} </div>
</div>
</div>

<script src="angular.js"></script>
<script src="github.js"></script>
<script src="coffeetech.js"></script>

</body>
</html>

-----

<1> `ng-repeat` is an AngularJS directive which iterates over an array
of items. Here we use it to iterate over the items in our
`portland.json` file and insert a snippet of HTML with our data
interpolated from each item in the iteration.
<2> We are now using Bootstrap to establish structure in our HTML. The
`col-md-6` class tells Bootstrap to build a column sized at 50% of our 12
column layout. We setup two adjacent columns this way. And, if we are 
inside a mobile device, it properly stacks these columns.
<3> Notice how we bind to data from the JSON file.

====== Errors Already?

If you run this in your browser, you will not see the shops for our city
displayed. Something is broken, so
let's investigate. I recommend using the Chrome browser to
debug this, but you can use any browser and set of developer tools you
like. For Chrome, right clicking on the
page anywhere and selecting "Inspect Element" at the bottom (or by
the keyboard shortcut "F12" or "Ctrl + Shift
+ I" on Windows or Linux or "Cmd + Opt + I" on Mac ) will bring up
the developer console. Then select the
console window. Refresh the browser window, and you'll see this in the
console: 

[source,error]
------
Uncaught TypeError: Cannot call method 'select' of undefined 
------

If you click on the link to the right for github.js, you'll see this.

image::images/javascript-underscore-missing.png[]

You see at the point of error that we are calling `select` on the tree.
Select appears to be a method defined on an underscore character. If
you use JavaScript frequently, you'll recognize that the underscore
variable comes from the Underscore library, and `select` is a method
which detects the first matching instance inside an array. Under the
hood, the Github.js library is pulling the entire tree from the
repository, then iterating over each item in the tree, then selecting
the item from the tree which matches the name of the file we have
requested. This is an important performance implication to consider;
the GitHub API does not provide a way to directly request content by
the path name. Instead, you pull a list of files and then request the
file by the SHA hash.

However, we get an error telling us `select` is undefined. Did we forget
to include underscore.js? Reviewing the documentation on Github.js, we
see that it states underscore.js and base64.js are required. We did
not see the issue when we pulled the information To
include these, run these commands from the console: 

[source,bash]
$ wget http://underscorejs.org/underscore-min.js
$ wget https://raw.github.com/dankogai/js-base64/master/base64.min.js

Then, make your index.html look like this:

[source,html index.html]
-----
<html>
<head>
<title>CoffeeTe.ch</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" type="text/css" href="bootstrap.min.css"></link>
</head>
<body ng-app="coffeetech">

<div class="container" ng-controller="GithubCtrl" ng-init="init()">

<h1>CoffeeTe.ch</h1>

<h3 ng-show="city">Current city: {{city.name}}</h3>

<div class="row=">
<div class="col-md-6"><h4>Shop Name</h4> </div>
<div class="col-md-6"><h4>Lat/Lng</h4> </div>
</div>
<div class="row" ng-repeat="shop in shops"> 
<div class="col-md-6">  
{{ shop.name }}  
</div>
<div class="col-md-6"> 
<a target="ctmaps" href="http://maps.google.com/?q={{ shop.latitude }},{{ shop.longitude }}">View on map</a>
 </div>
</div>
</div>

<script src="angular.js"></script>
<script src="underscore-min.js"></script>
<script src="base64.min.js"></script>
<script src="github.js"></script>
<script src="coffeetech.js"></script>

</body>
</html>

-----

Let's also add a link to Google Maps with these coordinates, to allow
the user to generate driving directions and get to the coffee shop.

===== Simulating user reported data

So far we have built a database of cities and coffee shops in those
cities. Even the first version of Google Maps developed in the
Victorian era provided more value to its users. If we add our own
layer of information on top of this data (like quirky information
about the coffeeshop), however, then we might have something that
someone might find useful alongside Google Maps. Let's add some faked
data to our coffee shop information.

Modify the `portland.json` file so it looks like this:

[source,html index.html]
-----
[ { "name" : "Very Good Coffee Shop", "latitude" : 45.52292,  "longitude" : -122.643074, "information" : [ "offers gluten free desserts", "free wifi", "accepts dogs" ] },
{ "name" : "Very Bad Coffee Shop", "latitude" : 45.522181, "longitude" : -122.63709 },
{ "name" : "Mediocre Coffee Shop", "latitude" : 45.520437, "longitude" : -122.67846 } ]

-----

Notice that we added an array called `information` to our data set.
We'll use this to allow simple search. Add the search feature to our
`index.html`

[source,html]
-----
<html>
<head>
<title>CoffeeTe.ch</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" type="text/css" href="bootstrap.min.css"></link>
</head>
<body ng-app="coffeetech">

<div class="container" ng-controller="GithubCtrl" ng-init="init()">

<h1>CoffeeTe.ch</h1>

<input style="width: 20em;" ng-model="search" placeholder="Enter search parameters..."/> <!--1-->

<h3 ng-show="city">Current city: {{city.name}}</h3>

<div class="row=">
<div class="col-md-6"><h4>Shop Name</h4> </div>
<div class="col-md-6"><h4>Lat/Lng</h4> </div>
</div>
<div class="row" ng-repeat="shop in shops | filter:search"> <!--2-->
<div class="col-md-6">  
{{ shop.name }}  

<div ng-show="search"> <!--3-->
<span ng-repeat="info in shop.information">
<span class="label label-default">{{info}}</span>
</span>
</div>

</div>
<div class="col-md-6">
<a target="ctmaps" href="http://maps.google.com/?q={{ shop.latitude }},{{ shop.longitude }}">View on map</a>
</div>
</div>
</div>

<script src="angular.js"></script>
<script src="underscore-min.js"></script>
<script src="base64.min.js"></script>
<script src="github.js"></script>
<script src="coffeetech.js"></script>

</body>
</html>

-----

<1> We add a search box which binds to the `search` model in our scope
<2> We add a filter on the data to display which searches through all
data inside each item in our `shops` array.
<3> If we are searching (the model variable `search` is defined) then
we show the extra information.

Now if we type in the word `gluten` in our search box, we filter out
anything except shops which match that, and we see the 

image::images/javascript-search-box.png[]


===== Adding data using pull-requests

Now that we have a functioning application, let's allow people to add
information themselves and help build our database. Just beneath the
link to the map link, add a button which will allow us to annotate a
coffeeshop with extra information. 

To add an annotation to our existing data we are going ask users to
contribute the "GitHub" way. Users will fork the repository, make a
change, and then issue a pull-request. We can do all of this from our
webapp using the Github.js library. This requires that we ask the
users to login, so we will prompt them for their username and
password, as well as the data they want to annotate.

[source,html]
-----
<div class="col-md-6">
<a target="_map" href="http://maps.google.com/?q={{shop.latitude}},{{shop.longitude}}">Open in map ({{shop.latitude}},{{shop.longitude}})</a>
<button ng-click="annotate(shop)">Add factoid</button>
</div>
</div>
-----

Let's add some tests. Inside the `coffeetech.spec.js` file, modify the
mock repository generator, and add a new test to the end of the file
which will test our annotate function.

[source,javascript]
-----
    ...

    function generateMockPrompt() {
        prompt = { prompt: function() { return "ABC" } };
        spyOn( prompt, "prompt" ).andCallThrough();
    }

    var PR_ID = 12345;
    function generateMockRepositorySupport() {
        repo = { 
            fork: function( cb ) {
                cb( true );
            },
            createPullRequest: function( pull, cb ) {
                cb( false, PR_ID );
            },
            read: function( branch, filename, cb ) {
                cb( undefined, JSON.stringify( filename == "cities.json" ? CITIES : PORTLAND ) );
            } 
        };
        spyOn( repo, "fork" ).andCallThrough();
        spyOn( repo, "createPullRequest" ).andCallThrough();
        spyOn( repo, "read" ).andCallThrough();

    ...

    });

    describe( "#annotate", function() {
        var $timeout;
        beforeEach( inject( function( $injector ) {
            $timeout = $injector.get( '$timeout' );
            } ) );
        it( "should annotate a shop", function() {
            scope.annotate();
            expect( prompt.prompt.calls.length ).toEqual( 3 );
            expect( repo.fork ).toHaveBeenCalled();
            $timeout.flush();
            expect( repo.read ).toHaveBeenCalled();
            expect( repo.createPullRequest ).toHaveBeenCalled();
        });

-----

We added two new methods to our mock Github object: `fork` and
`createPullRequest`. We test that these are called. According to the
documentation for `fork` in the Github.js library, this method can
take a little time to return, so we need to set a timeout in our app
and query for the new repository. This explains the
`$timeout.flush()`, a mock of the timeout browser call which
we can manually reconcile. We also added a mock prompt. We will be prompting the
user for username, password and the annotating data, and we will use
the native browser prompt mechanism to do this. If this sounds like an
ugly way to do it, don't fret, we'll find a better way later.

If you are still running karma in the background, you'll see the tests
fail with:

[source,bash]
-----
Chrome 32.0.1700 (Mac OS X 10.9.1) GithubCtrl #annotate should
annotate a shop FAILED
         TypeError: Object #<Scope> has no method 'annotate'
             at null.<anonymous> (/.../coffeetech.spec.js:80:19)
-----

Now, let's implement this functionality in our `coffeetech.js` file.




[source,javascript coffeetech.js]
-----
<html>
<head>
<title>CoffeeTe.ch</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" type="text/css" href="bootstrap.min.css"></link>
</head>
<body ng-app="coffeetech">

<div class="container" ng-controller="GithubCtrl" ng-init="init()">

<h1>CoffeeTe.ch</h1>

<input style="width: 20em;" ng-model="search" placeholder="Enter search parameters..."/> <!--1-->

<h3 ng-show="city">Current city: {{city.name}}</h3>

<div class="row=">
<div class="col-md-6"><h4>Shop Name</h4> </div>
<div class="col-md-6"><h4>Lat/Lng</h4> </div>
</div>
<div class="row" ng-repeat="shop in shops | filter:search"> <!--2-->
<div class="col-md-6">  
{{ shop.name }}  

<div ng-show="search"> <!--3-->
<span ng-repeat="info in shop.information">
<span class="label label-default">{{info}}</span>
</span>
</div>

</div>
<div class="col-md-6"> {{ shop.latitude }} / {{ shop.longitude }} </div>
</div>
</div>

<script src="angular.js"></script>
<script src="underscore-min.js"></script>
<script src="base64.min.js"></script>
<script src="github.js"></script>
<script src="coffeetech.js"></script>

</body>
</html>

-----

===== Safely implementing login

If I saw this app in the wild and knew nothing about the authors, I
would never use it to submit data. The app asks for my GitHub username
and password. Given that I usually assign a random password which I
have no hope of remembering, it is almost impossible that I could
authenticate at all. Additionally, and more importantly, asking for my
username and password implicitly asks me to trust the authors of this
application. Trust in this case means that I trust them to not
maliciously use my credentials for nefarious purposes, and also asks
me to trust that they are not doing something stupid which would allow
an attacker  to insert themselves into the middle of the
authentication process and steal my crendentials. It seems like every
day we hear of a break-in at a major internet service; I want to believe that most people are out to do good in the world, so I am less worried about the provider of such a service maliciously stealing my crendentials, but I am worried about a script kiddie attacking the service for fun and stealing my crendentials. At any rate, I would never use a service which requires me to give up my username and password to another service, especially one which is as important as GitHub is to me.

So, let's use oAuth instead and resolve these problems.

If we use oAuth, we enter our credentials directly into GitHub. We can take advantage of 2-factor authentication. Once we have entered our credentials, GitHub decides whether we are who we say we are, and then returns us to the application which requested access. And, GitHub provides the application with what is called an oAuth token that encapsulates exactly what services on GitHub we have access to, and whether that access is read-only or whether we can add data in a read-write manner. This means our requesting service can ask to modify only parts of our data within GitHub; this provides a much higher level of trust to users as they know the application cannot touch the more private parts within GitHub. Specifically, this means we could ask for access only to gists and not request access to our repositories, for example. And, finally, one important point about oAuth tokens is that they can be revoked. So, once a specific action has been taken, we can destroy the token and revoke access. With simple username and password access, the only way to revoke access is to change the password, which means any place you have saved that password (password managers or other applications which login via username and password) need to update their settings as well. With oAuth we can revoke a single token at any time (and GitHub makes it easy to do this) without affecting access to other services.

==== Everything on GitHub, except for one piece

We would like to host everything on GitHub, but sadly there is one piece which we cannot host there: the authentication component. 
Somehow we need to safely authenticate our user into the GitHub and retrieve an oAuth token. There is currently no way to do this 
strictly client side (using only static HTML and JavaScript running in the browser). 

Instead, we will delegate authentication to Firebase. Firebase is a real time communication toolset which integrates
well with our choice of AngularJS. Delegation of our authentication
component is easy with Firebase: we just create a GitHub application,
provide the credentials and GitHub oAuth scope to Firebase, and then our
application offloads user management to Firebase. 

To start, we need to create a new GitHub application.

===== Our own NodeJS Application

Why not: requires a hosting provider, like Nodejitsu. Not too complicated, but
do we want to do devops?

[source,javascript package.json]
----
{
  "name": "spa-auth",
  "description": "Single Page Authentication System for GitHub",
  "version": "0.1",
  "homepage": "https://github.com/xrd/spa.coffeete.ch/",
  "author": "Chris Dawson <xrdawson@gmail.com>
  (https://github.com/xrd/)",
  "dependencies": {
    "everyauth": "0.4.5"
  },
}
----

[source,javascript app.js]
----
var everyauth = require('everyauth')
  , connect = require('connect');

everyauth.github
  .appId('client_id')
  .appSecret('client_secret')
  .findOrCreateUser( function (session, accessToken, ,
  accessTokenExtra, githubUserMetadata) {
    // find or create user logic goes here
  })
  .redirectPath('/');

var routes = function (app) {
  // Define your routes here
};

connect(
    connect.bodyParser()
  , connect.cookieParser()
  , connect.session({secret: 'whodunnit'})
  , everyauth.middleware()
  , connect.router(routes);
).listen(3000);

----

===== Firebase App

By far the simplest option.


===== Advanced

We want to make our webapp as fast as possible. So, let's do some minimization of the assets.

[source,bash]
