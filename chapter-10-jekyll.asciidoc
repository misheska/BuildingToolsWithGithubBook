=== Jekyll: nouveau, yet antiquated, blogging on GitHub

=== What is Jekyll?

If you visit GitHub and visit the jekyll repository you'll see it state that 
"Jekyll is a blog-aware, static site generator in Ruby." What does this mean?
Jekyll is a set of technologies for building web sites. There are
probably as many tools for generating web sites as there are websites,
though, so why does Jekyll deserve notice over others? Jekyll provides
a quick way to generate a full featured website  
without the compromises that come with other tools: complicated process
and backends. When I author a blog post using Jekyll I am using a
minimalistic set of tools that get out of the way and allow me to
focus only on what I am writing. Few other site tools can deliver on
that promise.

Jekyll works natively with GitHub because a Jekyll blog is
stored as a Git repository. When you push files into GitHub from a
repository which GitHub recognizes as a Jekyll site, GitHub
automatically generates your site for you. 
The tools to generate the site are open source and simple, so you
create your site yourself, but because GitHub does everything
automatically it allows usage of tools that you might not have
considered. For example, you could write a tool that creates a new
blog post using the GitHub API and only publish a new blog post
without worrying about building the regeneration inside your tool as
well. GitHub handles this for you on their side.

If you really think about it, Jekyll takes us back to the advent of
the web when all pages were staticly created by hand. Most people
would assume that all modern sites are dynamically generated with a
database backend. Jekyll suprises us with a tool that recognizes we
only need to be dynamic when new content is created not when a new visitor
requests the same page as the previous visitor, and for most
sites, this acknoledgement results in a massive reduction in
complexity and freedom. When you look at a site built by jekyll, you
are looking at a set of static files, backed by nothing more complex
than the same web server technology that was available in 1998.

==== The need for Jekyll

Though you won't see it in the documentation, the popularity of Jekyll
is due in large part to bloggers, especially very technical ones,
wanting a blogging tool option other than the 800 lb. gorilla in the room:
Wordpress. For many bloggers, Wordpress is a poor
choice of blogging tools. Of course, there is always language snobbery
when considering any tool, but Wordpress is built on a language, PHP, which
is generally and widely reviled by advanced developers. Because PHP is
a more accessible language than other languages, the choice of PHP has
fostered a large community of plugin developers. Unfortunately, this
community is fractured, and the plugins which arise from it are at
best poorly documented and poorly integrated, and at worst, poorly
designed and buggy. While Wordpress does often have a plugin for
anything you need, the problem it solves often creates more problems
in the long term when scalability or database optimization or security, for
example, become concerns.

Jekyll is interesting because of the components which are not present
when compared against Wordpress. Jekyll does not require a database.
Jekyll does not require you know how to write in HTML. While Wordpress
ostensibly advertises itself as a tool which can be used without
knowledge of these technologies, talk to those of us who have struggled with
recovery of a mangled database after installation of a new Wordpress plugin,
or resolving scalability issues on a large Wordpress site, or fixing
by hand broken HTML produced by the Wordpress editor. We'll tell
you that, when using Wordpress, you don't need to know about MySQL or
HTML at all, because it is already too late by then to fix whatever
problem you are facing.

Jekyll responds to these concerns in a really elegant way. Instead of
authoring in HTML, you author in a simple and readable language called
Markdown, which the Jekyll engine converts automatically to HTML
for you. Instead of storing posts and other data inside a MySQL
database, you use the filesystem to store posts and layouts and then
regenerate the entire site when infrequent changes are made. And, to
faciliate interaction, you use client side JavaScript plugins instead
of pushing that interaction into your database. Jekyll has found a
sweet spot with a simple technology set that makes your life easier
and makes beautiful blogs and simple web sites. And, the biggest
benefit of doing things the "jekyll" way is that all dependencies can
sit within a repository, and this means your entire site can be hosted
on GitHub. 

==== The father of Jekyll

Like many of the open source technologies in heavy usage at GitHub,
jekyll was originally developed by Tom Preson Warner, one of the
co-founders of GitHub. 

==== Running Jekyll locally

To use jekyll, you'll need the `jekyll` gem. You could do this by
running the command:

[source,bash]
------
$ gem install jekyll
------

There are two issues with doing installation this way. The first is that any
commands we run inside the command line are lost to us and the world
(other than in our private shell history file). The second is that if
we are going to publish any of our sites to GitHub, we will want to
make sure we are matching the exact versions of Jekyll and its
dependencies so that a site that works on our local laptop also works
when published into GitHub. If you don't take care of this, you'll
occasionally get an email like this from GitHub: 

[quote]
----

 The page build failed with the following error:
 
 page build failed

 For information on troubleshooting Jekyll see
 https://help.github.com/articles/using-jekyll-with-pages#troubleshooting
 If you have any questions please contact GitHub Support.


----

The fix for these two issues is a simple one. You've probably seen other
chapters using a `Gemfile` to install ruby libraries. Instead of
using a manual command like `bundle` to install from the command line,
let's put this dependency into the Gemfile. Then, anyone else using
this repository can run the command `bundle install` and install the
correct dependencies. And, instead of using the `jekyll` gem directly, use the
`github-pages` gem which synchronizes your jekyll gem versions with
those on GitHub. If you do get the email above, run the command `bundle update`
to make sure that everything is properly setup and synchronized and
generally this will reproduce the issues on your local setup, which is
a much faster place to fix them.

==== Jekyll quick start

Now that we have our required tools, let's create a simple blog. Run
this command.

[source,bash]
-----
$ jekyll new myblog
$ cd myblog
-----

The `jekyll new` commands creates the necessary structure for a
minimal jekyll blog. Taking a look inside the directory, you'll see a
few files. 

The `jekyll new` command installs two CSS files: one for
the blog (`main.css`) and one for syntax highlighting (`syntax.css`).
Remember, you are in full control of this site; the `main.css` file is
simply boilerplate which you can completely throw away if it does not
suit your needs.

Installation of a new blog
comes with a .gitignore file as well which contains one entry:
`_site`. When you use the jekyll library to build your site locally,
all files are by default placed inside the _site directory.
This .gitignore file prevents those files from being included inside
your repository as they are overwritten by the jekyll command on
GitHub when your files are pushed up to GitHub.

[NOTE]
====
The `jekyll new` command does not create or initialize a new git
repository for you with your files. If you want to do this, you will need to
use the `git init` command. The jekyll initialization command does create the
proper structure for you to easily add all files to a git repository;
just use `git add .; git commit` and your gitignore file will be added
and configure your repository to ignore unnecessary files like the
`_site` directory.
====

All your blog posts are stored in the `_posts` directory. Jekyll sites
are not required to have a `_posts` directory (you can use jekyll with
any kind of static site) but if you do include files in this directory
jekyll handles them in a special way. If you look in the `_posts`
directory now, you see that the jekyll initialization command has
created your first post for you, something like
`_posts/2014-03-03-welcome-to-jekyll.markdown`. These posts have a
special naming format: the title of the post (with any whitespace replaced with
hyphens) trailed by the date and then an extension (either `.markdown`
or `.md` for markdown files, or `.textile` for Textile)

Your new jekyll blog also comes with a few HTML files: an index.html file
which is the starting point for your blog, and several layout files
which are used as wrappers when generating your content. If you look
in the `_layouts` directory, notice there is a file named
`default.html` and another named `post.html`. These files are the
layout files, files which are wrapped around all generated content,
like those from your markdown formatted blog posts. For
example, the `post.html` file is wrapped around the generated content
of each file stored inside the `_posts` directory. First the markup content is
turned into HTML and then the layout wrapper is applied. If you look
inside each of the files inside the `_layouts` directory, you will see
that each contains a placeholder with `{{ content }}`. This
placeholder is replaced with the generated content from other files. 

These placeholders are actually a markup language on their own: Liquid
Templates. Liquid Templates were developed and open sourced by
Shopify, and are a safe way to include programmatic constructs (like loops
and variables) into other markup languages, without exposing the rendering context
to a full fledged programming environment. Shopify wanted to build a
way for untrusted users of their public facing systems to upload
dynamic content but not worry that the markup language would have the
ability to perform malicious activity like open network connections to
sites on their internal networks, for example. If you think about a language 
like ERB (embedded ruby templates), you might realize that while
embedding ruby code is great when you have full control over your
source documents, it can be dangerous to provide a mechanism where
valid embedded code could look like `system("rm -rf /")`. Liquid
provides many of the benefits of embedded programming templates,
without the dangers.

Lastly, your jekyll directory has a special file called `_config.yml`.
This is the jekyll configuration file. Peering into it, you'll see it
is very basic:

[source,yaml]
-----
name: Your New Jekyll Site
markdown: redcarpet
pygments: true

-----

We only have three lines to contend with and they are simple to
understand: the name of our site, the markdown parser used by our
jekyll command, and whether to use pygments to do syntax highlighting.
To view this site locally run this command:

[source,bash]
-----
$ jekyll serve
-----

This command builds the entirety of your jekyll directory, and then
starts a mini web server to serve the files up to you. If you then
visit `http://localhost:4000` in your web browser, you will see
something like this:

image::images/jekyll-bare.png[A bare Jekyll site]

Clicking into the link inside the "Blog Posts" section, you will then
see something like this:

image::images/jekyll-welcome.png[A sample post co-authored by Tom Preston-Warner]

Our jekyll initialization command created a new post for us. This page
is backed by the markdown file inside the _posts directory which we
saw earlier. 

[source,yaml]
-----
---
layout: post
title:  "Welcome to Jekyll!"
date:   2014-03-03 12:56:40
categories: jekyll update
---

You'll find this post in your `_posts` directory - edit this post and re-build (or run with the `-w` switch) to see your changes!
To add new posts, simply add a file in the `_posts` directory that follows the convention: YYYY-MM-DD-name-of-post.ext.

Jekyll also offers powerful support for code snippets:

{% highlight ruby %}
def print_hi(name)
  puts "Hi, #{name}"
end
print_hi('Tom')
#=> prints 'Hi, Tom' to STDOUT.
{% endhighlight %}

Check out the [Jekyll docs][jekyll] for more info on how to get the most out of Jekyll. File all bugs/feature requests at [Jekyll's GitHub repo][jekyll-gh].

[jekyll-gh]: https://github.com/mojombo/jekyll
[jekyll]:    http://jekyllrb.com

-----

In this file we see a demonstration of all the tools we have talked
about thus far. 

 * move things into _config.yml file
 * jekyll serve -w
 * Specifying the port: --port 4010

[CAUTION]
====
The jekyll watch switch does reload all HTML and markup files, but
does not reload the _config.yml file. If you make changes to it, you
will need to stop and restart the server.
====

 * Named links
* Advanced features
 * Lists
 * Remember, nested content can be any block level content (embed markup inside of lists, quotes, etc.)
 * Quotes
 * Images
 * Themes
   * Jekyll Bootstrap
   * Octopress?
 * Categories
 * Orphan branches
 * Filename conventions
 * Ignoring files

===== Pushing into GitHub

* Using github.io or github.com/user/repo
* CNAME for domain names
 * DNS settings
* Fork existing repository
* Branches
* Hosting on gh-pages

==== What

==== When

==== Who

==== Where

=== Language geek out

==== Textile versus Markdown

===== Each uses slightly different forms for footnotes. 

* Textile supports tables.
* http://mojomojo.org/documentation/textile_vs_markdown
* https://github.com/vmg/redcarpet

===== Which to choose? 

==== Different markdown generators:

===== Redcarpet: used in Jekyll and all over GitHub

* supports fenced code blocks
* fork of libsoldout
* "safe"

===== Kramdown

===== Maruku

===== MultiMarkdown

===== Markdown

===== The devil is in the details. The differences in markdown support
is aggravating, but fortunately, you have more control over which you
prefer and switching is generally easy or at least possible. These two
tips:

* The best thing to do is to use a cheat sheet for the version of markdown or textile you are using
* Use the watch switch and live-reload to regenerate your pages and
  verify manually when you are confused. Fortunately, there is nothing
  here beyond text generation to contend with.

==== Liquid templates

===== Why: safely generate content using programmatic loops and
variables, without the risks of using a full programming language,
invented at Shopify

===== Capturing content is a special case

===== Include files

==== Yaml Front Matter: YFM

===== Problems with YML and YAML

* No comments (JSON has the same problem...)
 * reading in parsing, then writing out, loses all the comments!
 * use `comment: "some comment here"` for comments. 

=== Scraping a site into Jekyll

==== Writing tests

==== Using VCR

==== Embedding AngularJS directives

==== Geocoding and expansion of config file

== Jekyll

===== Hosting Jekyll sites on GitHub

CNAME files

Using gh-pages as master: `git push origin gh-pages:master`. 

===== Markdown

Markdown is a readable markup language. HTML was designed for
computers to read and interpret. Many people have trained themselves
to read and write literally in HTML, but most people use editors to
convert their designs and ideas into HTML code. 

Markdown is another way of writing HTML. Markdown is a language which
converts into HTML and is entirely readable by humans. 

You can embed regular HTML snippets into Markdown. There are a few gotchas, however:

You cannot wrap markdown inside of HTML tags. If you want to use a
tag and enclose content inside it, you need to embed pure HTML code.

Well, this is not entirely true. use a combination of includes and capturing
content. 

[source,html]
{% capture sidebar %}{% include blog.md %}{% endcapture %}
<div style="text-align: left">
{{ sidebar | markdownify }}
</div>


===== Scripts for generating site

===== Filenaming convention

==== Authoring Tips
  
===== inside GitHub

===== using Prose.io

==== Embedding Content

==== YAML Front Matter

===== What is YAML?

==== Importing from old blogs

==== Scraping a site into Jekyll

Rebuilding ByTravelers.com.

===== Using the VCR gem to minimize requests
===== Writing Tests
===== GeoCoding from the command line
===== Embedding AngularJS Directives
===== Stripping out markdown formatting characters

==== Branches
=====  Detached "Orphan" branches

[source,bash]
$ git checkout --orphan gh-pages
$ git rm -rf .

Once you execute these two commands, you've switched to a new branch named
gh-pages. This is a specially named branch for GitHub which will hold
the contents of your repository's web site. Now, this is something of
an odd concept, but this is a branch in your repository that is
designed to hold something entirely different from your code. Usually
branches are designed to hold related content. For example, you may
create a feature branch to capture a few days of work on a piece of
code, or you may create a branch for difference versions of content
that need to be updated independently.  In this case, it is almost
like you are creating a separate repository within your repository
that lives on a specially named repository.

Let me explain? When you run "git checkout" with the "--orphan" flag
you are creating a new branch "gh-pages" that is an "orphan" commit.
It is a commit that doesn't have any parents and it entirely
disconnected from history. After you create this branch with a
parent-less commit that is entirely disconnected from history, you run
"git rm -rf ." which removes everything from the Git repository. The
end result is that the branch gh-pages is now completely detached from
history and contains nothing. gh-pages is a blank slate to be filled
with your website content.

==== Editing inline on github
==== Using categories
==== Using tags
==== Using themes
==== Ignoring files
==== Published versus unpublished
==== File naming conventions
==== Using rake
==== Jekyll serve
=====  Watch
=====  Live reload
==== Cname file
==== Configuration file
==== Using liquid tags
=====  Safety
=====  Loops
=====  Variables
==== Matching gems with github

== Github Pages

GitHub Pages are really a very simple idea.  Any 
GitHub-hosted Git repository can be augmented with a branch called gh-pages. 
If this branch exists, everything in that branch is published automatically.  
This content is then served from GitHub giving you a very
quick and easy way to serve web pages and other information from
GitHub.  Various people use this or different reasons.  Some users
host entire company web sites from GitHub, while other create a web
site for a specific project or repository.

As with most things GitHub, this feature is as useful as you make it,
and there are many examples of projects and organizations that use
GitHub pages to provide compelling web content.  In this chapter,
we're going to explore a few, simple use cases for GitHub pages as
well as some advanced approaches to managing and publishing GitHub
pages with Jekyll.  Jekyll is a static site generator which is used as
a simple templating engine for publishing web sites and blogs.

=== Hosting a Web Site with Github

When you create an open source project or even a project that isn't
open source there's always some infrastructure required.  First, if
you are developing something with source code, you will need a source
code repository, and there's a good chance that if you are reading
this book you would choose GitHub to host your project's source.

Now, with a source code repository you can push source, you can keep
track of changes, and do any number of the things related to your
project, but source control isn't enough. If you want users and
community members, if you want to be found, you'll need a web site of
some sort that tells people what your project does, how to download
and use it, and how to participate in the project if you have an itch
to scratch.

Before GitHub, you would need to go find a place to host your
website. If you were developing the project under an open source
organization like Apache, you would publish the site on an Apache web
server, or if you were developing a project for a company, maybe the
company would stand up a simple web server to host open source
projects it was sponsoring. Before GitHub you had to worry about
maintaining a separate piece of infrastructure to host a project's web
site.

With GitHub Pages, you don't need to worry about another
piece of infrastructure to host a simple web page.  All you need to do
is push content to a specially named branch and this content will then
be published on a website that is then associated with your user,
organization, of project. While this seems like a simple improvement,
it saves a ton of effort, and makes it easier for open source
developers to focus on coding and communicating instead of wasting
precious cycles on worrying about infrastructure.

There are a number of high profile open source projects which rely on
GitHub Pages to host project web sites including: Twitter's Bootstrap
CSS and Javascript library, <Fill this in>

==== Creating a gh-pages branch

The first step to publishing content on GitHub Pages is to create a
gh-pages branch for a GitHub repository.  This is an easy operation to
do either from the command-line with Git or from the GitHub web
interface.

To create the gh-pages branch from the GitHub web interface, see
<<repo-admin-pages>>.

To create the gh-pages branch from the command-line, run the following
from your Git repository:

[source,bash]
----
$ TODO
----

==== Pushing Content to a Github Site

Once you've created a gh-pages branch, you'll need to put your site's
content in this branch.   Here are some commands to publish a simple,
"Hello, world." web page.  Execute the following commands in your Git
repository after running the commands to create gh-pages from the
previous section.

[source,bash]
.Pushing Content to the gh-pages branch
----
$ echo "Hello, world. I am a web page." > index.html 
$ git add index.html 
$ git push origin gh-pages
----

These commands populate a simple HTML page, add it to your git
repository, and then push your working copy to the gh-pages branch on
GitHub.  Once this is done, your web site will be available within 10
minutes.  While GitHub says that sites will be available within 10
minutes, my own experience suggests that the changes may also be
available immediately.

==== What is your URL?

You now have a web site available at 
http://:user.github.io/:project.  If your user name is
"tobrien" and the project is "github-test", the URL of this site would 
be http://tobrien.github.io/github-test.

=== Customizing Your Github Site

Now that you know how to create the gh-pages branch and populate your
site with content let's move on to customizing your GitHub Pages
site.  In the following sections, you will learn how to serve the site
from a custom domain, create a custom error page, and generate pages
with GitHub Pages themes.

==== Using a Custom Domain with Github Pages

Sometimes a URL like http://tobrien.github.io/super-important-project
just doesn't work for you.  Maybe you want to host your project's web
site on a custom domain?  If you control the DNS for a domain name,
all you need to do is create an A record and/or a CNAME record and
GitHub will happily serve your web site from any domain you desire.

Here are the steps to configuring GitHub Pages to serve content from a
custom domain.  In the next few sections, let's assume that you are
attempting to serve your site from the URL http://www.fancyproject.com

Step 1: Create a CNAME File::

    Create a file in the root of your repository in the gh-pages
    branch named CNAME.  In this file you only need a single line that
    contains the domain name you are pointing at GitHub.   In this
    case, you need to put "fancyproject.com" in this file.

Step 2: Create an A Record for Your Site::

    Next, create an A record that points your domain to the IP address
    "204.232.175.78".  This IP address points at GitHub pages. If you
    create an A record for "fancyproject.com", GitHub will
    automatically redirect "www.fancyproject.com" to
    "fancyproject.com".

Step 3: Wait, then Load Your Custom Domain in a Browser::

    When you change DNS you may have to wait a while for your DNS
    provider to implement the changes and for these changes to
    propagate over the Internet. After you are certain that the DNS
    change in in effect, you can then load your GitHub pages website
    using your custom domain.   Note that if you are certain your DNS
    changes were immediate, it'll take GitHub a few minutes to catch
    up with these DNS changes. If you don't see your custom domain on
    GitHub just give it 10 minutes and try again.
    
==== Creating a custom 404 Page

Simple instructions.

==== Generating a Pages with Themes

Simple instructions.

=== Tools for Creating Github Pages

These sections are just pointers.

==== Using Jekyll

Quick instructions: http://pages.github.com/

Note: Do you know who used Jekyll?   Obama for America used Jekyll, you should too.

==== prose.io a CMS for Github Pages

http://prose.io/

==== Octopress Blog (Jekyll)

https://github.com/imathis/octopress

Remember that things can get broken if you use the wrong Jekyll versions:

https://github.com/github/pages-gem/blob/master/lib/github-pages.rb#L10-L16

`gem install github-pages` will keep things up to date.

==== The future of static blogging

Interestingly, the movement towards static blogging which was
catalyzed by Jekyll has moved away from Jekyll. Many alternatives to
Jekyll have emerged as the prime users of Jekyll, the hacker
community, have done what they do best, hack alternatives to Jekyll.
There are now many other static blogging tools built on all the major
languages, like Nanoc (Ruby), Hakyll (Haskell), Ghost (NodeJS), and
Hyde (Python), among others. Fortunately, all of these tools can be
used to publish sites inside of GitHub on the gh-pages branch, but
unfortunately GitHub does not offer integrated processing of these
other blogs (yet). What this means is that you can write your sites
using these tools, process on your local machine, then use the static
engine tools to generate the site and commit those files to your
repository inside the gh-pages branch and push them all up to GitHub.

