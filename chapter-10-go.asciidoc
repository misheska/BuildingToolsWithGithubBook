== Go and Github Webhooks

=== Why Go and GitHub?

Go was originally developed as a systems language and it still serves
that purpose well. Yet, beyond just hidden system tools, there is a
niche developing where forward facing developers want to put GitHub to
work in other more integrated ways. Go stands as a competent language
for wiring together developer tools and processes. With very little
effort and with elegant code, Go acts as a perfect glue language for
systems programming tasks like wiring in an issue tracker API to a
continuous integration system. And, the GitHub API has great language
bindings for Go.

In this chapter we will explore creating a webhook using Go and the
GitHub libraries. Along the way we will show how the GitHub libraries
for Go support common Go idioms and dig deeper into the way these
libraries work.

[NOTE]
One question: why setup a webhook? In other words, is there a fun
reason we could create for the "why" and what to do when the webhook
runs? What about running the Go test suite on the code itself? If it
fails, "fly the Jolly Roger" (the pirate flag) and if it passes "fly
the white flag." I liked your idea about using Jolly Roger and had fun
reading the wiki page on it. http://en.wikipedia.org/wiki/Jolly_Roger.
In other words, the webhook runs, triggering a run through of the
tests. We get a pass or fail, and if a failure occurs, beware of the
encroaching pirate ship (meaning your manager coming to yell at you
for breaking the build...).

=== About Go

Over the last couple years the Go programming language has been on a
meteoric rise in popularity. Conceived in 2007 Go's main purpose was
to increase a programmers efficiency in their day-to-day work. Go's
standard library comes with built in modern tools to excel in today's
web focus clustered multicore environments.

Go is all about making the programmer's life easier. With built in
support for JSON, HTML, HTTP, templating and concurrency Go is ready
for any project.

Describing Go to another programmer often feels like being the host of
infomercial. Remember those long compile times? Gone! Remember the
endless bickering over formatting and documentation? Gone!

Documentation and formatting are taken care of at the language level.
Getting the documentation for a particular library is as easy as going
to godoc.org. Making sure your code is formatted properly is as easy
as `go fmt`.

=== Go Getting Started

Luckily if you're new to Go it's has a very user friendly installation
process.

Visit: http://golang.org/doc/install

I would recommend using an installer. You can also download an archive
or source and install it manually. The package install is nice in that
it will take care of almost everything for you. You can download it
at:

http://golang.org/dl/

I would also recommend the latest "stable" version. At the time of
writing this the latest stable version is 1.3.1. Also make sure you
grab the right one for your architecture and OS.

=== GOPATH

There is one very important environment variable that we will discuss
next: GOPATH

The `GOPATH` environment variable is a comma delimited list of
locations where go will look for packages. It is where the source for
your code with live alone with the code you need to import to run your
code. Each location in the `GOPATH` needs to have three specific
directories in it: bin, src and pkg.

The `bin` directory is where the compiled binaries live.

The `pkg` directory has all the installed package objects. You'll
rarely have to go into the pkg directory yourself. If peek in you'll
find a subdirectory for each operating system and architecture the
packages that were build for it.

Finally the `src` directory. This is where you'll spend most of your
time. Nested in the `src` directory is the import path for each
package.

For our use case we're going to keep it simple and have just one
location in our `GOPATH`. Depending on how you installed Go you might
already have GOPATH set.

To check run:

[source,bash]
-----
$ echo $GOPATH
-----

This will print of the current value of the GOPATH environment
variable. Lets set our GOPATH to a subdirectory in our `HOME`
directory:

[source,bash]
-----
$ export GOPATH=$HOME/go
-----

This would be a good time to add the line above your bash/zsh profile
so when you start your next terminal session GOPATH is set for you.

=== What we are going to build

You can build almost anything with Go but today we're going to build
ourselves a webserver that responds to Github Webhooks.

Our goal will be to create a server that runs a repository's tests
when ever there is a new commit. Then comments the output of the tests
on the commit on Github.

=== Introduction to Github webhooks

Until now most of the interaction we've had with Github is pushing,
viewing or requesting information from github. Us telling github what
to do. Webhook are the opposite. Github will send our server
information when events happen on Github's servers.

https://developer.github.com/webhooks/

Github webhooks provide the ability for your service to get data
pushed from Github. When and event happens on Github your service will
get notified. By setting up a webhook you're telling github: when
something happens tell me. There are a couple ways to setup these
hooks but we're going to ask Github to send us JSON describing the
event. The JSON or "payload" Github will send us will contain
information about what event happened, when and to which repository.

To view all supported events visit:
https://developer.github.com/webhooks/#events

=== Our Project

You can use these webhooks to start builds, notifiy your team on
commits or anything else your mind can come up with. For our project
we are going to make a server that will run `make test` on any new
commit. Anytime we push a new commit to our repositoty Github will
send our server the information about the new commit, our
server will pull down the code an run the test to make sure we haven't
broken anything.

To make our web server we'll need to be able to connect and interact
with the Github api. For this we'll use `go-github` written by Google.
You can find the sounce code here:

https://github.com/google/go-github

To get you acclimatized to Go's ecosystem lets look at the godoc for
this libary. To view the documentation **prepend** "godoc.org" into
the url:

https://godoc.org/github.com/google/go-github

GoDoc can generate documentation for Go packages hosted
on GitHub, Bitbucket,  Launchpad and Google Project Hosting. It's an
amazing tool. One, if you plan on taking up Go, you should get
accustom to.

We will be using two of the sections in the package.

WebHookPayload: http://godoc.org/github.com/google/go-github/github#WebHookPayload

RepositoriesService.CreateComment: http://godoc.org/github.com/google/go-github/github#RepositoriesService.CreateComment

But take a minute to look over the `github` package documentation. You
can see just about everything in Github's API is mapped out here.

=== Go get

The `go get` command is how you download go code and dependencies.
Running `go get` followed by a projects URL will download and install
the project.

Lets install the `github.com/google/go-github/github` project:

[source,bash]
-----
go get github.com/google/go-github/github
-----

The command should exit with no output. But what exactly did we just do?

The go get command just downloaded the source of the project and installed
it in your `GOPATH` in a subdirectory matching the project's URL.
We can look at the package's source by going into the
`src` folder inside our `GOPATH`.

[source,bash]
-----
cd $HOME/go/src/github.com/google/go-github/github
-----

The great thing about the `go get` itself is that it is url aware.
It knows to use git when downloading `github.com/google/go-github`,
knows to use Mercurial when downloading `code.google.com/p/goauth2/oauth`.

It just happens the `code.google.com/p/goauth2/oauth` project is another
dependencies we'll use later so lets install it as well:

[source,bash]
-----
go get code.google.com/p/goauth2/oauth
-----

You might get an error that the Mercurial command is missing. If you do you
can install Mercurial with Homebrew:

[source,bash]
-----
brew install mercurial
-----

=== Project structure

Time to start writing some Go code. Let setup our workspace so we can
get started.

The go tool is setup to work with open source software. As we saw with `go get`
command, the go tool uses a package's location to store the source locally on
your machine.

Go code's directory structure is intrinsically linked
to the public location of the code. Our project should do the same.

On Github create a new project call "gowebhooks". The URL for your
project should be 'http://github.com/{yourusername}/gowebhooks'.

[source,bash]
-----
src/github.com/jpoz/gowebhooks
-----

To create the directory we will run:

[source,bash]
-----
$ mkdir -p $GOPATH/src/github.com/{yourusername}/gowebhooks
-----

And move into our project directory:

[source,bash]
-----
$ cd $GOPATH/src/github.com/{yourusername}/gowebhooks
-----

We are going to keep it simple with our project and keep all of our code in a
single file (other than tests).

Lets create a `gowebhooks.go` file:

[source,bash]
-----
$ touch gowebhooks.go
-----

To get started and get familiar with some go code lets write a very simple
webserver to just return "hello world".

gowebhooks.go

[source,go]
-----
package main

import (
	"fmt"
	"net/http"
)

func helloWorldHandler(w http.ResponseWriter, r *http.Request) {
  fmt.Fprintln(w, "Hello World")
}

func main() {
	http.HandleFunc("/", helloWorldHandler)

	fmt.Println("Listening on 4567")
	err := http.ListenAndServe(":4567", nil)

	fmt.Println(err)
}
-----

The file has four parts: package declaration, import statement, helloWorldHandler function and main function. Lets go over each:

===== package main

The first line of any go code needs to declare which package it belongs to. For
our server we're declaring this code belongs to the `main` package. The `main`
package is used when we want to create an executable. It tells go to load the
file then start our program by executing the `main()` function.

If we wanted our code to be a reusable package we would need to choose another
name.

===== import

Next we to import the libraries our code depends one. In this simple example we
only depend on two packages from the standard library: `fmt` and `net/http`.

The `fmt` package is a formating utility. We will use it to write output to
standard out and to write content from our server.

The `net/http` package is go's standard http library. We will use it to startup
an http server but the package also includes http clients to get http content
as well.

===== helloWorldHandler

This function will handle our http request and response. Using the `fmt` package
we write "Hello World" to the `ResponseWriter`.

===== main()

The `main()` function will be called when we compile and run our code. In it we
tell the http package to send requests to `"/"` to our `helloWorldHandler`.

Then we started the package's default http server by calling `ListenAndServe`
on the `http` package.

[source,go]
-----
err := http.ListenAndServe(":4567", nil)
-----

The `ListenAndServe` function will block until it errors. Notice we're using the
`:=` operator to save the error if one occurs.

The `:=` operator can be used instead of explicitly creating a variable and
setting it's assignment.

We could alternatively write:

[source,go]
-----
var err error
err = http.ListenAndServe(":4567", nil)
-----

But isn't one line just so much cleaner. :)

==== Running our project

Lets run our project to make sure we've got everything working. In our project
directory lets run:

[source,bash]
-----
$ go run gowebhooks.go
-----

Navigate your browser to http://localhost:4567/ and you should
see a page greeting you.

Give yourself a pat on the back, you just made your first Go server!

=== Receiving webhooks from Github

First step in receiving webhooks is turning them on at github.com.
Navigate to your gowebhooks repository on Github.

https://github.com/{username}/gowebhooks/settings/hooks

In the settings panel you'll find "Webhooks & Services". There you
should find a "Add Webhook" button. Click it and lets get started

image::images/go-webhook.png[]

### Setting up a tunnel

To create our webhook we need to provide a "Payload URL". In this case
we're going to want github to send webhooks to our local computer.
Giving github "localhost" won't do us any good. Since we're not on the
same network as github's servers. We need a public address for our
local computer. To allow github to have connectivity to our local
computer we'll need to tunnel a public address to our local computer.

The Github documentation recommends "ngrok.com" for this task. Ngrok
runs a small daemon on our local machine that tunnels traffic back and
forth to a public address on their site. So any traffic that hits the
given unique address provided by ngrock will be proxied from ngrok.com
to our local machine. Visa versa, if we send anything to the daemon it
will be proxied to ngrok.com and sent by their servers.

To get ngrok install follow the instructions at
"https://ngrok.com/download". Or if you're a homebrew user:

[source, bash]
-----
brew install ngrok
-----

We want to proxy all traffic from port 80 (default http port) from
ngrok to our server's port locally, port 4567.

[NOTE]
Quick warning before we start up ngrok.
When we start ngrok port 4567 on our local machine will be accessible
to the **entire** internet. Sound a little scary but ngork gives us a
unique subdomain and we can always shutdown the daemon to close the
connection.

To start tunneling traffic run:

[source, bash]
-----
$ ngrok 4567
-----

You should see the tunnel starting up and tunnel status of "online".
Below that should be your unique ngrok url. The url should look
something like: http://1a2b3c4d.ngrok.com/

Leave ngrok running in a terminal window. In another terminal window
navigate back to your project directory and restart your server:

[source, bash]
-----
$ go run gowebhooks.go
-----

Now navigate your browser to your unique ngrok url. You should see the
same page as when you connected to the sever locally.

### Setting the Payload URL

We can now tell Github where to send our webhooks. Go back to your
repository's "Add webhook" page and enter in your unique ngrok url
followed by `/webhook`. For me that's: `http://1a2b3c4d.ngrok.com/webhook`.

Make sure the content type is `application/json` and set the secret to
something you'll remember. Something like: "DangerZone". We'll just be
working with push events. So you can leave "Just the push event"
selected. Click "Add webhook" to save your settings.

image::images/go-webhook-payload-url.png[]

==== Setting up our webhooks endpoint

We now have connectivity to Github and Github has the ability to POST to us.
Now we need to decide what we want to do with the information Github gives us.

We have our `helloWorldHandler` now lets build our `webhookHandler`.

We will need to do a few things in our `webhookHandler`

1. Check what type of Event we're getting from Github.
2. Read the body of JSON in the request.
3. Parse the JSON into something Go can use.
4. Pass the parsed JSON on to something that can run the tests.

Below is the entire `server.go`. Notice it has some lines commented out.

[source, go]
----
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"os/exec"

	"code.google.com/p/goauth2/oauth"
	"github.com/google/go-github/github"
)

var (
	accessToken = os.Getenv("GITHUB_ACCESS_TOKEN")
	transport   = &oauth.Transport{Token: &oauth.Token{AccessToken: accessToken}}
	client      = github.NewClient(transport.Client())
)

func webhookHandler(w http.ResponseWriter, r *http.Request) {
	eventType := r.Header.Get("X-GitHub-Event")
	log.Printf("Received: %s event", eventType)

	if eventType != "push" {
		return
	}

	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		fmt.Println(err)
		return
	}

	payload := github.WebHookPayload{}
	json.Unmarshal(body, &payload)

  go run(payload)

	fmt.Fprintln(w, "OK")
	log.Printf("Responded: OK")
}

func run(payload github.WebHookPayload) {
  buffer, err := runMakeTest(payload)
  if err != nil {
    log.Printf("runMakeTest: %s", err)
  }

  log.Printf("%s", buffer)

  resp, err := commentOutput(payload, buffer)
  if err != nil {
    log.Printf("commentOutput: %s\n%s", err, resp.Body)
    return
  }
  log.Printf("Commented on: %s", *payload.HeadCommit.ID)
}

func runMakeTest(payload github.WebHookPayload) (*bytes.Buffer, error) {
	buffer := bytes.NewBuffer([]byte{})
	tempDir, _ := ioutil.TempDir("/tmp", "gowebhooks")

	giturl := *payload.Repo.SSHURL
	// Replace line above if not private repo
	// giturl := *payload.Repo.CloneURL
	gitref := *payload.HeadCommit.ID

	var commands [3]*exec.Cmd

	cloneCmd := exec.Command("git", "clone", giturl, tempDir)

	checkoutCmd := exec.Command("git", "checkout", "-b", gitref, gitref)
	checkoutCmd.Dir = tempDir

	makeTestCmd := exec.Command("make", "test")
	makeTestCmd.Dir = tempDir

	commands[0] = cloneCmd
	commands[1] = checkoutCmd
	commands[2] = makeTestCmd

	for _, cmd := range commands {
		buffer.WriteString(fmt.Sprintf("\n%s\n", cmd.Args))
		cmdOutput, err := cmd.CombinedOutput()
		buffer.Write(cmdOutput)
		if err != nil {
			return buffer, err
		}
	}

	return buffer, nil
}

func commentOutput(payload github.WebHookPayload, output *bytes.Buffer) (*github.Response, error) {
	owner := *payload.Repo.Owner.Name
	repo := *payload.Repo.Name
	gitref := *payload.HeadCommit.ID

	commentBody := bytes.NewBufferString("Created by gowebhooks!")
	commentBody.WriteString("\n```")
	commentBody.Write(output.Bytes())
	commentBody.WriteString("```")

	commentBodyString := commentBody.String()

	comment := &github.RepositoryComment{
		Body: &commentBodyString,
	}

	_, resp, err := client.Repositories.CreateComment(
		owner,
		repo,
		gitref,
		comment)

	return resp, err
}

func main() {
	http.HandleFunc("/webhook", webhookHandler)

	fmt.Println("Listening on 4567")
	err := http.ListenAndServe(":4567", nil)
	fmt.Println(err)
}
----

The code above can be thought of as 6 sections:

* import and vars
* webhookHandler
* run
* runMakeTest
* commentOutput
* main()

Lets go over each individually:

===== import and vars

At the top of our `gowebhooks.go` file there is an import statement. In it is
listen each of the dependencies of our project. Notice it has two sections first
dependencies with shorter names like `"os/exec"` or `"bytes"`. These are the
standard library dependencies for our project. They come with the standard
installation of go.

Next are dependencies with longer URL names. These are our remote dependencies.

When you import remote packages into you actually use the public location
of the code in your code to import the package.

For example when we import Google's go-github package we will write:

[source, go]
----
import "github.com/google/go-github/github"
----

The location of the package locally mirrors the package's location on
the internet.

The `var` section sets up global variables we can use across functions. Our
project has three: `accessToken`, `transport` and `client`

- `accessToken` is the value of the environment variable "GITHUB_ACCESS_TOKEN".
You might already have this set, if not we'll go over that later.
- `transport` is an oauth http transport using the accessToken. If you want more
information on oauth transports checkout the documentation for the oauth package
we're using: http://godoc.org/code.google.com/p/goauth2/oauth
- `client` will be our authenticated github client. It will use the transport
we created with the accessToken to talk to GitHub. Using an authenticated client
allows us to comment on our project via the API.

===== webhookHandler

Our `webhookHandler` function's purpose will be to take an http request
read/validate the request's data and pass it on to our other functions.

We only want `push` events. So we need to check the event type before we
proceed. The event type received by our server is kept in a `X-GitHub-Event`
header. We will get the event type and return from the function if it does
not equal "push".

[source, go]
----
eventType := r.Header.Get("X-GitHub-Event")
log.Printf("Received: %s event", eventType)

if eventType != "push" {
  return
}
----

Next we need to read in the JSON GitHub has sent us. This is done in two steps:
First we will read in the byts from our request then create a `struct` of the
json we can pass to other functions.

Our `webhookHandler` was passed a `http.Request` which has a `Body`
`io.ReadCloser`. The `io/ioutil` package defines a bunch of helpful functions to
deal io objects such as the `io.ReadCloser`. We need to read all of the bytes
from our `io.ReadCloser`. We'll use the `ReadAll` function from the `io/ioutil`
package to do so. Now that we have the bytes we can parse them as JSON.

JSON is built into the standard Go library via the `encoding/json`
package. You need two things to decode JSON: the expected data type and bytes
to decode.

Luckily the `github.com/google/github-go` package has already defined a struct
that can be populated by the bytes we read in.

Look at the godoc for the WebHookPayload struct:

[soruce,go]
----
type WebHookPayload struct {
    After      *string         `json:"after,omitempty"`
    Before     *string         `json:"before,omitempty"`
    Commits    []WebHookCommit `json:"commits,omitempty"`
    Compare    *string         `json:"compare,omitempty"`
    Created    *bool           `json:"created,omitempty"`
    Deleted    *bool           `json:"deleted,omitempty"`
    Forced     *bool           `json:"forced,omitempty"`
    HeadCommit *WebHookCommit  `json:"head_commit,omitempty"`
    Pusher     *User           `json:"pusher,omitempty"`
    Ref        *string         `json:"ref,omitempty"`
    Repo       *Repository     `json:"repository,omitempty"`
}
----

https://godoc.org/github.com/google/go-github/github#WebHookPayload


Notice each field on the struct has a `json` "struct tag" that maps the JSON
key to the field in the Go struct. For example the `Repo` field in the Go
struct will be populated with the `repository` key's value in the JSON. Each
tag also has `omitempty` which will omit the field if the value is
empty.

To recap: Our webhookHandler function read in some bytes via the `io/ioutil`
package. Then handed those bytes to the `encoding/json` package to unmarshal
them into a `github.WebHookPayload` struct.

[soruce,go]
-----
body, err := ioutil.ReadAll(r.Body)
if err != nil {
  fmt.Println(err)
  return
}

payload := github.WebHookPayload{}
json.Unmarshal(body, &payload)
-----

We now have our `payload` variable filled in with the JSON GitHub sent us.

Next we start the process of running the test by passing our `payload` to the
`run` function.

[soruce,go]
-----
go run(payload)
-----

Notice we prepend the function call with the `go` command. We could run the
`run` function without the `go` call. But with it the `run` function will be
executed in it's own goroutine. This allows the execution of the `run` function
to happen concurrently with the rest of the `webhookHandler`. Meaning, we can
run the `run` function (which will take sometime) and quickly respond to
GitHub at the sametime.

We don't need to response back to GitHub with anything special. We'll just
respond back with `"OK"`. And for good measure log what we did.

[soruce,go]
-----
fmt.Fprintln(w, "OK")
log.Printf("Responded: OK")
-----

===== run

During the execution of the `webhookHandler` we started the execution of the
`run` function. The run function will mostly just handle the execution of two
other functions: `runMakeTest` and `commentOutput`. But there are some nice
take aways from this function.

Twice in the `run` function you see the pattern:

[soruce,go]
-----
if err != nil {
  ...
}
-----

### Key take aways for gowebhooks.go

#### Handler arguments

In Go you can pass functions as arguments. In the `main()` function
we're passing the `webhookHandler` function as the second argument. We
can do this because the function conforms to the method signature defined
in `http.HandleFunc`.

If `webhookHandler` did not take a `http.ResponseWriter` as the first
argument and a `*http.Request` as the second argument we would get a
compilation error.

The `http.ResponseWriter` is used to respond and how `webhookHandler`
sends information back to Github. The ResponseWriter conforms to the
io.Writer interface. We'll go over interfaces a bit more later,
but conforming to the io.Writer interface basically means
`http.ResponseWriter` has a `Write(byte)` function.

We will use the Fprintf function in the 'fmt' package (which takes a
`io.Writer` as its first argument) to write back to Github.

The `http.Request` holds all the information Github posted over to us.

[NOTE]
For more information on the net/http package: http://golang.org/pkg/net/http/

#### io/ioutil

The `io/ioutil` package defines a bunch of helpful functions to deal
with files and other io objects. In `server.go` the package is used
to read the JSON body sent from Github so it can be parsed.

#### JSON parsing

#### Type of Payload

You also need to check it what type of Event Github has sent us. This
information is held in the "X-GitHub-Event" header in the `Request` object.

The `http.Request` Header has a `Get` function to access header
values.

[source,go]
-----
eventHeader := r.Header.Get("X-GitHub-Event")
-----

## Defining GithubProject struct




== Makefile

Haven't heard of a Makefile? Don't worry, you've probably already used them and
had no idea. Ever type `make install` while going through a tutorial? Well that's
you running the "install" target with the Make utility.

Makefiles are simple in their structure.

* A target
* The dependencies of that target
* System command(s) to build that target

[source]
-----
target: dependencies
[tab] system command(s)
-----

For our project we're going to make two targets: run and test

The `run` target will startup our web server. We will also make this the first
target. This will make the `run` target the default, allowing us to just call
`make` to startup our server

The second target, `test`, will run our test suite.

Both the `run` and the `test` targets do not output files. This makes them both
phony targets. We need to make sure the Make utility know this. If we did not
mark them as phony targets and had a file named "run", our make task would never
be able to run.

[source,Makefile]
-----
.PHONY: run test
run:
	go run cmd/gowebhooks-server/main.go
test:
	go test
-----

[NOTE]
The space before each system command must be a **tab** characters. Make sure
your editor isn't turning tabs into spaces.

# THOUGHTS
* More comments in code?
* Level of Go knowledge?
* Less files? Larger files?


