== Gists

GitHub "gists" are a place to share snippets of code. To create a gist, go to
gist.github.com and enter in any textual data. You then choose public or
secret access and create the gist. After creating the gist, you receive a
shareable URL with the code. If the type of textual data is specified,
usually the coding language type, then the code will be formatted in a
pretty way for better readability. If you need to share a small bit of code,
or write something and discuss it, gists are a great tool. 

There are other services that do this: pastebin was the first, and
there are many others that offer variances on code sharing. But gists
by GitHub are not simply a pasting service. Gists are first class
repositories, forkable, editable and expansive. We'll go over the basics
of what gists are, and how to create them, and then show how they
allow you to share code that is also a live application.

=== Gists are repositories

Every gist
created is a tiny repository. You can update gists and see
the history using `git log`. You can download gists, hack on the
repository, and `git push` them back into the repository on
gist.github.com (which will republish them onto the publicly 
facing web page). And, you can "fork" gists, just like
any other repository. 

You are allowed to branch within gist repositories; however, branches
are not displayed inside of gist.github.com. But, if you need the
benefits of branching when using GitHub gists you can branch normally
inside a repository and keep the branch information on the upstream
repository after you push it up. 

You can have an unlimited number of public and secret gists. Instead
of creating a new private repository from your limited amount in a
paid GitHub account, you can take a tiny bit of code
and make a secret gist, sharing this with others through a URL
instead of the more onerous process of adding collaborators to a
regular repository. Or, you can make a gist public, and
share that URL to mailing lists or anywhere you need public feedback.

[NOTE]
As there are two types of gists (public and secret), it is important the understand the
differences between them. Public gists are searchable. Secret gists
are not searchable, but they are accessible to anyone who knows
the URL. Don't post any code to gist which you need to keep secret as
once you put it there, it is only as safe as the URL is secret.  

=== Embedding Gists

Gists are embeddable as shareable code snippets inside of blogs or any
web page. 

==== Inside HTML pages

To embed inside of an HTML page look for the "Embed this gist" box to
the left of a gist. Copy the code listed there (which will look
something like `<script
src="https://gist.github.com/xrd/8923697.js"></script>` and paste it
into your HTML. 

==== Inside Jekyll blogs

Jekyll supports a fast shortcut code to embed a public gist inside of your
Jekyll blog hosted on GitHub, or on any site built on the
"github-pages" branch mechanism (described in the "GitHub Pages"
chapter).  The shortcut `{% gist 8138797 %}` will embed a private gist
which would be found at `http://gist.github.com/8138797`. 

If you want to use a specific file within the gist, add a filename to
the gist code like `{% gist 8138797 hi.rb %}`.

Secret gists can also be embedded. If you use a secret gist, prefix
the username of the account holder in the gist like so: `{% gist xrd/8138797 hi.rb %}`.

=== Gist from the command line

`gem install gist` will install a command line tool which assists in
creating gists. You can use it simply by typing the command, and then
entering the data you want to post as a gist.

[source,bash]
-----
$ gist
(type a gist. <ctrl-c> to cancel, <ctrl-d> when done)
{ "foo" : "bar" }
https://gist.github.com/9106765
-----

The gist command will return the link to the gist just created. Gists
are created anonymously by default. You can login using the `--login`
switch. Once you do this, your gists will be linked to
your account.

[source,bash]
-----
$ gist --login
Obtaining OAuth2 access_token from github.
GitHub username: xrd
GitHub password: 
2-factor auth code: 787878

Success! https://github.com/settings/applications
-----

You can pipe text to the gist command to use the contents of that
file.

[source,bash]
-----
$ echo '{ "foo" : "bar" }' | gist
https://gist.github.com/9106799
-----

You can also `cat` a file to gist.

[source,bash]
-----
$ cat MyJavaFile.java | gist
https://gist.github.com/9345609
-----

Gists are often used to show interesting or troublesome code and there
are times when you don't want to display the entirety of a file. In
this case the command line `grep` tool can be a useful; `grep` searches
for a specific piece of code and with the right switches can include
several lines of context around that code inside a gist. This command
looks for the function `myFunction` inside the `MyJavaFile.java` file
and then prints the next 20 lines of context and stores it as a gist.

[source,bash]
-----
$ grep -A 20 myFunction MyJavaFile.java | gist
https://gist.github.com/9453069
-----

Adding the `-o` switch automatically opens the gist inside your
default web browser. You can also copy the gist URL to the clipboard
using the `-c` switch. Or, you can copy the contents of your clipboard
into a gist using the `-P` switch. 

There are many other fun features of the gist command. To learn more
run the gist command with the `--help` switch. 

[source,bash]
-----
$ gist --help
Gist (v4.2.0) lets you upload to https://gist.github.com/

The content to be uploaded can be passed as a list of files, if none are
specified STDIN will be read. The default filename for STDIN is "a.rb", and all
filenames can be overridden by repeating the "-f" flag. The most useful reason
to do this is to change the syntax highlighting.

If you'd like your gists to be associated with your GitHub account, so that you
can edit them and find them in future, first use `gist --login` to obtain an
Oauth2 access token. This is stored and used by gist in the future.

Private gists do not have guessable URLs and can be created with "-p", you can
also set the description at the top of the gist by passing "-d".

Anonymous gists are not associated with your GitHub account, they can be created
with "-a" even after you have used "gist --login".

If you would like to shorten the resulting gist URL, use the -s flag. This will
use GitHub's URL shortener, git.io. You can also use -R to get the link to the
raw gist.

To copy the resulting URL to your clipboard you can use the -c option, or to
just open it directly in your browser, use -o. Using the -e option will copy the
embeddable URL to the clipboard. You can add `alias gist='gist -c'` to your
shell's rc file to configure this behaviour by default.

Instead of creating a new gist, you can update an existing one by passing its ID
or URL with "-u". For this to work, you must be logged in, and have created the
original gist with the same GitHub account.

Usage: gist [-o|-c|-e] [-p] [-s] [-R] [-d DESC] [-a] [-u URL] [-P] [-f NAME|-t EXT]* FILE*
       gist --login

        --login                      Authenticate gist on this computer.
    -f, --filename [NAME.EXTENSION]  Sets the filename and syntax type.
    -t, --type [EXTENSION]           Sets the file extension and syntax type.
    -p, --private                    Makes your gist private.
        --no-private
    -d, --description DESCRIPTION    Adds a description to your gist.
    -s, --shorten                    Shorten the gist URL using git.io.
    -u, --update [ URL | ID ]        Update an existing gist.
    -a, --anonymous                  Create an anonymous gist.
    -c, --copy                       Copy the resulting URL to the clipboard
    -e, --embed                      Copy the embed code for the gist to the clipboard
    -o, --open                       Open the resulting URL in a browser
        --no-open
    -P, --paste                      Paste from the clipboard to gist
    -R, --raw                        Raw url of the new gist
    -h, --help                       Show this message.
    -v, --version                    Print the version.

-----

=== Gists as fully functioning apps

You can use gists to store entire apps. Let's create a
simple Sinatra app.

Sinatra is a ruby library for creating dead-simple web servers. A sinatra program looks as
simple as this:

[code,ruby]
-----
require 'sinatra'

get '/hi' do
  "Hello World!"
end

-----

Create a gist for this by visiting gist.github.com. Enter in the text exactly as above and then choose
public gist.

You now have a shareable gist of code, which anyone can use to review.
More importantly, this is an executable piece of code. To use it,
click into the "Clone this gist" box to the left of the body of
content. You'll get a URL which looks something like this: 

https://gist.github.com/8138797.git

Copy this and then enter a terminal program and enter this command:

[source,bash]
$ git clone https://gist.github.com/8138797.git
$ cd 8138797

Now, you are inside the gist repository. If you look inside the
repository you'll see a list of files, a list which right now numbers
only one file.

[source,bash]
----
$ ls
hi.rb
----

To run this code, enter `ruby hi.rb`

If you had not used sinatra with ruby before, this will cause an
error. This program requires a library called "sinatra" and 
you have not yet installed it. We could write a README, or add
documentation into this file itself. Another 
way to guarantee the user has the proper files installed is to use a
"Gemfile" which is a file that tells 
which libraries are installed and from where. That sounds like the
best way:

[source,bash]
-----
$ printf "source 'https://rubygems.org'\ngem 'sinatra'" > Gemfile
-----

The `bundle` command (from the bundler gem) will install sinatra and
the associated dependencies.

[source,bash]
-----
$ bundle
Using rack (1.5.2) 
Using rack-protection (1.5.1) 
Using tilt (1.4.1) 
Using sinatra (1.4.4) 
Using bundler (1.3.5) 
Your bundle is complete!
Use `bundle show [gemname]` to see where a bundled gem is installed.
-----

Why did we do things this way? Because now we can add the Gemfile to
our repository locally, and then publish into our gist for sharing on
the web. Our repository now not only has the code, but a well know
manifest file which explains the necessary components when running the
code. 

To publish our changes back into our gist from the command line, we
need to update the "remote" repository reference. When we 
first cloned the repository we used the https link. If we are using
SSH keys (and you should be; read the section "When should I use SSH
vs HTTPS?") then we need to switch to use the SSH URL format (git
protocol). Run this command:

[source,bash]
-----
$ git remote -v
origin       https://gist.github.com/8138797.git (fetch)
origin       https://gist.github.com/8138797.git (push)
-----

Your results will be slightly different, but this output displays our
remote repository; in other words, where we pull and push our code
changes. If you are familiar with the way 
that remotes work on GitHub you can see that this is a read-only URL.
We need to adjust these URLs in our remote so that it points to the
read-write remote URL. To do that, remove the `https://` part and add
a `git@`. Then, change the first `/` character after the
`gist.github.com` URL to a `:` character. If your remote was the same
as above you would have this `git@gist.github.com:8138797.git`. Then,
in a terminal window run these commands:

[source,bash]
----
$ git remote rm origin
$ git remote add origin git@gist.github.com:8138797.git
----

Now you can push new content in via the command line as well as edit
files inside of GitHub.com. As you develop your app you have
flexibility in whichever way fits you best.

=== A gist that displays gists

Let's add to our application and use the octokit gem to pull all
public gists for any user we specify. Why would we want to make a gist
that displays other gists? Self-referential meta code is all the rage, the
modern day response to René Magritte's famous work: "Ceci n'est pas une
pipe.".footnote:[Explained best by Ben
Zimmer http://www.bostonglobe.com/ideas/2012/05/05/dude-this-headline-meta-dude-this-headline-meta/it75G5CSqi82NtoQHIucEP/story.html?camp=pm]

Add a view `index.erb` at the root of our directory.

[code,ruby]
-----
<html>
<body>

User has <%= count %> public gists

</body>
</html>

-----

Add the octokit gem to our Gemfile:

[source,ruby]
-----
gem "octokit"
-----

Run `bundle` to install octokit. Then, modify our hi.rb app to look
like this:

[code,ruby]
-----
require 'sinatra'
require 'octokit'

set :views, "."

get '/:username' do |username|
  user = Octokit.user username
  count = user.public_gists
  erb :index, locals: { :count => count }
end

-----

Our filesystem should look like this, with three files.

[source,bash]
-----
$ ls -1
Gemfile
hi.rb
index.erb
-----

Run `bundle` to install octokit and restart Sinatra by running ctrl-c,
and then `ruby hi.rb`. If you visit `http://localhost:4567/xrd` in
your browser, you will see the count of public gists for user `xrd`;
modify the username in the URL to any specify any GitHub username and you will see
their last five gists displayed.

image::images/gists-gist-count.png[]

==== Going deeper into the Gist API

The GitHub API uses hypermedia instead of
basic resource driven APIs. If you use a client like Octokit, the
hypermedia details are hidden behind an elegant ruby client. But,
there is a benefit to understanding how hypermedia works when you need
to retrieve deeper information from the GitHub API.

Most RESTful APIs come with a "sitemap", generally a API reference
document which tells a user which endpoints to use. You view
the resources available from that API and then apply some HTTP verb to
do something to them. Hypermedia thinks of an API differently.
Hypermedia APIs describe themselves inside their responses using
"affordances." What this means is that the API might respond like this:

[source,json]
-----
{
    "_links": {
        "self": {
            "href": "http://shop.oreilly.com/product/0636920030300.do"
        }
    }
    "id": "xrd",
    "name": "Chris Dawson"
}
-----

In this payload, you can see that there is an id ("xrd") and a name
("Chris Dawson"). Most APIs offer JSON responses, and this one
does too. This particular payload was forked from the HAL explanation at the
https://phlyrestfully.readthedocs.org/en/latest/halprimer.html:[HAL
Primer document] and you can find a more detailed explanation of these concepts
there. 

The important thing to note about Hypermedia APIs is that payloads contain
metadata about data itself and metadata about the possible options of
operating on the data. RESTful APIs typically provide a mapping
outside of the payload. You have to join the API sitemap with the data
in an ad-hoc way when using RESTful APIs; with Hypermedia APIs your
client can react to the payload itself correctly and intelligently
without knowing anything about a sitemap stored in human readable
documentation. 

This loose coupling makes APIs and their clients flexible. In theory,
a Hypermedia API works intuitively with a Hypermedia aware client. If
you change the API, the client, as it understands Hypermedia, can
react and still work as expected. Using a RESTful API means that
clients must be updated (either a newer version of the client must be
installed) or the client code must be upgraded. Hypermedia APIs can
alter their backend and the client, as long as it is
hypermedia-aware, can automatically and dynamically determine
the right way to access information from the response itself. In other
words, with a hypermedia client the API backend can change and your
client code should not need to.

This is explained in great detail in the book http://www.amazon.com/o/ASIN/1449306578?tag=adapas02-20:[Building
Hypermedia APIs with HTML5 and Node].

In the case of Octokit, navigating hypermedia looks like this:

* Start at a resource, with code like `user = Octokit.user "xrd"`. This
  begins the initialization of the client.
* `user` now is an object filled with the actual data of the resource.
  In this case, you could call a method like `user.followers` to see a
  meager follower count.
* `user` also has hypermedia references. You can see these by calling
  `user.rels`. This retrieves the relationships described in the
  hypermedia links. In this case, calling `.rels` shows a map of
  relationships, displayed in ruby code like: `#<Sawyer::Relation::Map: [:avatar, :self, :html,
  :followers, :following, :gists, :starred, :subscriptions,
  :organizations, :repos, :events, :received_events]>`
* Using one of these relationships starts by keying into the
  relationship hash and then using the get and data methods to request
  that information from the GitHub API:
  `followers = user.rels[:followers].get.data`. 
* Once you call `.get.data` you will have a new followers object
  populated with an array of the followers (paged if it exceeds 100
  items). 

Let's extend our Sinatra app to retrieve actual data about the user's
gists by using hypermedia references.

[source,ruby]
-----
require 'sinatra'
require 'octokit'

set :views, "."

helpers do
  def h(text)
    Rack::Utils.escape_html(text)
  end
end

get '/:username' do |username|
  gists = Octokit.gists username, :per_page => 5
  erb :index, locals: { :gists => gists, username: username }
end

-----

The `index.erb` file contains code to iterate over each gist and pull
the content. You can see that our response object is an array of
gists, each which has an attribute called `fields`. This fields attribute
specifies the filenames available in each gist. If you reference that
filename against the files, the response includes a hypermedia `ref`
attribute. You can use this retreive the `raw` content using the
Octokit method `.get.data`.

[source,html]
-----
<html>
<body>

<h2>User <%= username %>'s last five gists</h2>

<% gists.each do |g| %>
<% g[:files].fields.each do |f| %>
<b><%= f %></b>: 

<%= h g[:files][f.to_sym].rels[:raw].get.data %>

<br/>
<br/>

<% end %>
<% end %>

</body>
</html>

-----

Now we see the gists and the contents.

image::images/gists-last-five.png[]


////

The main benefit of using Hypermedia is that you don't need to harcode
URLs into your application, making your application less brittle when
inevitable changes to the API occur. 
link:$$http://signalvnoise.com/posts/3373-getting-hyper-about-hypermedia-apis$$[Cool URIs don’t change] 
(ironically a post by David Heinemeier Hansen
talking about why Hypermedia is overblow). As I was developing this
simple Sintra application, I attempted to refactor the code. From that
point onward, the GitHub API issued redirects to all my calls for raw
gist data. So, while my code did not change, the end result did. I no
longer get the content, but a HTML message indicating I am being
redirected. Perhaps I am using the hypermedia references incorrectly,
but I was able to retrieve the correct content previously. Now I
am not. Perl people argue that "there is more than one way to do it"
(TIMTOWTDI) is a good thing, but in this case I am left wondering
whether I got it right and now GitHub broke their API, or if I never
had the interface to the API correct. The non-deterministic results of
the API via Hypermedia make me uncomfortable using it in production.

image::images/gists-hypermedia-broken.png[]

////
