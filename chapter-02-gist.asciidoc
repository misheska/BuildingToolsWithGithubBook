== Gists

Gists are great for code sharing. To create one, you can go to
gist.github.com and enter in some code. You then choose public or
private and create the gist. If you need to share a small bit of code,
or write something and discuss it, gists are a great tool. 

There are other services that do this: pastebin was the first, and
there are many others that offer variances on code sharing. But gists
by GitHub are not simply a pasting service.

=== Gists are repositories

Gists from GitHub are not just a place to paste code. Every gist
created is a tiny repository. You can update gists and see
the history. You can download them, hack on them, and `git push` them
back into the repository (which will republish them onto the publicly
facing web page). You get all the benefits of branching when using
GitHub gists if you need them. And, you can "fork" gists, just like
any other repository.

You can have an unlimited number of public and private gists. Instead
of creating a new private repository, you can take a tiny bit of code
and make a private gist, sharing this will others through a URL
instead of the more onerous process of adding collaborators to a
regular repository. Or, you can make a gist public, and
share that URL to mailing lists or anywhere you need public feedback.

=== No real privacy

As there are two types of gists (public and private), it is important the understand the
differences between them. Public gists are searchable. Private gists
are not searchable, but they are accessible to anyone who knows
the URL. Don't post any code to gist which you need to keep private as
once you put it there, it is only as a safe as the URL is private.  

=== Embedding Gists

You can embed gists as shareable code snippets inside of blogs or any
web page.

==== Inside HTML pages

To embed inside of an HTML page look for the "Embed this gist" box to
the left of a gist. Copy the code listed there (which will look
something like `<script
src="https://gist.github.com/xrd/8923697.js"></script>` and paste it
into your HTML. 

==== Inside Jekyll blogs

You can use the code `{% gist 8138797 %}` to embed a gist inside of your
Jekyll blog hosted on GitHub, or on any site built on the
"github-pages" branch mechanism (described in the "GitHub Pages" chapter). 

If you want to use a specific file within the gist, add a filename to
the gist code like `{% gist 8138797 hi.rb %}`.

Private gists can be embedded. If you use a private gist, you need to
prefix the username of the account holder in the gist like so: `{% gist
xrd/8138797 hi.rb %}`.

=== Gist from the command line

`gem install gist` will install a command line tool which assists in
creating gists. You can use it simply by typing the command, and then
entering the data you want to post as a gist.

[source,bash]
-----
$ gist
(type a gist. <ctrl-c> to cancel, <ctrl-d> when done)
{ "foo" : "bar" }
https://gist.github.com/9106765
-----

The gist command will return the link to the gist just created. Gists
are created anonymously by default. You can login using the `--login`
switch. Once you do this, your gists will be linked to
your account.

[source,bash]
-----
$ gist --login
Obtaining OAuth2 access_token from github.
GitHub username: xrd
GitHub password: 
2-factor auth code: 787878

Success! https://github.com/settings/applications
-----

You can pipe text to the gist command to use the contents of that
file.

[source,bash]
-----
$ echo '{ "foo" : "bar" }' | gist
https://gist.github.com/9106799
-----

Adding the `-o` switch automatically opens the gist inside your
default web browser. You can also copy the gist URL to the clipboard
using the `-c` switch. Or, you can copy the contents of your clipboard
into a gist using the `-P` switch. 

There are many other fun features of the gist command. To learn more
run the gist command with the `--help` switch. 

[source,bash]
-----
$ gist --help
Gist (v4.2.0) lets you upload to https://gist.github.com/

The content to be uploaded can be passed as a list of files, if none are
specified STDIN will be read. The default filename for STDIN is "a.rb", and all
filenames can be overridden by repeating the "-f" flag. The most useful reason
to do this is to change the syntax highlighting.

If you'd like your gists to be associated with your GitHub account, so that you
can edit them and find them in future, first use `gist --login` to obtain an
Oauth2 access token. This is stored and used by gist in the future.

Private gists do not have guessable URLs and can be created with "-p", you can
also set the description at the top of the gist by passing "-d".

Anonymous gists are not associated with your GitHub account, they can be created
with "-a" even after you have used "gist --login".

If you would like to shorten the resulting gist URL, use the -s flag. This will
use GitHub's URL shortener, git.io. You can also use -R to get the link to the
raw gist.

To copy the resulting URL to your clipboard you can use the -c option, or to
just open it directly in your browser, use -o. Using the -e option will copy the
embeddable URL to the clipboard. You can add `alias gist='gist -c'` to your
shell's rc file to configure this behaviour by default.

Instead of creating a new gist, you can update an existing one by passing its ID
or URL with "-u". For this to work, you must be logged in, and have created the
original gist with the same GitHub account.

Usage: gist [-o|-c|-e] [-p] [-s] [-R] [-d DESC] [-a] [-u URL] [-P] [-f NAME|-t EXT]* FILE*
       gist --login

        --login                      Authenticate gist on this computer.
    -f, --filename [NAME.EXTENSION]  Sets the filename and syntax type.
    -t, --type [EXTENSION]           Sets the file extension and syntax type.
    -p, --private                    Makes your gist private.
        --no-private
    -d, --description DESCRIPTION    Adds a description to your gist.
    -s, --shorten                    Shorten the gist URL using git.io.
    -u, --update [ URL | ID ]        Update an existing gist.
    -a, --anonymous                  Create an anonymous gist.
    -c, --copy                       Copy the resulting URL to the clipboard
    -e, --embed                      Copy the embed code for the gist to the clipboard
    -o, --open                       Open the resulting URL in a browser
        --no-open
    -P, --paste                      Paste from the clipboard to gist
    -R, --raw                        Raw url of the new gist
    -h, --help                       Show this message.
    -v, --version                    Print the version.

-----

=== Gists as fully functioning apps

You can use gists to store entire apps. Let's create a
simple Sinatra app.

Sinatra is a ruby library for creating dead-simple web servers. A sinatra program looks as
simple as this:

[code,ruby]
-----
require 'sinatra'

get '/hi' do
  "Hello World!"
end

-----

Create a gist for this by visiting gist.github.com. Enter in the text exactly as above and then choose
public gist.

You now have a shareable gist of code, which anyone can use to review this code. More importantly, this
is an executable piece of code. To use it, click into the "Clone this gist" box to the left of the body of 
content. You'll get a URL which looks something like this:

https://gist.github.com/8138797.git

Copy this and then enter a terminal program and enter this command:

[source,bash]
$ git clone https://gist.github.com/8138797.git
$ cd 8138797

Now, you are inside the gist repository. If you look inside the repository you'll see a list of files, which 
right now numbers only one.

[source,bash]
----
$ ls
hi.rb
----

To run this code, enter `ruby hi.rb`

If you had not used sinatra with ruby before, this will cause an
error. This program requires a library called "sinatra" and 
you have not yet installed it. We could write a README, or add
documentation into this file itself. Another 
way to guarantee the user has the proper files installed is to use a
"Gemfile" which is a file that tells 
which libraries are installed and from where. Let's add this:

[source,bash]
$ printf "source 'https://rubygems.org'\ngem 'sinatra'" > Gemfile

This is a quick way to add content to the file named Gemfile. To install the libraries required here, we run
the bundler command

[source,bash]
$ bundle
Using rack (1.5.2) 
Using rack-protection (1.5.1) 
Using tilt (1.4.1) 
Using sinatra (1.4.4) 
Using bundler (1.3.5) 
Your bundle is complete!
Use `bundle show [gemname]` to see where a bundled gem is installed.

This shows that we installed the library "sinatra" and the associated dependencies (rack, tilt and other associated
libraries). 

Why did we do things this way? Because now we can add this file to our repository locally, and then publish
into our gist for sharing on the web.

First, we need to update the "remote". Run this command:

[source,bash]
-----
$ git remote -v
origin       https://gist.github.com/8138797.git (fetch)
origin       https://gist.github.com/8138797.git (push)
-----

Your results will be slightly different, but this output displays our
remote repository; in other words, where we pull and push our code
changes. If you are familiar with the way 
that remotes work on GitHub you can see that this is a read-only URL.
We need to adjust these URLs in our remote so that it points to the
read-write remote URL. To do that, remove the `https://` part and add
a `git@`. Then, change the first `/` character after the
`gist.github.com` URL to a `:` character. If your remote was the same
as above you would have this `git@gist.github.com:8138797.git`. Then,
in a terminal window run these commands:

[source,bash]
----
$ git remote rm origin
$ git remote add origin git@gist.github.com:8138797.git
----

Now you can push new content in via the command line as well as edit
files inside of GitHub.com. As you develop your app you have
flexibility in whichever way fits you best.

=== A gist that displays gists

Let's add to our application and use the octokit gem to pull all
public gists for any user we specify.

Add a view `index.erb` at the root of our directory.

[code,ruby]
-----
<html>
<body>

User has <%= count %> public gists

</body>
</html>

-----

Add the octokit gem to our Gemfile:

[source,ruby]
-----
gem "octokit"
-----

Run `bundle` to install octokit. Then, modify our hi.rb app to look
like this:

[code,ruby]
-----
require 'sinatra'
require 'octokit'

set :views, "."

get '/:username' do |username|
  user = Octokit.user username
  count = user.public_gists
  erb :index, locals: { :count => count }
end

-----

Our filesystem should look like this, with three files.

[source,bash]
-----
$ ls -1
Gemfile
hi.rb
index.erb
-----

Run `bundle` to install octokit and restart Sinatra by running ctrl-c,
and then `ruby hi.rb`. If you visit `http://localhost:4567/xrd` in
your browser, you will see the count of public gists for any user you
specify.

image::images/gists-gist-count.png[]

==== Going deeper into the Gist API

The GitHub API uses hypermedia instead of
basic resource driven APIs. If you use a client like Octokit, the
hypermedia details are hidden behind an elegant ruby client. But,
there is a benefit to understanding how hypermedia works when you need
to retrieve deeper information from the GitHub API.

Most RESTful APIs come with a "sitemap", generally a API reference
document which tells a user which endpoints to use. You view
the resources available from that API and then apply some HTTP verb to
do something to them. Hypermedia thinks of an API differently.
Hypermedia APIs describe themselves inside their responses using
"affordances." What this means is that the API might respond like this:

[source,json]
-----
{
    "_links": {
        "self": {
            "href": "http://shop.oreilly.com/product/0636920030300.do"
        }
    }
    "id": "xrd",
    "name": "Chris Dawson"
}
-----

In this payload, you can see that there is an id ("xrd") and a name
("Chris Dawson"). Most APIs offer JSON responses, and this one
does too. This payload was forked from the HAL explanation at the
(https://phlyrestfully.readthedocs.org/en/latest/halprimer.html)[HAL
Primer] and you can find a more detailed explanation of these concepts
there. 

The important thing to note about Hypermedia APIs is that payloads contain
metadata about data itself and metadata about the possible options of
operating on the data. RESTful APIs typically provide a mapping
outside of the payload. You have to join the API sitemap with the data
in an ad-hoc way when using RESTful APIs; with Hypermedia APIs your
client can react to the payload correctly and intelligently. 

This loose coupling makes APIs and their clients flexible. In theory,
a Hypermedia API works with a Hypermedia aware client. If you change
the API, the client, as it understands Hypermedia, can react and still
work as expected. Using a RESTful API means that clients must be
updated (either a newer version of the client must be installed) or
the client code must be upgraded. Hypermedia APIs can alter their backend
and the client, as long as it is
hypermedia-aware, can automatically and dynamically determine
the right way to access information from the response itself. In other
words, with a hypermedia client the API backend can change and your
client code should not need to.

This is explained in great detail in the book (http://www.amazon.com/o/ASIN/1449306578?tag=adapas02-20)[Building
Hypermedia APIs with HTML5 and Node]

Let's extend our Sinatra app to retrieve actual data about the user's
gists by using hypermedia references.

[source,ruby]
-----
require 'sinatra'
require 'octokit'

set :views, "."

helpers do
  def h(text)
    Rack::Utils.escape_html(text)
  end
end

get '/:username' do |username|
  gists = Octokit.gists username, :per_page => 5
  erb :index, locals: { :gists => gists, username: username }
end

-----

The `index.erb` file contains code to iterate over each gist and pull
the content. You can see that our response object is an array of
gists, each which has an attribute called `fields`. This fields attribute
specifies the filenames available in each gist. If you reference that
filename against the files, the response includes a hypermedia `ref`
attribute. You can use this retreive the `raw` content using the
Octokit method `.get.data`.

[source,html]
-----
<html>
<body>

<h2>User <%= username %>'s last five gists</h2>

<% gists.each do |g| %>
<% g[:files].fields.each do |f| %>
<b><%= f %></b>: 

<%= h g[:files][f.to_sym].rels[:raw].get.data %>

<br/>
<br/>

<% end %>
<% end %>

</body>
</html>

-----

Now we see the gists and the contents.

image::images/gists-last-five.png[]


