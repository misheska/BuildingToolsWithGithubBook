==== Using Gollum

Gollum is the GitHub contribution to open source wikis. A wiki is defined as "a website that allows collaborative editing of its content and structure by its users." Just as Git has revolutionized collaborative editing of code, Gollum wikis layer the benefits of Git onto a proven publishing metaphor.

===== Many Editing Modalities

Editing Gollum content is flexible. Gollum wikis are editable locally within a web browser: run the `gollum` command locally on your laptop (which spawns a mini web server hosting your wiki) and then browse to http://localhost:4567. Gollum wikis are editable remotely using a web browser: edit on GitHub as just another repository using the standard GitHub web enabled editor tools. And, gollum wikis are editable locally using your favorite editor and tools, allowing you the flexibility of staying within the same workflow you use to edit any other file within a local repository. 

You might use a hybrid approach to editing your Gollum wiki, switching back and forth  between editing within the web browser interface and jumping into the command line and using your editor to create or modify files when you need to use "power commands." If you do this, remember that Gollum only processes files that have been checked into the repository; files which are only in the working directory or which have been added to the index but not yet commited are *not* processed by gollum. So, if you add a file using your editor or from the command line, make sure you `git add` and `git commit` the files to see them to make sure you see them in the browser interface.

===== Editing Gotchas with the Command Line

To illustrate this "gotcha" let's imagine adding a sidebar to our wiki. Adding a sidebar means you need to create a file called _Sidebar.md. This is a special file which Gollum recognizes and generates a sidebar for you; the first part of the name is fixed, but you can change the extension to whatever extension you prefer for your wiki files. If we use the "open" command (available on Mac or Linux) to open the Wiki in our default browser, you will see that only once we have committed the change to our repository do we actually see the sidebar.

```
$ gollum & # Start gollum, will run on port 4567.
$ printf "## Warning\nPlease note this is subject to change" > _Sidebar.md
$ open http://localhost:4567/ # We won't see our sidebar yet...
$ git add _Sidebar.md 
$ open http://localhost:4567/ # We still don't see our sidebar...
$ git commit -m "Add sidebar"
$ open http://localhost:4567/ # Eureka, now we will see our sidebar!
```

If you edit within the web browser interface, the underlying grit libraries do all the work to commit new files into the repository. If you use the command line, you'll need to remember to do this manually.

===== Editing Gollum Wikis Anytime, Anywhere

Gollum adds all the powerful features that automatically come with usage of a DCVS; you can edit your files offline, which is simply not the case with most wikis. If you check out your gollum repository and then hop on a plane without a wifi connection, you can edit files as you would any other Git repository. Once you have landed, you do the normal pull/push sequence as you would do with any other repository. If others have modified the repository, you use your standard tools to merge those changes and deal with conflicts. 

A word of caution when using the gollum command in server mode to edit files locally inside a web browser. If you start the gollum server from the command line you do have the capability to edit the files from any computer within the same network. In other words, you could find your IP address and use that address from your Chromebook or your tablet to view and edit your wiki. However, remember that the gollum server command does not have an authentication system built into it, which means that gollum thinks anyone accessing the wiki is the same user that started the gollum command. This is fine if you are in the other room editing on your tablet while gollum runs on your work laptop. However, the gollum server is not a good solution for offering a wiki up to many people within a subnet. If multiple people edit files, there is no way that gollum can track the different user contributions in the change log. This is not a problem when editing your Gollum wiki inside GitHub.com: the GitHub site knows who you are and properly assigns your changes to your username inside the change log.

==== Hacking Gollum

Gollum is a great way to build up living documentation of any project.
As everything is built on Git, you get history for free, and more
importantly, a way to extract that history using all your familiar Git
tools, either within the command line, or from GitHub. We've explored
how easy it is to edit Gollum wikis: from within the command line, from the web browser, or from
within GitHub. However, there might be times when you need to provide
a different editing modality. As long as you write files into the
repository in the way the gollum libraries understand, you can write
your own editing interface to suit your own needs. Let's build one!

===== Documenting Wireframe Discussions: Needs versus Reality

If you do much software development within a team larger than one person, you often find this scenario: a business
person develops the structure of the application with higher-up stakeholders, these ideas are passed down to a 
UI/UX designer who then creates wireframes and mockups of the interactions, and then a software developer takes
these wireframes and builds the software. Put another way, executives figure out what features provide the 
most value to users, which then trickles down into the wireframes as real interactions. Many hidden blocking 
paths are fleshed out here, places where the application would confuse the user, and time is saved 
because the software developer does not have to waste time building something that would not work anyway. By the time
it reaches the developer, the UI interaction is streamlined and the costly and inflexible stage of 
building software has all the inefficiencies optimized away. The developer can simply work on a piece of 
software and know there are no changes, changes which would be extremely costly to implement.

In practice, this process is never so smooth. What typically happens is the business people never completely
understand all the requirements, and ask for changes, which trickle down into the designs. The mockups are changed
and this then needs to be communicated to the developer, who has already started building something that was
"set in stone." Or, the developer, as they build the software, realize there are missing steps to get to places
inside the application, and they need to communicate this back to the designer. If you have multiple people
doing software development on a project, this information then needs to fan out to them if their areas are affected
by these changes. This information must traverse many different people, with many different methods of communication.

Wikis are a great way to store this information. Information which changes. Information which must be retrieved
by many people and edited by many people. Information which sounds perfect for a wiki and perfect to be managed
within git.

===== A Simple Wireframe Review Tool

Let's build a simple tool which stores these types of changes. We'll build an image editor that hosts changes 
to UI mockups. This will give our executives a place where they can see changes and updates. This will allow
our UI designer a place to store their images and annotate them with vital information. And, we'll have a place
where developers can retrieve information without reviewing their email and wondering "Do I have the most
up-to-date mockups?" We'll buid a special interface which allows quickly editing and reviewing these files locally. 
And all of it can be published into GitHub for review (though we won't allow editing of the information there,
since GitHub has its own editing modality.)

Gollum is built on ruby and uses the grit library underneath. It is simplest to use Ruby to build this, so let's 
use Sinatra, a super simple web server framework for Ruby.

Again, this is a dual purpose repository. We can use it with gollum as
a standard wiki. And, we can use it with our application to enter data
in a more powerful way than gollum permits from its default interface.
The data will still be compatible with gollum and will be hosted on
GitHub.

To begin, initialize our repository.

[source,bash]
$ mkdir images
$ cd images
$ git init .
$ printf > "### Our home" > Home.md
$ git commit -m "Initial checking" -a

We've just created a wiki compatible with gollum. Let's see what it
looks like inside gollum. run the `gollum` command then open
`http://localhost:4567/` in your browser.

image::images/gollum-first-view.png[]

As you can see, this built a starting point for our gollum wiki.

Create our sinatra script called `image.rb`, and then we can install the necessary gems
and run our server application.

[source,ruby image.rb]
require 'sinatra'
require 'gollum-lib'
wiki = Gollum::Wiki.new(".")
get '/pages' do
  "All pages: \n" + wiki.pages.collect { |p| p.path }.join( "\n" )
end

[source,bash]
$ printf "source 'https://rubygems.org'\n\ngem 'sinatra'\ngem 'gollum-lib'" >> Gemfile
$ bundle install
$ ruby image.rb
$ open http://localhost:4567 # or whatever URL is reported from Sinatra

Once you open this in your browser, you'll see a report of the files
that exist in our Gollum wiki right now. We've only added one file,
the `Home.md` file.

Let's add to our server. We want to support uploading ZIP files into
our system that we will then unpack and add to our repository, as well
as adding a list of these files to our wiki. Modify our image.rb
script to look like this:

[source,ruby image.rb]
require 'sinatra'
require 'gollum-lib'
require 'tempfile'
require 'zip/zip'
wiki = Gollum::Wiki.new(".")
get '/' do
  render File.open( "index.html" )
end
post '/unpack' do
    zip = params[:zip][:tempfile]
    Zip::ZipFile.open( zip ) { |zipfile|
      zipfile.each do |f|
        puts "F: #{f.name}"
        # Extract files into our images directory                                                                                              filename = "images/" + ( f.name.gsub( /\s+/, '_' ).gsub( /^.*\/([^\/]*)$/, $1 ) )
        puts "Filename: #{filename}"
      end
    }
  }
  render json: { success: 'ok' }
end  

Without going into the specific syntax of this Ruby code, this server
script receives a POST request at the `/unpack` mount point and
retrieves a ZIP file from the parameters passed into the script. It
then opens the ZIP file (stored as a temp file on the server side),
iterates over each file in the ZIP, and writes them to the images
directory, stripping the file names down to a simple name without
subdirectories and converting whitespace to underscores. Pretty
advanced for ten lines of code, no?

Update the required gems using the following commands, and then re-run
our Sinatra server script.

[source,bash]
$ printf "gem 'rubyzip'\n" >> Gemfile
$ bundle install
$ ruby image.rb


