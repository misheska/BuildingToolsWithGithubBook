== Gollum

Wikis have revolutionized the way we create and digest
information. It turns out they are a great complement to technical
projects (code repositories) because they allow non-technical
users to contribute information without disturbing developers. Gollum
is GitHub's open source version of a wiki. Just as Git has
revolutionized collaborative editing of code, Gollum wikis layer the
benefits of Git onto a proven publishing workflow. The true power of
Gollum wikis reveal themselves when you see how tightly integrated
with GitHub they are. You can quickly build and associate a wiki with
any repository, and create a collaborative documentation system around
any repository hosted on GitHub. And, you can pull in information from
git repositories with ease, linking documentation with live code.

In this chapter we'll explore the basics of using Gollum, creating a
wiki on GitHub and then understanding how to edit it on GitHub, and as
a repository on our local machine. We will then create a Gollum wiki by
hand from the command line, and show the bare minimum set of files to
call something a Gollum repository. Finally, we will build a simple
image organization tool which allows us to edit a Gollum wiki in an
entirely different way, but still publishes information into GitHub as
a regular Gollum wiki, exploring a little bit of the internals of Git
along the way.

=== "The Story of Smeagol..."

Gollum wikis are simply an agreed upon file structure. At its most
basic form, a Gollum wiki is a git repository with a single file,
`Home.ext` (`ext` would be any of the supported wiki markup formats,
which we will talk about later). 

==== Repository Linked Wikis

Any repository on GitHub, public or private, can have an associated Gollum wiki.
To create a wiki linked to your repository, visit the repository
page and then look in the rightmost colum. You'll see an icon which
looks like a book, next to which will be the word "Wiki." 

image::images/gollum-wiki.png[Integrated Gollum Wiki in the Sidebar]

Clicking on this link will bring you to a page where you are asked to
create a wiki for the first time. GitHub will ask you to create the
"Home" page, which is the starting point in a Gollum wiki. GitHub will
automatically create a page template with the project name; you can
customize this information to suit your own needs. Clicking on the
"Save Page" will save your first page and create the wiki for you.

image::images/gollum-wiki-create.png[Starting a Gollum Wiki]

Your wiki is now as public as your repository is public. Public
repositories have public wikis, accessible to anyone. Private
repositories have private wikis, accessible only to those users or
organizations which have rights to edit the repository data. 

Wikis are powerful collaboration tools because they use a special
language which compiles into HTML. Let's review the options for Gollum
wikis.

==== Markup and Structure

Gollum files can be written in any of the supported "Github Markup" formats, which
includes ASCIIdoc, Creole, Markdown, Org Mode, Pod, RDoc,
ReStructuredText, Textile, and MediaWiki. The variety of markup
languages brings flexibility but it can be confusing to know which one
to use. Markdown (and its variant cousins) is the most popular markup
language on GitHub, and is well liked on other popular sites like
Stack Overflow. If you are unsure which language to use, Markdown is a
safe bet because it is ubiquitous across GitHub. The <<Jekyll>>
chapter has a much deeper overview of Markdown.

If you do choose Markdown, In addition to the standard vanilla
Markdown language tags, Gollum adds its own set wiki specific tags. There 
are often subtle (or conflicting) differences from other Wiki markup
so it is worth reviewing the
https://github.com/gollum/gollum/wiki:[Gollum repository documentation
page]. We'll go over the most important ones here.

===== Links 

Links obviously convert into the `<a>` HTML tag.

* Links use the syntax `[[Link]]`. 
* You can add a link title using the bar character:
  `[[http://foobar.com|A link to foobar]]`. 
* Links can be either external or internal links. 
* A link like `[[Review Images]]` will be converted to a relative link
  to the page `review-images.ext` (where ext is the preferred
  extension you are using with your wiki, most likely Markdown). 

Wikis are generally a collection of pages
linked together in myriad ways, and this assumption about the
structure of links makes writing pages easier. 

As we mentioned, there are differences between Gollum wiki tags and other wikis despite
having similar syntax. One such example is MediaWiki, where links with
titles use the opposite ordering `[[A link to
foobar|http://foobar.com]]`, so caveat emptor.

===== Code Snippets

Gollum (the wiki) was invented at GitHub, a company dedicated to
improving the lives of software developers, so it stands to reason
Gollum wikis would support insertion of code snippets. To include a snippet of
code, use three backticks, followed by the language name, and close
the block of code using three more backticks.

[source,ruby]
----
```ruby
def hello
  puts "hello"
end
```
----

A more interesting way of embedding code inside a Gollum repository is
to use the file include syntax. Again, use a triple backtick, followed
by the file type and then a reference to the code snippet inside a
GitHub repository. You'll need to include the branch as well.

[source,ruby]
------
```html:github:xrd/TeddyHyde/blob/master/Gemfile```
------

This will pull the file on GitHub located inside the "TeddyHyde" repository for
user "xrd" on the master branch named "Gemfile"  and publish it with
syntax hilighted into your wiki as if you had used this markup.

[source,ruby]
-------
```ruby
source 'https://rubygems.org'

gem "nokogiri"
gem "rspec"
gem 'calabash-android', 
  :git => 'git://github.com/calabash/calabash-android.git'
```
-------

Unfortunately, you cannot specify a specific SHA commit to retrieve
moments in history within the git repository, but this is still a
powerful way to expose a file inside a Gollum wiki. If you need to do
that, the best way might be to create a branch from a specific SHA
commit, and then reference that branch when including the file.

[source,bash]
$ git checkout 0be3e4475db2697b8
$ git checkout -b at_sha_0be3e4475db2697b8
$ echo "gem 'rails' # Adding rails to Gemfile" >> Gemfile
$ git commit -m "Added rails to Gemfile" -a
$ git push origin at_sha_0be3e4475db2697b8

This would generate a new branch based on an older commit, and push up
the branch. Then, you could reference this inside your wiki with the
following include

[source,ruby]
------
```html:github:xrd/TeddyHyde/blob/at_sha_0be3e4475db2697b8/Gemfile```
------

Note that we've referenced the branch named after the specific SHA
hash we want. 

===== Structural Components

Gollum includes capabilities to add sidebars, headers, and footers. If
you include a file called `_Sidebar.ext` inside your repository,
you'll see it as a sidebar for every file rendered. Sidebars are
automatically added to any file and any file from subdirectories that
do not have their own sidebar files. If you wanted to add sidebars
specific to a subdirectory, add another file in the subdirectory and
this file will override the top level sidebar file. 

===== No Styling or JavaScript

For security reasons, Gollum strips out all CSS and
JavaScript from raw markup files. You can include your own JavaScript
or CSS file when running Gollum locally using the `--custom-css` or
`--custom-js` switches, but there is no way to include these files on a
Wiki when your Gollum wiki is hosted on GitHub.

===== Inserting Images

Images are inserting into your document using the same tag format
`[[ceo.png]]`: this adds the correct HTML tags to include an image
named ceo.png inside your page. This basic syntax is often extended
for additional funtionality. For example, to add a frame
and an alt tag, you could use syntax like `[[ceo.png|frame|alt=Our CEO
relaxing on the beach]]`. This creates the proper HTML tags for the
same image, and also adds a frame and alt text (helpful for
better context and screenreaders). Review the documentation on the
Gollum repository for more details about the breadth of the image
options. 

You can also add images using the editor on GitHub. But, you'll notice
that either way you are adding a link to an image and that there is no
way to upload images into GitHub from the editor. 

image::images/gollum-image-url.png[No image upload, only image URLs]

For non-technical users, this makes Gollum Wikis on GitHub almost
unusable if they need to add images. Let's address this problem by
building our own customized image-centric Gollum editor that still
interoperates with regular Gollum Wikis. We can put this editor in
front of non-technical users allowing them to add images, and then
publish the wiki into GitHub as-is.

=== Hacking Gollum

On many software teams there is a tension between the design
team and the software team stemming from the fact that designers
generally don't like using source code tools to manage images. This
causes issues when software developers rely on designs that are
rapidly changing: coders quickly get out of sync with the latest
designs. As a wiki, Gollum is the perfect tool to bridge this gap
between designers and coders: wikis are easy to read and modify by
non-technical users. Since Gollum is a hackable Wiki, we can build our
own workflow tool that allows designers to manage images and coders to
easily see those changes in a source code repository. 

Gollum is built on Ruby and uses the Grit library underneath. Using
Ruby makes sense because we can leverage the existing Grit and Gollum
libraries. We'll also use Sinatra, the same web application library we
used in the last chapter.

[NOTE]
The `gollum` command is, in fact, a customized wrapper around Sinatra.

This will be a dual purpose repository. We can use the repository with
gollum as a standard wiki. And, we can use it with our application to
enter data in a more powerful way than gollum permits from its default
interface. The data will still be compatible with gollum and will be
hosted on GitHub.

To begin, install the Gollum ruby gem and then initialize our repository.

[source,bash]
$ gem install gollum
$ mkdir images
$ cd images
$ git init .
$ printf "### Our home" > Home.md
$ git add Home.md
$ git commit -m "Initial checking"

We've just created a wiki compatible with gollum. Let's see what it
looks like inside gollum. run the `gollum` command then open
`http://localhost:4567/` in your browser.

image::images/gollum-first-view.png[Gollum running locally]

As you can see, this tiny set of commands was enough to create the
basics of the gollum wiki structure.

[WARNING]
If you edit a Gollum wiki from the command line, be aware that Gollum
only looks inside the repository data for files. If you have added
something to the working directory or have not yet commited files in
your index, they will not be visible to Gollum. 

Now let's begin creating the web app that will help us store images
inside a Gollum wiki.

==== Our Gollum Editor Starting Point

Create our sinatra script called `image.rb`, and then we can install
the necessary gems and run our server application.

[source,ruby]
------
require 'sinatra'
require 'gollum-lib'
wiki = Gollum::Wiki.new(".")
get '/pages' do
  "All pages: \n" + wiki.pages.collect { |p| p.path }.join( "\n" )
end
------

Then, create the Gemfile.

[source,bash]
------
$ echo "source 'https://rubygems.org'
gem 'sinatra'
gem 'gollum-lib', '4.1.0'" >> Gemfile
$ bundle install
Fetching gem metadata from https://rubygems.org/..........
Resolving dependencies...
Installing charlock_holmes (0.7.3) 
Using diff-lcs (1.2.5) 
Installing github-markup (1.3.3) 
Using mime-types (1.25.1) 
...
$ bundle exec ruby image.rb
$ open http://localhost:4567/pages
------

We specify at least the minimum 4.1.0 for gollum-lib as the interface
and list of supporting libraries has changed. We then run within the
bundler context (using gems installed from this Gemfile rather than
system gems) using the `bundle exec ruby image.rb` command.

You'll see a report of the files that exist in our Gollum wiki right
now. We've only added one file, the `Home.md` file.

==== Programmatically Handling Images

Let's add to our server. We want to support uploading ZIP files into
our system that we will then unpack and add to our repository, as well
as adding a list of these files to our wiki. Modify our image.rb
script to look like this:

[source,ruby]
-----
[filename=".", language="ruby", sha="4570ee0:support/gollum/image.rb" lines="1..33"]
snippet~~~~~
To be replaced
snippet~~~~~
-----

We'll need an `index.html` file as well, so add that.

[source,ruby]
-----
[filename=".", language="ruby", sha="4570ee0:support/gollum/index.html"]
snippet~~~~~
To be replaced
snippet~~~~~
-----

This server script receives a POST request at the `/unpack` mount point and
retrieves a ZIP file from the parameters passed into the script. It
then opens the ZIP file (stored as a temp file on the server side),
iterates over each file in the ZIP, strips the full path from the
filename, and then prints out that filename (if it looks like an image)
to our console. Regardless of whether we are accessing the 
root of our server, or have just posted to the `/unpack` mount point,
we always need to render our index page. When we do render it after
unzipping, we replace a comment stored in the index file with a status
message indicating the script received the correct file we posted.

We need to add an additional ruby library to enable this application,
so update the required gems using the following commands, and then re-run
our Sinatra server script.

[source,bash]
$ printf "gem 'rubyzip'\n" >> Gemfile
$ bundle install
$ ruby image.rb

Then, we can open `http://localhost:4567/` and test uploading a file
full of images. You'll see output similar to this in your console
after uploading a file.

[source,bash]
----
...
[2014-05-07 10:08:49] INFO  WEBrick 1.3.1
[2014-05-07 10:08:49] INFO  ruby 2.0.0 (2013-05-14)
[x86_64-darwin13.0.0]
== Sinatra/1.4.5 has taken the stage on 4567 for development with
backup from WEBrick
[2014-05-07 10:08:49] INFO  WEBrick::HTTPServer#start: pid=46370
port=4567
Writing out: IMG1234.png
Writing out: IMG5678.png
Writing out: IMG5678.png
...
----

==== Leveraging the Rugged Library

Our end goal for this script is to add files to our Gollum wiki, which
means adding files to the repository which backs our Gollum wiki.
The Rugged library handles the grunt work of this type of task easily. 
Rugged is the successor to the original Ruby library for Git (called
Grit). Gollum, at the time of this writing uses the Grit libraries,
which also provide a binding to the libgit2 library, a "portable, pure
C implementation of the Git core methods." Grit has been abandoned
(though there are unofficial maintainers) and the Gollum team intends
to use Rugged as the long term library backing Gollum. Rugged 
is written in Ruby and, if you like Ruby, is a more elegant way to
interface with a Git repository than raw git commands. As you might
expect, Rugged is maintained by several employees of GitHub.

To change our script to modify our Git repository, modify the `puts`
statement inside the zip loop to call a new method called
`write_file_to_repo`. And, at the end of the zip block, add a method
called `build_commit` which builds the commit from our new files. Our
new file (omitting the unchanged code at the head of the file) looks
like this.

[source,ruby]
-----
[filename=".", language="ruby", sha="f737917:support/gollum/image.rb" lines="23..80"]
snippet~~~~~
To be replaced
snippet~~~~~
-----

As you can see from the code above, Rugged handles a lot of the grunt
work required when creating a commit inside a Git repository. Rugged has a
simple interface to creating a blob inside your Git repository
(`write`), adding files to the index (the `add` method), and
then has a simple and clean interface to build the tree object
(`write_tree`) and then build the commit (`Rugged::Commit.create`). 

To ease the burden of hard coding our commit credentials, we implement
a method called `get_credentials` that loads up your credentials from
a file located in your home directory called `.gitconfig`. You
probably have this if you have used Git for anything at all on your machine, but if this
file is missing, this method will fail. On my machine this file looks
like the following code snippet. The `get_credentials` method simply loads up this
file and parses it for the name and email address. If you wanted to
load the credentials using another method, or even hard code them, you
can just modify this method to suit your needs. The instance variables
`@email` and `@name` are then used in the `build_commit()` method.

[source,ini]
----
[user]
        name = Chris Dawson
        email = xrdawson@gmail.com
[credential]
        helper = cache --timeout=3600
...
----

Just to double check that everything worked properly, let's verify
that things are working correctly after uploading a ZIP file. Jumping
into a terminal window after uploading a new file, imagine running
these commands:

[source,bash]
----
$ git status
----

To our surprise, we will see something like this:

[source,bash]
-----
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

  deleted:    images/3190a7759f7f6688b5e08526301e14d115292a6e/IMG_20120825_164703.jpg
  deleted:    images/3190a7759f7f6688b5e08526301e14d115292a6e/IMG_20130704_151522.jpg
  deleted:    images/3190a7759f7f6688b5e08526301e14d115292a6e/IMG_20130704_174217.jpg

-----

We just added those files; why is Git reporting them as deleted?

To understand why this happens, remember that in Git there are three
places where files can reside: the working directory, the staging
area or index, and the repository itself. Your working directory is
the set of local files which you are working on. The `git status`
command describes itself as "show the working tree status." Rugged
operates on the repository itself, and our Rugged calls above operated
on the index and then built a commit. This is important to note
because our files will not exist in our working directory if we only
write them using the Rugged calls, and if we do this, we cannot
reference them inside our wiki page when we are running Gollum
locally. We'll fix this in the next section.

We've now added the files to our repository, but we have not exposed
these files inside our wiki. Let's modify our server script to write
out each file to a wiki page for review. As we mentioned in the
previous section, we need to make sure that we write the files to both
the working index and the repository (using the Rugged library `write`
call). Then we can generate a Review file which details all the images
uploaded.

==== Optimizing for Image Storage

If a designer uploads the same image twice, what happens? We might
assume that our code, as it writes these files to a different path on
disk inside the repository (the path is the parent SHA hash to make it
unique) and we could therefore be adding the same 
file multiple times, and creating a repository with wasted
space. However, the nature of git permits us to add the same file
multiple times without incurring any additional storage cost beyond
the first addition. When a file is added to git repository, a SHA hash
is generated from the file contents. For example, generating the SHA hash
from an empty file will always return the same SHA hash.footnote:[This is explained
beautifully in the blog
http://alblue.bandlem.com/2011/08/git-tip-of-week-objects.html.]

[source,bash]
-----
$ echo -en "blob 0\0" | shasum
e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
$ printf '' | git hash-object -w --stdin
e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
-----

Adding a zip file with a bunch of files where only one
or two differs from the prior zip file means that Git will properly
reference the same file multiple times. Unfortunately, GitHub does not provide
an interface for reviewing statistics of Wikis in the same way that
they do for regular repositories. We can, however, review our
repository size from within the local repository by running the
count-objects Git subcommand. As an example, I uploaded a ZIP file
with two images inside of it. I then use the 
count-objects command and see this:

[source,bash]
-------
$ git gc
...
$ git count-objects -v
count: 0
size: 0
in-pack: 11
packs: 1
size-pack: 2029
prune-packable: 0
garbage: 0
size-garbage: 0
	      -------

Inspecting the first ZIP file, I see these statistics about it.

[source,bash]
-----
$ unzip -l ~/Downloads/Photos\ \(4\).zip 
Archive:  /Users/xrdawson/Downloads/Photos (4).zip
  Length     Date   Time    Name
 --------    ----   ----    ----
  1189130  01-01-12 00:00   IMG_20130704_151522.jpg
   889061  01-01-12 00:00   IMG_20130704_174217.jpg
 --------                   -------
  2078191                   2 files
-----

I then use another ZIP file which has one additional file, with the
other two included files exactly identical.

[source,bash]
-----
unzip -l ~/Downloads/Photos\ \(5\).zip 
Archive:  /Users/xrdawson/Downloads/Photos (5).zip
  Length     Date   Time    Name
 --------    ----   ----    ----
  1189130  01-01-12 00:00   IMG_20130704_151522.jpg
   566713  01-01-12 00:00   IMG_20120825_164703.jpg
   889061  01-01-12 00:00   IMG_20130704_174217.jpg
 --------                   -------
  2644904                   3 files

-----

Then, I upload the second ZIP file. If I re-run the count-object
command (after running `git gc`, a command which packs files
efficiently and makes our output more human readable), I see this:

[source,bash]
----
$ git gc
...
$ git count-objects -v
count: 0
size: 0
in-pack: 17
packs: 1
size-pack: 2578
prune-packable: 0
garbage: 0
size-garbage: 0
----

Notice that our packed size has only changed by about half a MB, which
is the compressed size of the additional third file, but more
importantly, there was no impact from the other two files on our
repository size, even though they were added at different paths. 

If we upload the secondary file yet again, we will regenerate and
commit a new version of the `Review.md` file, but no new files will
need to be created inside our Git repository object store from the
images directory (even though their paths have changed), so our 
impact on the repository will be minimal.

[source,bash]
-----
$ git gc
...
$ git count-objects -v
count: 0
size: 0
in-pack: 21
packs: 1
size-pack: 2578
prune-packable: 0
garbage: 0
size-garbage: 0
-----

As you can see, our packed-size has barely changed, an indication that
the only changes were a new Git tree object and commit object. We
still do have the files located in our repository at a variety of
paths so our review pages will work no matter what revision we are accessing.

[source,bash]
-----
$ find images
images
images/7507409915d00ad33d03c78af0a4004797eec4b4
images/7507409915d00ad33d03c78af0a4004797eec4b4/IMG_20120825_164703.jpg
images/7507409915d00ad33d03c78af0a4004797eec4b4/IMG_20130704_151522.jpg
images/7507409915d00ad33d03c78af0a4004797eec4b4/IMG_20130704_174217.jpg
images/7f9505a4bafe8c8f654e22ea3fd4dab8b4075f75
images/7f9505a4bafe8c8f654e22ea3fd4dab8b4075f75/IMG_20120825_164703.jpg
images/7f9505a4bafe8c8f654e22ea3fd4dab8b4075f75/IMG_20130704_151522.jpg
images/7f9505a4bafe8c8f654e22ea3fd4dab8b4075f75/IMG_20130704_174217.jpg
images/b4be28e5b24bfa46c4942d756a3a07efd24bc234
images/b4be28e5b24bfa46c4942d756a3a07efd24bc234/IMG_20130704_151522.jpg
images/b4be28e5b24bfa46c4942d756a3a07efd24bc234/IMG_20130704_174217.jpg
-----

Git and Gollum can efficiently store the same file at different paths
without overloading the repository.

==== Reviewing on GitHub

The raison d'etre for this wiki is to annotate a development project.
If you follow the instructions above and create a new wiki for a
repository, you'll then be able to push up the changes we've made
using our `image.rb` script. Once you have created a new wiki, look
for a box on the right which says "Clone this wiki locally". 

image::images/gollum-local-clone-url.png[Gollum git clone URL]

Copy that link, and then enter a terminal window where we can then add a remote
URL to our local repository which allows us to synchronize our
repositories and publish our images into GitHub. Gollum wikis have a
simple URL structure based on the original clone URL: just add the
word `.wiki` to the end of the clone URL (but before the final `.git`
extension). So, if our original clone URL of the repository is
`git@github.com:xrd/webiphany.com.git` our clone URL for the
associated wiki will be `git@github.com:xrd/webiphany.com.wiki.git`.
Once we have the URL, we can add it as a remote to our local
repository using the following commands.

[source,bash]
-----
$ git remote add origin git@github.com:xrd/webiphany.com.wiki.git
$ git pull # This will require us to merge the changes...
$ git push
-----

When we pull, we will be asked to merge our changes since GitHub
created a `Home.md` file which did not exist in our local repository.
We can just accept the merge as-is. The `git push` publishes our
changes. If we then visit the wiki, we'll see an additional file
listed under the pages sidebar to the right. Clicking on the review
page, we can see the images we've added most recently.

image::images/gollum-android-project1-review.png[Images displayed within a Gollum wiki]

Not sure why our designer is providing us with an image of a couch,
but I am sure he has his reasons.

Once have published the file, we can click on the "Review" link in the
sidebar to see the most current version of the "Review" page. We also
can review the revisions of this file by clicking on the "3 Commits"
(or whatever number of commits have occurred with this file).
link right underneath the page title. Jumping onto that page shows us
the full history of this file.

image::images/gollum-android-project1-revisions.png[A view on the revisions from within GitHub]

Clicking on any of the SHA hashes will display the page at that
revision in our history and show us the state of the document at any given
moment in history. Unfortunately, jumping back and forth between
revisions requires two clicks, one from the review page to the list of
revisions, and then another click to jump into the revision we want,
but this permits us to review changes between the comps provided from
our designer. 

It would be nice if GitHub provided a simple way to jump
from a revision to the parent (older) revision, but they don't expose
this in their site as of this writing. We can fix this, however, by generating
our own special link inside the review page itself which will
magically know about how to navigate to a previous version of the page.

==== Improving Revision Navigation

In our example, we only have three revisions right now, and all share the same commit
message ("Adding new images"). This is not very descriptive and makes
it challenging to understand the differences between revisions,
critical when we are trying to understand how things have changed
between comps. We can improve this easily.

First, let's add a commit message field to our upload form.

[source,html]
-----
[filename=".", language="html", sha="fb361b5:support/gollum/index.html"]
snippet~~~~~
To be replaced
snippet~~~~~
-----

Then, let's adjust the commit message inside our `image.rb` script,
which is a one line change to the options hash, setting the value of
it to the parameter we are now passing in for "commit".

[source,ruby]
-----
  ...
[filename=".", language="ruby", sha="f448f60:support/gollum/image.rb", lines="64..66"]
snippet~~~~~
To be replaced
snippet~~~~~
  ...
-----

Now, if our designer posts a new version of the UI comps, they can
specify what changes were made, and we have a record of that in our
change log, exposed on the revisions section of our wiki hosted on GitHub.

#### Fixing Linking Between Comp Pages

We noted that there is no quick way to jump between comps once we are
inside a review revision. However, if you recall we used the parent
SHA hash to build out our image links. We can use this to build out a
navigation inside our comp page when we are on a revision page while
viewing the history.

Again, it is a simple change: one line within the `write_review_file`
method. After the block which creates each link to the image files,
add a line which builds a link to the parent document
via its SHA hash using the parent SHA found in our Rugged object under
`@repo.head.target`. This link will allow us to navigate to prior
revisions in our history.

[source,ruby]
-----
  ...
[filename=".", language="ruby", sha="8ea804c:support/gollum/image.rb", lines="44..50"]
snippet~~~~~
To be replaced
snippet~~~~~
  ...
-----

Now, when we view the Review file history, we see a file with a link
at the bottom to the link to each prior version. Is it possible to
provide a link to the next version in our history? Unfortunately, we
have no way to predict the SHA hash of the next commit made to the
repository, so we cannot build this link inside our `Review.md` file
with our ruby script. However, we do get something just as good for
free because we can simply use the back button to jump back to the
prior page in the history stack of our browser. It would be nice if we
could generate this link alongside the link we placed into the wiki
markup, and we could do this using a link that runs an onclick handler
delegating to a JavaScript command like
`window.history.back()`, but Gollum foils us again by
stripping JavaScript from our markup files as we noted before. This is a good thing
generally, as we don't want to permit rogue markup inside our wiki
pages, but it does limit our options in this situation.

Unfortunately, these links do not work when you are viewing the review file itself
(clicking on them brings you to a page which asks you to create this
as a new page). Gollum, unlike Jekyll, does not support Liquid
tags which would permit building a link using the username and
repository. Right now we don't have access to these variables, so our
link needs to be relative, which works when we are in history review,
but not in the normal review. It does not affect viewing the files so
this would require educating your stakeholders on the limitations of
this link.

=== Summary

In this chapter we learned how to create a Gollum wiki from
scratch, both on GitHub and as a fresh repository from the comman
line. We then looked at the different ways to use the `gollum` command
line tool and learned why this is a nice option when we want to run
our own Gollum server. Finally, we built a customized Gollum
image-centric editor using the Rugged library for Ruby.

In the next chapter we'll switch gears completely, and build a GUI
application for searching GitHub issues. And we'll do it in Python.
