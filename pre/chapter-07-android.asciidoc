== Android and the Git Data API

You might not use your phone right now as a developer tool, but the
odds are that you will soon. At the moment, phones and tablets can be
great for reading code, but the editors we developers use on our
laptops have not yet been reimagined for mobile devices. We are
getting close though: the GitHub API is accessible through the well
written EGit client library for Java, and this library supports both reading
data stored on GitHub and writing data back into it. These are a
perfect set of building blocks to develop applications for the Android
platform, currently the world's most popular mobile OS.

In this chapter, we'll use the Java EGit libraries to develop a small 
Android application which posts to our blog hosted on GitHub. Our
blogging application will allow us to login to GitHub, and then ask us
for a quick note describing how we are feeling. The application will
then compose a Jekyll blog post for us and push the post into our blog
on GitHub.  

=== Setting Up

To build this application, we need to create a Jekyll blog and then
install the necessary Android build tools. 

==== Creating a Jekyll blog

We are writing an application which adds jekyll blog entries, and we
are writing tests to verify our application works as advertisted, so
we need a sandbox blog against which we can run commands. There are
various ways to create a new Jekyll blog. The simplest is to run a
series of Ruby commands documented here; if you want to know more
about Jekyll, it is covered in more depth in the Jekyll chapter.
There are a few items of note when establishing a Jekyll blog that
have some complexity, things like mapping a hostname properly and using the
correct branch inside git. For our purposes here, however, we won't need
to make sure all that is established. All we need is to make sure that
we have a sandbox repository that has the structure of a jekyll blog.

[source,bash]
-----
$ printf "source 'https://rubygems.org'\n\ngem 'github-pages'\ngem 'hub'" >> Gemfile
$ export BLOG_NAME=mytestblog
$ bundle
$ jekyll new $BLOG_NAME
$ cd $BLOG_NAME
$ hub create
$ git push -u origin master
-----

These commands install the correct libraries for using Jekyll (and one
for our tests as well), generate a new blog using the jekyll command
line tool, and then create a blog on GitHub with those files. On the
second line we specify the name of the blog; you are welcome to change
this to any name you'd like, just make sure the tests match the name.

[WARNING]
When you have finished running these commands, you should close the
terminal window. There are other commands later in this chapter which
should occur in a fresh directory and as such it is best not to run
those commands from within the same directory where you created your
jekyll blog. You've pushed all those files into GitHub, so you could
safely delete the local repository in this directory.

==== Android Development Tools

If you don't have a physical Android device, don't fret. You can follow
along with this chapter without having an actual Android device by doing
development and testing on a virtual device. 

===== Installing the Java SDK

Unfortunately there is no simple shell command to install Java in the
same way as there is for Ruby and NodeJS using RVM or NVM. 
Oracle controls the Java language and distribution of official SDKs,
and they restrict access to downloads other than from java.oracle.com.
Java is freely available, but you need to visit java.oracle.com and
find the correct download for your needs. Android works with the 1.7
versions of Java or better.

===== Installing Android Studio

We will use Android Studio, the Google IDE for developing Android
applications. To install it, go to
https://developer.android.com/sdk/index.html and you will see a
download button for your platform (OSX, Linux and Windows
supported). Android Studio bundles all the important tools for
building Android applications.

=== Creating a New Project

Let's now create our Android project. When you first open Android
Studio, you will see an option in the right pane inviting you to
create a new project. Click on the "Start a new Android Studio
project" option. In the next step, you will see a screen for
configuring your new project. Enter in GhRU ("GitHub R U?") into the
Application Name and use `example.com` as the Company Domain (or use
your own domain, but be aware this will make the directory structure
presented in this chapter different than yours). Android Studio should
automatically generate the "package name" for you as
`com.example.ghru`. 

You will then need to choose a target SDK. The higher the target,
the better access to newer Android APIs, but the fewer number of
devices which can run the application. The code in this chapter will
work with older SDKs, so let's make a balanced choice and use Android
4.4 (KitKat) running on phone and tablets. At the moment this means,
according to Android Studio, that our application will run on 49.5% of
Android devices in the world.  

[[choose-android-sdk]]
.Choose an Android SDK
image::images/android-target-devices.png[Choose an Android SDK]

You will then be presented with a choice of activities. Choose "Blank
Activity". You will be taken to a screen which allows you to customize
the activity. Accept the defaults of "MainActivity" as the Activity
Name and the associated files for the layout, title and menu resource
name. Then click the "Finish" button to generate the project.

After completing these steps, Android Studio will create gradle
configuration files and generate the structure of your
application. Once this has completed, you can review the file tree of
your project by clicking on the left hand vertical tab labeled
"Project".

[[reviewing-android-project-structure]]
.Reviewing the Android project structure for the first time]
image::images/android-project-structure.png[Reviewing the Android project structure for the first time]

If you have never seen an Android project before, this screen deserves
some explanation. The "app" directory contains your application code and
resources (layout files, images, and strings). Inside the "app"
directory you will see several other directories: The "java" directory
contains, quite obviously, any java code for the project, which
includes the application files, and also programs which do not reside
in the app when it is published to the app store but perform testing
on the app. The "res" directory contains the resources as we
mentioned. Android Studio lists all build files under the "Gradle
Scripts" section, and groups them regardless of their directory
placement. You can see two "build.gradle" files, the first of which
you can generally ignore, though the second we will need to adjust.

Now we are ready to start editing our project.

==== Editing the Gradle Build File

First, we need to add to our Gradle build file and specify the
dependent libraries. Gradle is a build system for Java and has become
the offical build system for the Android platform. Open the
`build.gradle` within the `app` module (the second of the two
`build.gradle` files). 

[source,groovy]
-----
[filename="../GhRu2", language="groovy", sha="b2b6a80:app/build.gradle", callouts="1,4,13,24,28,30", callouts_prefix=" // "]
snippet~~~~~
To be replaced
snippet~~~~~
-----

<1> First, we load the Android gradle plugin. This extends our project
to allow an `android` block, which we specify next.
<4> Next, we configure our Android block, with things like the target
version (which we choose when setting up our project) and the actual
SDK which we are using to compile the application.
<2> In order to run UI tests, we need to specify a test runner
called the `AndroidJUnitRunner`
<1> Android Studio automatically adds a configuration to our build
file which loads any JARS (Java libraries) from the `lib`
directory. We also install the support compatibility library for older
Android devices, and most importantly, the EGit library which manages
connections to GitHub for us. The commons codec library from the
Apache Foundation proides tools that help to encode content into
Base64, one of the options for storing data inside a GitHub repository
using the API.
<1> Next we install libraries which are only used when we run unit
tests. `testCompile` libraries are compiled only when the code is run
on the local development machine, and for this situation we need the
JUnit library, and the OkHttp library from Square which helps us
validate that our request for a new commit has made it all the way
into the GitHub API.
<1> Lastly, we install the espresso libraries, the Google UI testing
framework. The first line (of the three libraries) installs the test
runner which we configured above. We use `androidTestCompile` which
compiles against these libraries when the code runs on Android in test
mode. 

===== Creating AVDs for Development

Android Studio makes creating AVD (Android Virtual Devices) simple. To
start, under the "Tools" menu, click on "Android" and then select
"AVD Manager". To create a new AVD, click on the "Create Virtual
Device.." button and follow the prompts. You are generally free to
choose whatever settings you like. Google produces a real device
called the Nexus 5. This is the Android reference device, and is a
good option for a generic device with good support across all
features. You can choose this one if you are confused about which to
use.

[[creating-new-avd]]
.Creating a new AVD
image::images/android-studio-new-avd.png[Creating a new AVD]

Once you have created an AVD, start it up. It will take a few minutes
to boot; AVDs emulate the chipset in software and
booting up can take a few minutes, unfortunately. There are
alternative tools that speed up AVD boot time (Genymotion is one of
those), but there are complexities if you stray away from the stock
Android tools, so we will stick with AVD. 

==== Default Android Main

When we use the above commands to create a new android application, it
creates a sample entry point which is the starting point of our
Android application. All Android applications have a file called
`AndroidManifest.xml` which specifies this activity and also supplies
a list of permissions to the apps. Open the `AndroidManifest.xml` file
from within the `app/src/main` directory. We need to make one change, to
add a line which specifies that this app will use the Internet
permission (required if our app will be talking to the GitHub
API). Note that when viewing this file inside Android Studio the IDE
can interpolate strings from resources, so you might see the
`android:label` attribute displayed as "GhRU" with a grey tinge, when
in fact the XML file itself has the value displayed below (`@string/app_name`).

[source,java]
-----
[filename="../GhRu2", language="java", sha="0f68b1f4a0fd6c:app/src/main/AndroidManifest.xml"]
snippet~~~~~
To be replaced
snippet~~~~~
-----

When the application is launched, the Android OS will launch this
activity and then call the `onCreate` function for us. Inside this
function, our application calls our parent's implementation of
`onCreate`, and then inflates the layout for our application. Layouts
are XML files in which the UI of an Android application is
declaratively described.

Android Studio created a default layout for us (called
`activity_main.xml`), but let's ignore that and create our own
layout. To do so, right click (control-click on OSX) on the `layouts`
directory, and then choose "New" and then "Layout resource file" at
the very top of the list (Android Studio nicely chooses the most
likely candidate given the context of the click). Enter "main.xml" as
the file name, and accept the other default.s

This application requires that we login, so we know we at least need a field and a
descriptive label for the username, a password field (and associated
descriptive label) for the password, a button to click that tells our
app to attempt to login, and a status field which indicates success or
failure of the login. So, let's modify the generated `main.xml` to
specify this user interface. To edit this file as text, click on the
tab labeled "Text" next to the tab labeled "Design" at the very bottom
of the `main.xml` pane to switch to text view. Then, edit the file to
look like the following.

[source,java]
-----
[filename="../GhRu2", language="java", sha="3442280:app/src/main/res/layout/main.xml", callouts="1,6,29,36", , callouts_wrap=" <!-- {x} -->"]
snippet~~~~~
To be replaced
snippet~~~~~
-----

You may have complicated feelings about XML files (I know I do), but
the Android layout XML files are a straightforward way to design
layouts declaratively, and there is a great ecosystem of GUI tools
that provide sophisticated ways to manage them. Scanning this XML
file, it should be relatively straightforward to understand what is
happening here.

<1> The entire layout is wrapped in a `LinearLayout` which simply
  positions each element stacked vertically inside it. We set the 
  height and width layout attributes to `match_parent` which means this
  layout occupies the entire space of the screen.
<2> We then add the elements we described above: pairs of `TextView`
  and `EditView` for the label and entry options necessary for the
  username and password. 
<3> The password field customizes the type to be a password field,
  which means the entry is hidden when we enter it. 
<4> Some elements in the XML have an ID attribute, which allows us to
  access the items within our Java code, such as when we need to assign
  a handler to a button or retrieve text entered by the user from an
  entry field. We will demonstrate this in a moment.

You can review the visual structure of this XML file by clicking in
the "Design" tab to switch back to design mode.

We also need a layout once we have logged in. Create a file called
`logged_in.xml` using the same set of steps. Once
logged in, the user is presented with a layout asking them to choose
which repository to save into, asks them to enter their blog post into
a large text field and then click a button to submit that blog
post. We also leave an empty status box beneath the button to 
provide context while saving the post.

[source,java]
-----
[filename="../GhRu2", language="java", sha="3442280:app/src/main/res/layout/logged_in.xml"]
snippet~~~~~
To be replaced
snippet~~~~~
-----

Most of this should be familiar once you have reviewed the `main.xml`
file (and be sure to copy this from the associated sample repository
on GitHub if you don't want to copy it in yourself).

Now that we have our XML established, we can ready our application for
testing.

=== Android Automated Testing

Android supports three types of tests: unit tests, integration tests,
and user interface (UI) tests. Unit tests validate very tightly
defined and isolated pieces of code, while integration tests and UI tests test
larger pieces of the whole. On Android, integration tests generally
mean instantiation of data managers or code that interacts with
multiple components inside the app, while UI testing permits testing
of user facing elements like buttons or text fields.
In this chapter we will create a unit test and UI test. 

One important note: Unit tests run on your development machine, not the Android 
device itself. UI tests run on the Android device (or emulator). There
can be subtle differences between the Java interpreter running on your development
machine and the Dalvik interpreter running on your Android device, so
it is worthwhile to use a mixture of the three types of tests. Stated
another way, write at least one test which runs on the device or
emulator itself!

==== Unit Tests for our GitHub Client

Let's start by defining a unit test. Since the unit test runs on our
development machine, our test and implementation code should be
written such that they not need to load any Android classes. This
forces us to constrain functionality to only the GitHub API. We will
define a helper class which will handle all the interaction with the
GitHub API but does not know about Android whatsoever. Then, we can
write a test harness that takes that class, instantiates it and
validates our calls to GitHub produce the right results.

[NOTE]
You might legitimately ask: is a unit test the right place to verify
an API call? Will this type of test be fast, given that slow running
unit tests are quickly ignored by software developers? Would it be
better to mock out the response data inside our unit tests? These are
all good questions! 

To setup unit tests, we need to switch the build variant to unit
tests. Look for a vertical tab on the left hand side of Android
Studio. Click on this, and then where it says "Test Artifact" switch
to "Unit Tests." From the project view (click on the "Project" vertical tab if
project view is not already selected) you can expand the "java"
directory, and you should then see a directory with "(test)" in
parentheses indicating this is where tests go. If this directory is
not there, create a directory using the command line (this command
would work `mkdir -p app/src/test/java/com/example/ghru`).

Then, create a test file called `GitHubHelperTest.java` that looks like the following.

[source,java]
-----
[filename="../GhRu2", language="java", sha="4dfcd18:app/src/test/java/com/example/ghru/GitHubHelperTest.java", callouts="3,7,16,20,26,28,34,36,45", callouts_prefix=" // "]
snippet~~~~~
To be replaced
snippet~~~~~
-----

<1> First, we import the OkHttp library, a library for making HTTP
calls. We will verify that our GitHub API calls made it all the way into
GitHub by looking at the event log for our repository, a log
accessible via HTTP.
<2> Next, we import JUnit, which provides us with an annotation
`@Test` we can use to indicate to a test runner that certain methods
are test functions (and should be executed as tests when in test mode).
<3> We create a class called `GitHubHelperTest`. In it, we define a
sole test case `testClient`. We use the `@Test` annotation to indicate
to JUnit that this is a test case.
<4> Now we specify our login information and the repository we want to
test against. In order to keep the password out of our source code, we
use an environment variable which we can specify when we run the
tests.
<6> Next we build a random string. This unique string will be our
commit message, a beacon that allows us to verify our commit made it
all the way through and was stored on GitHub, and differentiate from
other commits made recently by other tests.
<7> Now, to the meat of the test: we instantiate our GitHub helper class
with login credentials, then use the `SaveFile` function to save the
file. The last parameter is our commit message, which we will verify
later.
<7> There can be times when the GitHub API has registered the commit
but the event is not yet displayed in results coming back from the
API; sleeping for a few seconds fixes this.
<7> Next we go through the steps to make an HTTP call with the OkHttp
library. We load a URL which provides us with the events for a
specified repository, events which will have the commit message when
it is a push type event. This repository happens to be public so we
don't require authentication against the GitHub API to see this data.
<8> Once we have the body of the HTTP call, we can scan it to verify
the commit message is there. 

The final steps deserve a bit more investigation. If we load the event
URL from cURL, we see data like this.

[source,bash]
-----
$ curl https://api.github.com/repos/burningonup/burningonup.github.io/events
[
  {
    "id": "3244787408",
    "type": "PushEvent",
    ...
    "repo": {
      "id": 44361330,
      "name": "BurningOnUp/BurningOnUp.github.io",
      "url":
      "https://api.github.com/repos/BurningOnUp/BurningOnUp.github.io"
    },
    "payload": {
      ...
      "commits": [
        {
          "sha": "28f247973e73e3128737cab33e1000a7c281ff4b",
          "author": {
            "email": "unknown@example.com",
            "name": "Unknown"
          },
          "message": "207925 Thu Oct 15 23:06:09 PDT 2015",
          "distinct": true,
          "url":
	  "https://api.github.com/repos/BurningOnUp/BurningOnUp.github.io/commits/28f247973e73e3128737cab33e1000a7c281ff4b"
        }
      ]
    }
...
]
-----

This is obviously JSON. We see the type is "PushEvent" for this event,
and it has a commit message which matches our random string format. We
could reconstitute this into a complex object structure, but scanning
the JSON as a string works for our test.

==== Android UI Tests

Let's now write a UI test. Our test will start our app, find the
username and password fields, enter in the proper username and
password text, then click the login button, and finally verify that we
have logged in by checking for the text "Logged into GitHub" in our
UI.

Android uses the Espresso framework to support UI testing. We
already installed Espresso with our Gradle configuration, so we can
now write a test. Tests are written by deriving from a generic test
base class (`ActivityInstrumentationTestCase2`). Any public function
defined inside the test class is run as a test.

In Android Studio, from the "Build Variant" window, select "Android
Instrumentation Test" which will then display a test directory called
"androidTest". These are tests which will run on the emulator or
actual device. Inside the directory, make a new file called
`MainActivityTest.java`. 

[source,java]
-----
[filename="../GhRu2", language="java", sha="4dfcd18:app/src/androidTest/java/com/example/ghru/MainActivityTest.java", callouts="3,10,14,17,18,20,22,23,30", callouts_prefix=" // //"]
snippet~~~~~
To be replaced
snippet~~~~~
-----

<2> We import the instrumentation registry (for instrumenting the
tests of our app), the base class, and matchers which will be used to
make assertions in our tests.
<3> We create a test class which derives from the
`ActivityInstrumentationTestCase2` generic. 
<4> The constructor of an Espresso tests implementation needs to call
the parent constructor with the class of the Activity for test, in
this case `MainActivity`. 
<5> Our test verifies that we can login to GitHub, so we name it accordingly.
<5> We then load the instrumentation registry, and also call
`getActivity`, which actually instantiates and starts the activity. In
many espresso tests these two steps will occur in a function annotated as
a `@Before` function if they are used across multiple tests (in which
case they will be run before each test). Here to simplify our function
count we can call them inside the single test function.
<8> It is never a good idea to store credentials inside of a code
repository, so we retrieve the username and  password from a resource
XML file using the `getString` function available using the
activity. We will show what the contents of this secret file could
look like presently.
<6> Once we have the username, we can enter it in the text field in
our UI. With the `onView` function we can interact with a view (for
example: a button or text field). `withId` finds the view using the
resource identifier inside the XML layout files. Once we have the
view, we can then perform an action (using the `perform` function)
like typing in text. This chain of calls enters the GitHub username
into the first text field.
<9> We then complete our interaction with the UI, entering in the
password and then clicking the login button.
<10> If all is successful, we should see the text "Logged into
GitHub". Under the hood, this test will verify that we are logged into
GitHub and display the successful result. 

To provide a username and password to our test and to keep these
credentials out of our source code, create a file called `secrets.xml`
inside our `strings` directory inside the resource folder. This file
should look like this. 

[source,java]
-----
[filename="../GhRu2", language="java", sha="4dfcd18:secrets.xml.sample"]
snippet~~~~~
To be replaced
snippet~~~~~
-----

Make sure this is not checked into your source code by
adding an exception to `.gitignore` (The command `echo
"secrets.xml" >> .gitgnore` is a quick way to add this to your .gitignore file).

Our tests will not even compile yet because we have not yet written the
other parts of the application. As such, we will skip the setup
required to run our tests within Android Studio for now.

Let's now build the application itself to pass these tests.

=== Application Implementation

Now we can start writing some Java code for our application. Let's
make it so our `MainActivity` class will inflate the layouts we
defined earlier. 

[source,java]
-----
[filename="../GhRu2", language="java", sha="25288cbf57ae28085b:app/src/main/java/com/example/ghru/MainActivity.java", callouts="21,23,30,34,41", callouts_prefix=" // //"]
snippet~~~~~
To be replaced
snippet~~~~~
-----

This code mocks out the functionality we will be building and shows us
exactly what the UI will look like once that code is completed.

<1> We register a click handler for our login button.
<2> When the login button is clicked, we call the `login()` function which triggers a login flow.
<3> Once we have logged in, we inflate the logged in layout, suitable
for making a blog post.
<4> We then setup another click handler for the submit button; when
clicked, we call the `doPost()` function.
<5> Our `doPost()` function updates the status message at the bottom
of our application.

Even though our code is not functionally complete, this application will
compile. This is a good time to play with this application and verify
the UI looks appropriate. Our login form looks like this:

[[simple-ui-blog-posts]]
.A simple UI for making blog post entries
image::images/android-log-in.png[A simple UI for making blog post entries]

==== Code to Login to GitHub

Now we can wire in the GitHub API. Let's first work on the `login()`
function. Poking into the
https://github.com/eclipse/egit-github/tree/master/org.eclipse.egit.github.core[EGit
libary reference], we can write GitHub login code that is as simple as
the following.  

[source,java]
-----
GitHubClient client = new GitHubClient();
client.setCredentials("us3r", "passw0rd");
-----

The context in which the code runs makes as much a difference as the
code. The Android OS disallows any code from making network
connections unless it runs inside a background thread.
If you are not a Java developer already, and the thought of using
threads with Java sounds daunting, dispell your worries. The 
Android SDK provides a great class for managing background tasks
called `AsyncTask`. This class provides several entry points into the
lifecycle of a thread that is managed by the Android OS. We implement
a class and then overriding two functions provided by AsyncTask: the
first function is `doInBackground()` which handles operations off the
main thread (our background thread code), and the second function is
`onPostExecute()` which runs on the UI thread and allows us to update
the UI with the results of the code that ran inside `doInBackground()`.

Before we implement the login, we need to update our `onCreate`
function of the `MainActivity`. Our login button handles logging in,
so let's register a click handler on the login button that will call
the login task we will define inside our class based off AsyncTask.

[source,java]
-----
...
[filename=".", language="java", sha="dce3035bb1a21c04b:support/android/ghru/src/com/githubru/MainActivity.java", lines="20..38", callouts="13,15,16", callouts_prefix=" // //"]
snippet~~~~~
To be replaced
snippet~~~~~
...
-----

<1> We retrieve the username and password from our UI elements. 
<2> Our UI should notify the user that a login is occurring in a
background task, so we grab the status text element and update the text in it. 
<2> We then start the background thread process to do our login. This
syntax creates a new thread for us with the username and password as
parameters. Android will manage the lifecycle of this thread for us,
including starting the new thread separate from the main UI thread.

Now we can implement `LoginTask`. 

[source,java]
-----
...
[filename=".", language="java", sha="dce3035bb1a21c04b:support/android/ghru/src/com/githubru/MainActivity.java", lines="52..76", callouts="1,3,8,18,20,", callouts_prefix=" // //"]
snippet~~~~~
To be replaced
snippet~~~~~
...
-----

<2> Here we define our class derived from AsyncTask. The three types
in the generics signature provide a way to parameterize our
instantiated task; we need to provide a username and password to the
background task, and the first type in the signature allows us to pass
an array of Strings. You can see in the actual function definition
that the ellipsis notation provides a way to parameterize a function
with a variable number of arguments (called varargs). Inside our
defined function we expect we will send two Strings in, and we make
sure to do that in our call. 
<5> Once inside the `doInBackground()` function, we instantiate a
`UserService` class, a wrapper around the GitHub API which interacts 
with the user service API call. In order to access this information,
we have to retrieve the client for this service call and provide the
client with the username and password credentials. This is the syntax
to do that.
<6> We wrap the call to `getUser()` in a try block as the function
signature can throw an error (if the network were down, for example).
We don't really need to retrieve information about the user using the
User object, but this call verifies that our username and password are
correct and we store the result of the call in our return value.
GitHub will not use the credentials you set until you make an API
call, so we need to use our credentials to access something in order
to verify those credentials work.
<7> Let's call our function `loggedIn()` instead of `login()` to more
accurately reflect the fact that when we call this, we are already
logged into GitHub. 
<8> If our login was a failure, either because of network failure, or
because our credentials were incorrect, we indicate this in the status
message. A user can retry if they wish.

`loggedIn` updates the UI once logging in has completed and then initiates
the post on GitHub. 

[source,java]
-----
...
[filename="../GhRu2", language="java", sha="a359323a346a5bbda49:app/src/main/java/com/example/ghru/MainActivity.java", lines="40..63", callouts="3,6,12,21", callouts_prefix=" // //"]
snippet~~~~~
To be replaced
snippet~~~~~
...
-----

<1> Inflate the logged in layout to reflect the fact we are now logged
in.
<2> Then, install a click handler on the submit button so that when we
submit our post information, we can start the process to create the
post on GitHub. 
<3> We need to gather up three details which the user provides: the
post body, the post title, and the repository name. 
<4> Using these three pieces of data, we can then call into `doPost`
and initiate the asynchronous task.

Building out `doPost()` should be more familiar now that we have
experience with AsyncTask. `doPost()` makes the commit inside of
GitHub, and it performs network activity it needs to run on a
background thread.

[source,java]
-----
...
[filename="../GhRu2", language="java", sha="8d8c385:app/src/main/java/com/example/ghru/MainActivity.java", lines="113..156", callouts="8,15,16,18,19,28", callouts_prefix=" // //"]
snippet~~~~~
To be replaced
snippet~~~~~
...
-----

<1> First, we retrieve the parameters we need to send off to the
GitHub API. Notice that we don't attempt to retrieve these from the
UI. Background threads don't have access to the Android UI functions. 
<2> This function returns a true or false value indicating success or
failure (using the variable `rv` for "return value"). We assume that
it fails unless everything we need to do inside our function works
exactly as expected, so set the expectation to false to start. The
value of our return statement is passed to the next stage in the
lifecycle of the thread, a function called `onPostExecute` (an
optional stage in the thread lifecycle that we will use to report 
status of the operation back to the user).
<2> Now, we instantiate the `GitHubHelper` class. This instantiation
and usage should look very familiar as it is the same thing we did
inside our unit test.
<3> Our helper class returns success or failure. If we have reached
this point, this is our final return value.
<3> We will wrap the call to `SaveFile` inside a try/catch block to
make sure we handle errors; these will most likely be network errors.
<4> `onPostExecute()` is the function we (optionally) return to once
our background task has completed. It receives the return value from
our previous function. If we have a true value returned from
`doInBackground()` then our save file succeeded and we can update the
UI of our application.

We need to import the support classes. The JARs and classes for EGit
have already been added to our project automatically using
gradle. Make sure you add these `import` statements to the top of the
file, under the other imports. 

[source,java]
-----
...
[filename=".", language="java", sha="467c40dc8d:support/android/ghru/src/com/githubru/MainActivity.java" lines="9..13"]
snippet~~~~~
To be replaced
snippet~~~~~
...
-----

Now we are ready to write the code to write data into GitHub.

==== Code to talk to GitHub

Our last step is to write the code which handles putting content into GitHub.
This is not a simple function, because the GitHub API requires you
build out the structure used internally by Git. A great reference for learning more about
this structure is the free and open source book called "Pro Git" and
specifically the last chapter called
http://git-scm.com/book/en/Git-Internals[Git Internals]. 

In a nutshell, the GitHub
API expects you to create a git "tree" and then place a "blob" object
into that tree. You then wrap the tree in a "commit" object and then
create that commit on GitHub using a data service wrapper. In
addition, writing a tree into GitHub requires knowing the base SHA
identifier, so you'll see code which retrieves the last SHA in the
tree associated with our current branch. This code will work
regardless of whether we are pushing code into the master branch, or
into the gh-pages branch, so this utility class works with real
Jekyll blogs. It would be lovely if the GitHub API provided more
"porcelain" (the Git term for user friendly verbs that insulate you
from knowing the internals of Git) instead of just this "plumbing"
API. Having the API work like this, however, does give you full
control over your repository and gives you the same power you would
have with a local repository. 

We'll write a helper class called `GitHubHelper` and add a single
function which writes a file to our repository.

The GitHub API requires that files stored in a repositories be
either Base64 encoded or UTF-8. The Apache Foundation provides a suite of tools
published to Maven (the same software repository where we grabbed the
EGit libraries) which can do this encoding for us, and which were
already installed in our Gradle file above (the "commons-codec" declaration).

We will start by defining a series of high level functions inside
`SaveFile` to get through building a commit inside of GitHub. Each
function itself contains some complexity so let's look first at the
overview of what it takes to put data into GitHub using the Git Data API.

[source,java]
-----
package com.example;
[filename="../GhRu2", language="java", sha="f2e7922:app/src/main/java/com/example/ghru/GitHubHelper.java" lines="2..55"]
snippet~~~~~
To be replaced
snippet~~~~~
...
-----

The `SaveFile` function goes through each step of writing data into
a repository using the GitHub API. We will walk through each of these
functions. As you can see, the `SaveFile` function has the same
signature as the function we call inside our unit test.

Let's implement each of the functions specified in the
GitHubHelper class.

==== Writing the blog content

First, we implement `generateContent()`. The following code snippet
shows functions defined to generate the content which we will place
into our remote git repository stored on GitHub.

[source,java]
-----
...
[filename="../GhRu2", language="java", sha="3714b07:app/src/main/java/com/example/ghru/GitHubHelper.java", lines="47..81", callouts="1,9,10,16,22,26,29,31" callouts_prefix=" // //"]
snippet~~~~~
To be replaced
snippet~~~~~
...
-----

You will notice many similarities between this Java code and the
Ruby code we used in the Jekyll chapter when generating filenames
and escaping whitespace.

<1> First, we setup several instance variables we will use when
storing the data into GitHub: the commit message, the full post
including the YAML Front Matter (YFM), the post contents encoded as
Base64, the filename, and then the three parameters we saved from the
call to `SaveFile()` function: the post itself, the title and the
repository name. 
<2> The `generateContent` function creates the content for our
addition: the filename, and the raw contents and the contents Base64 encoded.
<3> Here we create the YAML Front Matter (see the <<Jekyll>> chapter for more
details on YFM). This YAML specifies the "post" layout and sets
publishing to "true". We need to terminate the YAML with two newlines.
<4> Base64 encode the contents of the blog post
itself using a utility class found inside the Apache Commons
library. Contents inside a git repository are stored either as UTF-8
content or base64; we could have used UTF-8 since this is text content
but base64 works losslessly and you can always safely use base64
without concerning yourself about the content.
<5> Next, inside `getFilename()`, create the title by using the first
30 characters of the post.
<6> Convert the title to lowercase, and replace whitespace with
hyphens to get the Jekyll post title format.
<7> Jekyll expects the date to be formatted as `yyyy-MM-dd`, so use
the java `SimpleDateFormat` class to help in creating a string of that format.
<8> Finally, create the filename from all these pieces, prepending
`_posts` to the filename, where Jekyll expects posts to reside.

Now we will setup the services necessary to store a commit inside GitHub.

==== GitHub Services 

Next, we implement `createServices()`. There are several services
(wrappers around git protocols) which we need to instantiate. We don't
use them all immediately, but we will need them at various steps
during the file save process. The `createServices` call manages these
for us. 

[source,java]
-----
...
[filename="../GhRu2", language="java", sha="a608f2d3df0ca9a2:app/src/main/java/com/example/ghru/GitHubHelper.java", lines="105..116"]
snippet~~~~~
To be replaced
snippet~~~~~
...
-----

As a side note, writing things this way would allow us to specify an
enterprise endpoint instead of GitHub.com. Refer to the entprise
appendix for specific syntax on how to do this.

==== The Base SHA from the Repository and Branch

Now we implement `retrieveBaseSha()`. A git repository is a directed
acrylic graph (DAG) and as such, (almost) every node in the graph points
to another commit (or potentially two if it is a merge commit). When
we append content to our graph, we need to determine the prior node in
that graph and attach the new node. `retrieveBaseSha` does this: it
finds the SHA hash for our last commit, a SHA hash which is
functionally an address inside our tree. To determine this address,
our applications needs to have a reference to the repository, and we
use the repository service we instantiated earlier to get this
reference. Once we have the repository, we need to look inside the
correct branch: `getBranch` does this for us. 

[source,java]
-----
...
[filename="../GhRu2", language="java", sha="a608f2d3df0ca9a2:app/src/main/java/com/example/ghru/GitHubHelper.java" lines="108..145"]
snippet~~~~~
To be replaced
snippet~~~~~
...
-----

This SHA commit is very important. Without it, we cannot create a
new commit that links into our existing commit graph. In our starting
point function `SaveFile()` we discontinue our commit steps if the SHA
hash is not retrieved properly.

==== Creating the Blob

Contents inside a git repository are stored as blobs. `createBlob`
manages storing our content as a blob object, and then uses the
dataService to store this blob into a repository. Until we have called
`dataService.createBlob`, we have not actually placed the object
inside GitHub. Also, remember that blobs are not linked into our DAG
by themselves; they need to be associated with our DAG vis-a-vis a
tree and commit object, which we do next.

[source,java]
-----
...
[filename="../GhRu2", language="java", sha="a608f2d3df0ca9a2:app/src/main/java/com/example/ghru/GitHubHelper.java" lines="82..90"]
snippet~~~~~
To be replaced
snippet~~~~~
...
-----

==== Generating a Tree

Next, we generate a tree by implementing `generateTree()`. A tree
wraps a blob object and provides basically a path to our object: if
you were designing an operating system, the tree would be the filename
path and the blob is an inode. Our data service manager uses a
repository name and a base SHA address, one that we retrieved earlier,
to validate that this is a valid starting point inside our
repository. Once we have a tree, we fill out the necessary tree
attributes, like tree type (blob) and and 
tree mode (blob), and set the SHA from the previously created blob
object along with the size. Then we store the tree into our GitHub
account using the data service object. 

[source,java]
-----
...
[filename="../GhRu2", language="java", sha="a608f2d3df0ca9a2:app/src/main/java/com/example/ghru/GitHubHelper.java" lines="91..104"]
snippet~~~~~
To be replaced
snippet~~~~~
...
-----

==== Creating the Commit

We are getting close to actually finalizing the creation of content:
next, implement `createCommit()`. We have created
a blob which stores the actual content, and created a tree which
stores the path to the content (more or less), but since git is a
version control system, we also need to store information about who
wrote this object and why. A commit object stores this
information. The process should look familiar coming from the previous
steps: we create the commit and then add relevant metadata, in this case the
commit message. We also need to provide the commit user with the
commit. We then use the data service to create the commit
inside our repository in GitHub at the correct SHA address.

[source,java]
-----
...
[filename="../GhRu2", language="java", sha="cbbf6dbe7ab6568778c87beef66f75a9d43bf0d9:app/src/main/java/com/example/ghru/GitHubHelper.java", lines="146..180", callouts_prefix=" // //", callouts="3,5,6,9,13,24,26,29,34"]
snippet~~~~~
To be replaced
snippet~~~~~
...
-----

<1> Create a user service object. We will use this to get back user
data for the logged in user from GitHub. 
<2> We then create a commit user. This will be used to annotate the
commit object (twice in fact, as we will use it for both the author
and committer).
<3> Retrieve the user from the service, loading it from GitHub.
<4> Now, attempt to get the name for the logged in user. If the name
does not exist (the user has not set a name in their GitHub profile)
set the name to unknown. Then, store the name in the commit user
object.
<5> Do the same process to establish the email for the commit user.
<6> Now, return to the `createCommit` function and create a commit
object. 
<7> We need to use an author and committer, so pass in the commit user
we created in the `createCommitUser` function. 
<8> Next, generate a list of commits. We will only use one, but you
might recall commits can have multiple parents (a merge, for example)
and we need to specify the parent or parents for a commit. We create
the list, create a parent and set the base SHA we determined earlier,
and then indicate in our new commit that it is the parent.
<9> Finally, we create the commit using our data service object.

==== Updating the Master Resource

Our final step is to take the new commit SHA and update your branch
reference to point to it. 

[source,java]
-----
...
[filename="../GhRu2", language="java", sha="b520926:app/src/main/java/com/example/ghru/GitHubHelper.java", lines="189..-1", callouts_prefix=" // //", callouts="3,12,14"]
snippet~~~~~
To be replaced
snippet~~~~~
...
-----

<1> First, we create the new commit resource. We then associate the
new commit SHA, indicate it is a resource of commit type, and then
link it to our commit using its URL.
<2> We use the data service object to get the current branch reference
from GitHub. Branch references are retrieved by appending "heads" to
the branch (we determined the branch in a prior step).
<3> Finally, we update the branch reference to our new commit resource.

This is the complete code to add data to GitHub using the Git Data
API. Good work!

==== Passing all our tests

Our code is complete. Let's make sure our tests run successfully.

We need to setup our test configuration to run within Android Studio.
Select the "Build Variants" vertical tab on the left, and in "Test
Artifact" select "Unit Tests". Then, open the "Run" menu, and
select "Edit configurations...". Click the plus symbol, and choose
JUnit. You will be presented with space to create a unit test run
configuration. First, click on the "Use classpath of module" and
select "app". Make sure the "Test Kind" is set to class, and then
click on the selector to the right of the "class" field. It should
display your test class "GitHubHelperTest.java". We will need to store
the username and password as environment variables, so click to add
these. Your final configuration should look like the following.

[[creating-unit-tests]]
.Creating a unit test configuration
image::images/android-unit-test.png[Creating a unit test configuration]

Now, create the UI tests configuration: switch to "Android Instrumentation Tests" in the "Test Artifact"
of the "Build Variants" tab. Then, click on the "Run" menu, and again
go to "Edit configurations...". Click on the plus symbol, and this
time choose "Android Tests". Choose "app" as the module, and then
select "android.support.test.runner.AndroidJUnitRunner" as the
specific instrumentation runner. You can choose whichever target
device you prefer, an emulator, or a physical device if you have
one. Give the configuration a name like "Android Test". 

To run your tests, switch to the appropriate test artifact and then
from the "Run" menu, select "Debug..." and choose the proper test
configuration. You can set breakpoints and step through code in your
test or implementation from within Android Studio.

I personally find it annoying to switch between build variants when I
want to run my tests, so if you prefer, you can use the command line
instead (and ignore the need to change build variants).

[source,bash]
-----
$ GITHUB_HELPER_USERNAME=MyUsername \
GITHUB_HELPER_PASSWORD=MyPwd123 \
./gradlew testDebugUnitTest
...
:app:mockableAndroidJar UP-TO-DATE
:app:assembleDebugUnitTest UP-TO-DATE
:app:testDebugUnitTest UP-TO-DATE

BUILD SUCCESSFUL
$ ./gradlew connectedAndroidTest
...
:app:compileDebugAndroidTestNdk UP-TO-DATE
:app:compileDebugAndroidTestSources
:app:preDexDebugAndroidTest
:app:dexDebugAndroidTest
:app:packageDebugAndroidTest
:app:assembleDebugAndroidTest
:app:connectedDebugAndroidTest

BUILD SUCCESSFUL
-----

You will see similar results with the Android Studio test runner
windows. Our tests pass and our application is complete.

[NOTE]
If you want to see a more complicated version of the GitHub API on
Android, take a look at https://github.com/xrd/TeddyHyde.git[Teddy
Hyde] (also available on the Google Play Store). Teddy Hyde uses OAuth
to login to GitHub, and has a much richer set of features for editing
Jekyll blogs.

=== Summary

This application will allow you to write into a real Jekyll blog,
adding posts, upon which GitHub will regenerate your site. This little
application manages quite a few things: formatting the filename
correctly, encoding the data for submission to GitHub, and we have a
a unit test and UI test which help to verify the functionality. 

In the next chapter we will look at building a single page application
that edits information inside a GitHub repository using JavaScript and
the GitHub.js library talking to the Pull Request API.
