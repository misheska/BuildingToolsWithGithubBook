== Gists

GitHub "gists" are a place to share snippets of code. To create a gist, go to
gist.github.com and enter in any textual data. You then choose public or
secret access and create the gist. After creating the gist, you receive a
shareable URL with the code. If the type of textual data is specified,
usually the coding language type, then the code will be formatted in a
pretty way for better readability. If you need to share a small bit of code,
or write something and discuss it, gists are a great tool. 

There are other services that do this: pastebin was the first, and
there are many others that offer variances on code sharing. But gists
by GitHub are not simply a pasting service.

=== Gists are repositories

Gists from GitHub are not just a place to paste code. Every gist
created is a tiny repository. You can update gists and see
the history using `git log`. You can download gists, hack on the repository, and `git push` them
back into the repository on gist.github.com (which will republish them onto the publicly
facing web page). And, you can "fork" gists, just like
any other repository. 

You are allowed to branch within gist repositories; however, branches
are not displayed inside of gist.github.com. But, if you need the
benefits of branching when using GitHub gists you can branch normally
inside a repository and keep the branch information on the upstream
repository after you push it up. 

You can have an unlimited number of public and secret gists. Instead
of creating a new private repository from your limited amount in a
paid GitHub account, you can take a tiny bit of code
and make a secret gist, sharing this with others through a URL
instead of the more onerous process of adding collaborators to a
regular repository. Or, you can make a gist public, and
share that URL to mailing lists or anywhere you need public feedback.

=== No real privacy

As there are two types of gists (public and secret), it is important the understand the
differences between them. Public gists are searchable. Secret gists
are not searchable, but they are accessible to anyone who knows
the URL. Don't post any code to gist which you need to keep secret as
once you put it there, it is only as a safe as the URL is secret.  

=== Embedding Gists

You can embed gists as shareable code snippets inside of blogs or any
web page.

==== Inside HTML pages

To embed inside of an HTML page look for the "Embed this gist" box to
the left of a gist. Copy the code listed there (which will look
something like `<script
src="https://gist.github.com/xrd/8923697.js"></script>` and paste it
into your HTML. 

==== Inside Jekyll blogs

You can use the code `{% gist 8138797 %}` to embed a gist inside of your
Jekyll blog hosted on GitHub, or on any site built on the
"github-pages" branch mechanism (described in the "GitHub Pages" chapter). 

If you want to use a specific file within the gist, add a filename to
the gist code like `{% gist 8138797 hi.rb %}`.

Secret gists can be embedded. If you use a secret gist, you need to
prefix the username of the account holder in the gist like so: `{% gist
xrd/8138797 hi.rb %}`.

=== Gist from the command line

`gem install gist` will install a command line tool which assists in
creating gists. You can use it simply by typing the command, and then
entering the data you want to post as a gist.

[source,bash]
-----
$ gist
(type a gist. <ctrl-c> to cancel, <ctrl-d> when done)
{ "foo" : "bar" }
https://gist.github.com/9106765
-----

The gist command will return the link to the gist just created. Gists
are created anonymously by default. You can login using the `--login`
switch. Once you do this, your gists will be linked to
your account.

[source,bash]
-----
$ gist --login
Obtaining OAuth2 access_token from github.
GitHub username: xrd
GitHub password: 
2-factor auth code: 787878

Success! https://github.com/settings/applications
-----

You can pipe text to the gist command to use the contents of that
file.

[source,bash]
-----
$ echo '{ "foo" : "bar" }' | gist
https://gist.github.com/9106799
-----

You can also `cat` a file to gist.

[source,bash]
-----
$ cat MyJavaFile.java | gist
https://gist.github.com/9345609
-----

`grep` can be a useful tool if you need to
search for a specific piece of code and include several lines of
context around that code inside a gist. 

[source,bash]
-----
$ grep -A 20 myFunction MyJavaFile.java | gist
https://gist.github.com/9453069
-----

This command looks for the function `myFunction` inside the
`MyJavaFile.java` file and then prints the next 20 lines of context
and stores it as a gist.

Adding the `-o` switch automatically opens the gist inside your
default web browser. You can also copy the gist URL to the clipboard
using the `-c` switch. Or, you can copy the contents of your clipboard
into a gist using the `-P` switch. 

There are many other fun features of the gist command. To learn more
run the gist command with the `--help` switch. 

[source,bash]
-----
[filename=".", language="js", sha="30afd95:support/gists/gist.help"]
snippet~~~~~
To be replaced
snippet~~~~~
-----

=== Gists as fully functioning apps

You can use gists to store entire apps. Let's create a
simple Sinatra app.

Sinatra is a ruby library for creating dead-simple web servers. A sinatra program looks as
simple as this:

[code,ruby]
-----
[filename=".", language="js", sha="499e56c:support/gists/hi.rb"]
snippet~~~~~
To be replaced
snippet~~~~~
-----

Create a gist for this by visiting gist.github.com. Enter in the text exactly as above and then choose
public gist.

You now have a shareable gist of code, which anyone can use to review this code. More importantly, this
is an executable piece of code. To use it, click into the "Clone this gist" box to the left of the body of 
content. You'll get a URL which looks something like this:

https://gist.github.com/8138797.git

Copy this and then enter a terminal program and enter this command:

[source,bash]
$ git clone https://gist.github.com/8138797.git
$ cd 8138797

Now, you are inside the gist repository. If you look inside the
repository you'll see a list of files, a list which right now numbers
only one file.

[source,bash]
----
$ ls
hi.rb
----

To run this code, enter `ruby hi.rb`

If you had not used sinatra with ruby before, this will cause an
error. This program requires a library called "sinatra" and 
you have not yet installed it. We could write a README, or add
documentation into this file itself. Another 
way to guarantee the user has the proper files installed is to use a
"Gemfile" which is a file that tells 
which libraries are installed and from where. Let's add this:

[source,bash]
-----
$ printf "source 'https://rubygems.org'\ngem 'sinatra'" > Gemfile
-----

This is a quick way to add content to the file named Gemfile. To install the libraries required here, we run
the bundler command

[source,bash]
-----
$ bundle
Using rack (1.5.2) 
Using rack-protection (1.5.1) 
Using tilt (1.4.1) 
Using sinatra (1.4.4) 
Using bundler (1.3.5) 
Your bundle is complete!
Use `bundle show [gemname]` to see where a bundled gem is installed.
-----

This shows that we installed the library "sinatra" and the associated dependencies (rack, tilt and other associated
libraries). 

Why did we do things this way? Because now we can add the Gemfile to our repository locally, and then publish
into our gist for sharing on the web.

First, we need to update the "remote" repository reference. When we
first cloned the repository we used the https link. If we are using
SSH keys (and you should be; read the section "When should I use SSH
vs HTTPS?") then we need to switch to use the SSH URL format (git
protocol). Run this command:

[source,bash]
-----
$ git remote -v
origin       https://gist.github.com/8138797.git (fetch)
origin       https://gist.github.com/8138797.git (push)
-----

Your results will be slightly different, but this output displays our
remote repository; in other words, where we pull and push our code
changes. If you are familiar with the way 
that remotes work on GitHub you can see that this is a read-only URL.
We need to adjust these URLs in our remote so that it points to the
read-write remote URL. To do that, remove the `https://` part and add
a `git@`. Then, change the first `/` character after the
`gist.github.com` URL to a `:` character. If your remote was the same
as above you would have this `git@gist.github.com:8138797.git`. Then,
in a terminal window run these commands:

[source,bash]
----
$ git remote rm origin
$ git remote add origin git@gist.github.com:8138797.git
----

Now you can push new content in via the command line as well as edit
files inside of GitHub.com. As you develop your app you have
flexibility in whichever way fits you best.

=== A gist that displays gists

Let's add to our application and use the octokit gem to pull all
public gists for any user we specify.

Add a view `index.erb` at the root of our directory.

[code,ruby]
-----
[filename=".", language="js", sha="c80e5fe:support/gists/index.erb"]
snippet~~~~~
To be replaced
snippet~~~~~
-----

Add the octokit gem to our Gemfile:

[source,ruby]
-----
gem "octokit"
-----

Run `bundle` to install octokit. Then, modify our hi.rb app to look
like this:

[code,ruby]
-----
[filename=".", language="js", sha="bd1422c:support/gists/hi.rb"]
snippet~~~~~
To be replaced
snippet~~~~~
-----

Our filesystem should look like this, with three files.

[source,bash]
-----
$ ls -1
Gemfile
hi.rb
index.erb
-----

Run `bundle` to install octokit and restart Sinatra by running ctrl-c,
and then `ruby hi.rb`. If you visit `http://localhost:4567/xrd` in
your browser, you will see the count of public gists for any user you
specify.

image::images/gists-gist-count.png[]

==== Going deeper into the Gist API

The GitHub API uses hypermedia instead of
basic resource driven APIs. If you use a client like Octokit, the
hypermedia details are hidden behind an elegant ruby client. But,
there is a benefit to understanding how hypermedia works when you need
to retrieve deeper information from the GitHub API.

Most RESTful APIs come with a "sitemap", generally a API reference
document which tells a user which endpoints to use. You view
the resources available from that API and then apply some HTTP verb to
do something to them. Hypermedia thinks of an API differently.
Hypermedia APIs describe themselves inside their responses using
"affordances." What this means is that the API might respond like this:

[source,json]
-----
{
    "_links": {
        "self": {
            "href": "http://shop.oreilly.com/product/0636920030300.do"
        }
    }
    "id": "xrd",
    "name": "Chris Dawson"
}
-----

In this payload, you can see that there is an id ("xrd") and a name
("Chris Dawson"). Most APIs offer JSON responses, and this one
does too. This payload was forked from the HAL explanation at the
(https://phlyrestfully.readthedocs.org/en/latest/halprimer.html)[HAL
Primer] and you can find a more detailed explanation of these concepts
there. 

The important thing to note about Hypermedia APIs is that payloads contain
metadata about data itself and metadata about the possible options of
operating on the data. RESTful APIs typically provide a mapping
outside of the payload. You have to join the API sitemap with the data
in an ad-hoc way when using RESTful APIs; with Hypermedia APIs your
client can react to the payload itself correctly and intelligently
without knowing anything about a sitemap stored in human readable
documentation. 

This loose coupling makes APIs and their clients flexible. In theory,
a Hypermedia API works intuitively with a Hypermedia aware client. If
you change the API, the client, as it understands Hypermedia, can
react and still work as expected. Using a RESTful API means that
clients must be updated (either a newer version of the client must be
installed) or the client code must be upgraded. Hypermedia APIs can
alter their backend and the client, as long as it is
hypermedia-aware, can automatically and dynamically determine
the right way to access information from the response itself. In other
words, with a hypermedia client the API backend can change and your
client code should not need to.

This is explained in great detail in the book (http://www.amazon.com/o/ASIN/1449306578?tag=adapas02-20)[Building
Hypermedia APIs with HTML5 and Node]

In the case of Octokit, navigating hypermedia looks like this:

* Start at a resource, with code like `user = Octokit.user "xrd"`. This
  begins the initialization of the client.
* `user` now is an object filled with the actual data of the resource.
  In this case, you could call a method like `user.followers` to see a
  meager follower count.
* `user` also has hypermedia references. You can see these by calling
  `user.rels`. This retrieves the relationships described in the
  hypermedia links. In this case, calling `.rels` shows a map of
  relationships, displayed in ruby code like: `#<Sawyer::Relation::Map: [:avatar, :self, :html,
  :followers, :following, :gists, :starred, :subscriptions,
  :organizations, :repos, :events, :received_events]>`
* Using one of these relationships starts by keying into the
  relationship hash and then using the get and data methods to request
  that information from the GitHub API:
  `followers = user.rels[:followers].get.data`. 
* Once you call `.get.data` you will have a new followers object
  populated with an array of the followers (paged if it exceeds 100
  items). 

Let's extend our Sinatra app to retrieve actual data about the user's
gists by using hypermedia references.

[source,ruby]
-----
[filename=".", language="js", sha="e3133c8:support/gists/hi.rb"]
snippet~~~~~
To be replaced
snippet~~~~~
-----

The `index.erb` file contains code to iterate over each gist and pull
the content. You can see that our response object is an array of
gists, each which has an attribute called `fields`. This fields attribute
specifies the filenames available in each gist. If you reference that
filename against the files, the response includes a hypermedia `ref`
attribute. You can use this retreive the `raw` content using the
Octokit method `.get.data`.

[source,html]
-----
[filename=".", language="js", sha="e3133c8:support/gists/index.erb"]
snippet~~~~~
To be replaced
snippet~~~~~
-----

Now we see the gists and the contents.

image::images/gists-last-five.png[]

==== Caveats

The main benefit of using Hypermedia is that you don't need to harcode
URLs into your application, making your application less brittle when
inevitable changes to the API occur. 
link:$$http://signalvnoise.com/posts/3373-getting-hyper-about-hypermedia-apis$$[Cool URIs don’t change] 
(ironically a post by David Heinemeier Hansen
talking about why Hypermedia is overblow). As I was developing this
simple Sintra application, I attempted to refactor the code. From that
point onward, the GitHub API issued redirects to all my calls for raw
gist data. So, while my code did not change, the end result did. I no
longer get the content, but a HTML message indicating I am being
redirected. Perhaps I am using the hypermedia references incorrectly,
but I was able to retrieve the correct content previously. Now I
am not. Perl people argue that "there is more than one way to do it"
(TIMTOWTDI) is a good thing, but in this case I am left wondering
whether I got it right and now GitHub broke their API, or if I never
had the interface to the API correct. The non-deterministic results of
the API via Hypermedia make me uncomfortable using it in production.

image::images/gists-hypermedia-broken.png[]


