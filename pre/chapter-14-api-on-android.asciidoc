== GitHub API on Android

Android is currently the most popular operating system for mobile
devices, overtaking Symbian OS in 2010, experiencing incredible growth
since its release in 2008. Many software developers would not consider
a mobile device as a worthwhile platform for software developer tool
creation, but as more and more people shift to using mobile devices,
we will see demand for tools on mobile devices. The GitHub API has a
good set of bindings for developing Java and Android applications.
We'll use the egit libraries to develop a small Android application
which posts to our blog hosted on GitHub.

We will build an application which uses one of the unique features of a
mobile device: GPS. Our blogging application will allow us to login to
GitHub, determine our location, and then ask us for a quick note
describing what we are doing. The application will then compose a
Jekyll blog post for us and push the post into our blog on GitHub.

=== Prerequisites

If you don't have a physical Android device, don't fret. You can follow
along with this chapter without having an actual Android device by doing
development from a virtual device. 

==== Installing the Java SDK

Unfortunately there is no simple shell command to install Java in the
same way as there is for Ruby and NodeJS using RVM or NVM. 
Oracle controls the Java language and distribution of official SDKs,
and they restrict access to downloads other than from java.oracle.com.
Java is freely available, but you need to visit java.oracle.com and
find the correct download for your needs. Android works with either
the 1.6 or 1.7 versions of Java.

==== Installing the Android SDK

==== Creating AVDs for Development

Once you have installed the SDK, you can create a virtual device
called an AVD. AVDs are very useful because you can see any screen
resolution, any SDK version, and can quickly delete and reset the
devices. In addition, AVDs are created "rooted" by default, which
allows you to view the contents of all files, a capability which is
not available on non-rooted devices. This makes debugging AVDs much
easier because, for example, you can inspect SQLite databases using
command line tools rather than from within a compiled Java
application. Even if you have a physical device, it is worth learning
about AVD management.

To create an AVD, run the `android avd` command from a shell prompt.
You'll see the AVD manager, and can create new devices and manage
existing ones. Mine has multiple AVDs already created; yours will be
empty the first time.

image::images/android-avd.png[]

To create a new AVD, click on the "New.." button and follow the
prompts.

image::images/android-new-avd.png[]

You are generally free to choose whatever settings you like. Google
produces a real device called the Nexus 5. This is the Android
reference device, and is a good option for a generic device with good
support across all features. You can choose this one if you are
confused about which to use. 

Once you have created an AVD, start it up. It will take a few minutes
to boot; AVDs are actually emulating the chipset in software and
booting up can take a few minutes, unfortunately. There are ways to
speed up AVD boot time, like the Genymotion tool, but they are outside
of the scope of this book. After your AVD has completed booting, you
can test to see if it is correctly started and available using the adb
command line tool.

[source,bash]
$ adb devices -l
* daemon not running. starting it now on port 5037 *
* daemon started successfully *
List of devices attached 
0222fdc60910aede       device usb:1D110000 product:hammerhead model:Nexus_5 device:hammerhead

Running the adb command starts a daemon service which communicates
with your device. In this case the daemon reported that I have a
single device attached via USB which is a Nexus 5 device.

==== Creating a New Project

[source,bash]
$ mkdir ghru # GitHub R U?
$ cd ghru
$ android create project --target 13 --name GHRU --path . --activity GitHubRu --package com.githubru

These three commands create a new directory `ghru`, enter the
directory, and then build a simple Android directory structure with
the proper files.

If you have the ant tool installed, you can build this new project
with the `ant debug` command. This will create an APK in the bin
directory called `./bin/Ghru-debug-unaligned.apk`. To install it on
your device run the command `ant debug install`. Then, you can launch
the application by double clicking on the application titled
"MainActivity".

===== Adding Gradle support

Gradle is a new build system for Java and has become the offical build
system for the Android platform.
Using a simple `build.gradle` file we can build an entire Android
application from the command line. Gradle is well supported with more
advanced editors, so you can always import an Android project using
Gradle and use it with editors like Eclipse or Android Studio. Ant
used to be the default and preferred method of building Java projects
from the command line, but gradle syntax is so simple and powerful and
lightweight that it is now the preferred build system by the Android team.

[source,groovy]
-----
[filename=".", language="groovy", sha="b8e957f:support/android/ghru/build.gradle"]
snippet~~~~~
To be replaced
snippet~~~~~
-----

Gradle build files use some standard boilerplate which you can ignore
here, but there are two items which are worth noting.

<1> Gradle was not designed for Android; it started as a generic java
build tool. We need to specify where the files to compile reside for an android
project using the `sourceSets` variable.
<2> We can install the egit library, our interface to the GitHub API
from within Java, using this simple declaration. Gradle will download
the proper JAR files from the Maven repository and build them into our
application using this dependency declaration.


===== Default Android Main

When we use the above commands to create a new android application, it
creates a sample entry point into our Android application. That entry
point looks like this: 

[source,java]
-----
[filename=".", language="js", sha="b8e957f:support/android/ghru/src/com/githubru/MainActivity.java"]
snippet~~~~~
To be replaced
snippet~~~~~
-----

When the application is launched, the
Android OS will launch this activity and then call the `onCreate`
method for us. Inside this method, our application calls our parent's
implementation of `onCreate`, and then inflates the layout for our
application. This layout corresponds to an automatically generated XML
file which resides in our layouts directory. This file looks like
this:

[source,java]
-----
[filename=".", language="js", sha="d8f7a56e5fa3:support/android/wia/res/layout/main.xml"]
snippet~~~~~
To be replaced
snippet~~~~~
-----

You may have complicated feelings about XML files (I know I do), but
the Android layout XML files are a straightforward way to design
layouts declaratively, and many GUI tools provide sophisticated
ways to manage them. We'll manage ours by hand as they are exceedingly
simple.

==== Writing tests

Practicing test driven development (following the path of our
friends at GitHub), we write tests for our application before
writing the code. There are many options for writing
tests on Java and Android. JUnit is a popular testing tool which
permits writing unit tests. Robotium is another testing tool which
focuses on a different aspect of testing, user interface tests. We'll
use a wrapper around Robotium called Calabash for Android which allows
us to write in a high level domain specific language. I find that
writing Calabash tests is a simpler way to write tests using APIs
because Calabash tests interact with the entire application, rather
than only the internals like unit testing. With unit testing you can
be required to mock out network interactions, and as such, often miss
subtle changes in APIs. Calabash also uses a simple DSL which is not
compiled, so refactoring and changing tests is a simple matter. And,
Calabash has a console mode which allows you to interactively refine
your tests. Calabash makes testing easy; your code can be complicated,
but tests should not be an onerous task. Calabash test scripts do
require more overhead and take longer to run because they are
instantiating and running a new app for each test (unlike unit tests
which can isolate a test to a small piece of code), but you can
mitigate the impact of this on your development flow by using
continuous integration tools or using a service like AppThwack.com to
run tests in the cloud.

Calabash runs using ruby. You already have ruby installed, so to
install calabash, run these commands:

[source,bash]
$ printf "source 'https://rubygems.org'\n\ngem 'calabash-android'" >> Gemfile
$ bundle install
$ calabash-android gen

Your `Gemfile` should now look like this:

[source,java]
-----
[filename=".", language="js", sha="b8e957f:support/android/ghru/Gemfile"]
snippet~~~~~
To be replaced
snippet~~~~~
-----

We've now installed calabash and created the folder structure to hold
our tests along with some helper scripts. The `calabash-android gen`
command will write out a default calabash feature file like this.

[source,yaml]
-----
[filename=".", language="js", sha="8032c772:support/android/wia/features/my_first.feature"]
snippet~~~~~
To be replaced
snippet~~~~~
-----

As we do in all the other chapters, let's practice test driven
development. Modify the `my_first.feature` file:

[source,yaml]
-----
[filename=".", language="js", sha="b8e957f:support/android/ghru/features/my_first.feature"]
snippet~~~~~
To be replaced
snippet~~~~~
-----

Calabash requires the *internet* permission added to your
AndroidManifest.xml file in order to permit Calabash to run. Edit
`AndroidManifest.xml` to have the internet permission (look for the
line labled *uses-permission*):

[source,yaml]
-----
[filename=".", language="js", sha="b8e957f:support/android/ghru/AndroidManifest.xml"]
snippet~~~~~
To be replaced
snippet~~~~~
-----

This first test is very basic. It enters in our username and password,
clicks the login button, and then verifies that our login is
successful. To run it we need to build our application and then run
the test harness scripts.

[source,bash]
-----
$ gradle assembleDebug
$ bundle exec calabash-android resign build/apk/ghru-release-unsigned.apk 
$ bundle exec calabash-android run build/apk/ghru-release-unsigned.apk 
-----

[WARNING]
You can run calabash using just the abbreviated `calabash-android` command instead of `bundle
exec calabash-android`. But, there are good reasons to use the full
command. Adding bundle exec means that you are running your commands
within the bundler context, loading the gems which you specified in
the Gemfile. If you don't use this prefix, things might work, or they
might not. At the time of this writing, there was a bug with the
newest version of Calabash for Android (0.4.21). To rectify this, we
specify 0.4.20 in our Gemfile. If we run without `bundle exec` then we
will not load the correct version of the calabash gems if another
newer version of calabash was previously installed (as it was in my
case). You'll see this if you run `calabash-android version` even once
you've bundled with an older version.

Gradle and the Gradle Android plugin establish several tasks for you,
one of which is `assembleRelease`. That builds a release version of your
application for you, and then we specify the run command with a path
to it to run our tests. As expected, these tests will fail. 

image::images/android-calabash-failures.png[]

When using calabash, you need to understand two types of files: "feature"
files and "step" files. Feature files define human readable actions
comprising a test. Step files define the code, written in Ruby, behind
these actions. Step files are entirely optional as there are many default steps
defined inside of Calabash that suit many app actions. You can find a
full list of default "canned" calabash steps here:
https://github.com/calabash/calabash-android/blob/master/ruby-gem/lib/calabash-android/canned_steps.md
Though you are not required to write steps and can often avoid writing ruby
code entirely when writing calabash tests for Android applications,
steps files are very useful when you want to refactor a long
set of actions into a smaller piece and reuse it, or when you need to
do something in Ruby that is not possible in a meta DSL (domain
specific language) like Calabash. For example, in this case we will be
using username and passwords retrieved from our environment rather
than storing them inside our source files. Keeping passwords inside
our source repositories is never a good idea.

To build our step files, Calabash gives us the boilerplate code. Copy and
paste the output from our initial run into the file
`features/step_definitions/calabash_steps.rb`. This is our starting
point, with pending indicated for the places we will be adding our
code. Once the boilerplate is pasted in, modify it to actually enter
text into several Android text widgets. These ruby commands for
calabash are available in the Ruby API document:
https://github.com/calabash/calabash-android/blob/master/documentation/ruby_api.md

Here we write two steps with some helper code. Each step will test to
make sure that the text element exists, and then if we find it, set
the text inside that element to the username or password passed in
via an environment variable. 

[source,ruby]
-----
[filename=".", language="js", sha="b8e957f:support/android/ghru/features/step_definitions/calabash_steps.rb"]
snippet~~~~~
To be replaced
snippet~~~~~
-----

Then we run from the command line using this command `GH_USER=foobar
GH_PASS=barfoo calabash-android run
build/apk/ghru-release-unsigned.apk`. Our code will still fail to pass,
but now we are actually verifying real functionality of our future app.

image::images/android-calabash-failures2.png[]

So, let's start building our application. Obviously we need to put a
username and password field into our application. Jumping into our XML
layout files and editing gives us this file:

[source,xml]
-----
[filename=".", language="js", sha="bdb0709b8eb33:support/android/ghru/res/layout/main.xml"]
snippet~~~~~
To be replaced
snippet~~~~~
-----

We've now defined the XML for a full on login. Once logged in, we can
define what the user will see, a layout that permits them to enter a
blog post into a large text field and then click a button to submit
the blog post. We also leave an empty status box beneath the button to
provide context while saving the post.


[source,xml]
-----
[filename=".", language="js", sha="611556c:support/android/ghru/res/layout/logged_in.xml"]
snippet~~~~~
To be replaced
snippet~~~~~
-----

Viewed inside our application:

image::images/android-calabash-logged-in.png[]

If we run our tests now, we see that they pass. We now have a baseline
for success with our tests and can be assured that once we implement
all the actual functionality that our tests will tell us when we are
fully complete.



==== Code to talk to GitHub

We've finally assemble the proper UI for our application. Our last
step is to write the code which handles putting content into GitHub.
This is not a simple function, because the GitHub API requires you
build out the objects required.

This code was refactored from https://gist.github.com/Detelca/2337731.
Who is this mysterious user Detelca? 


[source,java]
-----

String username = getUsername();
String password = getPassword();
RepositoryService rs = getRepositoryService( username, password );
RepositoryBranch rb = getCorrectBranch( rs );
String baseCommitSha = getBaseCommitSha( rb );
commitContents( baseCommitSha, contents );

// create needed services
private RepositoryService getRepositoryService( String username, String password ) {
  RepositoryService repositoryService = new RepositoryService();
  repositoryService.getClient().setOAuth2Token(authToken);
  CommitService commitService = new CommitService();
  commitService.getClient().setOAuth2Token(authToken);
  DataService dataService = new DataService();
  dataService.getClient().setOAuth2Token(authToken);
}

private RepositoryBranch getCorrectBranch( RepositoryService ) {
  // get some sha's from current state in git
  Repository repository =  repositoryService.getRepository(login, repoName);
 List<RepositoryBranch> branches = repositoryService.getBranches(repository);
  RepositoryBranch theBranch = null;
  RepositoryBranch master = null;
  // Iterate over the branches and find gh-pages or master
  for( RepositoryBranch i : branches ) {
      String theName = i.getName().toString();
      if( theName.equalsIgnoreCase("gh-pages") ) {
          theBranch = i;
      }
      else if( theName.equalsIgnoreCase("master") ) {
          master = i;
      }
  }
  if( null == theBranch ) {
      theBranch = master;
  }
  return theBranch;
}

private String getBaseCommitSha( RepositoryBranch rb ) {
  String baseCommitSha = rb.getCommit().getSha();
}

private void commitContents( String baseCommitSha, String contents ) {
  String newSha = null;
  // create new blob with data
  Blob blob = new Blob();
  blob.setContent(contentsBase64);
  blob.setEncoding(Blob.ENCODING_BASE64);
  String blob_sha = dataService.createBlob(repository, blob);
  Tree baseTree = dataService.getTree(repository, baseCommitSha);
  
  // create new tree entry
  TreeEntry treeEntry = new TreeEntry();
  treeEntry.setPath(filename);
  treeEntry.setMode(TreeEntry.MODE_BLOB);
  treeEntry.setType(TreeEntry.TYPE_BLOB);
  
  treeEntry.setSha(blob_sha);
  treeEntry.setSize(blob.getContent().length());
  Collection<TreeEntry> entries = new ArrayList<TreeEntry>();
  entries.add(treeEntry);
  Tree newTree = dataService.createTree(repository, entries, baseTree.getSha());
  
  // create commit
  Commit commit = new Commit();
  commit.setMessage( commitMessage );
  commit.setTree(newTree);
  List<Commit> listOfCommits = new ArrayList<Commit>();
  listOfCommits.add(new Commit().setSha(baseCommitSha));
  // listOfCommits.containsAll(base_commit.getParents());
  commit.setParents(listOfCommits);
  // commit.setSha(base_commit.getSha());
  Commit newCommit = dataService.createCommit(repository, commit);
  
  // create resource
  TypedResource commitResource = new TypedResource();
  commitResource.setSha(newCommit.getSha());
  commitResource.setType(TypedResource.TYPE_COMMIT);
  commitResource.setUrl(newCommit.getUrl());
  
  // get master reference and update it
  Reference reference = dataService.getReference(repository, "heads/" + theBranch.getName() );
  reference.setObject(commitResource);
  Reference response = dataService.editReference(repository, reference, true) ;
  newSha = treeEntry.getSha();
  }
  catch( IOException ieo ) {
      ieo.printStackTrace();
  }
  
  return newSha;
}

-----

Now, let's make this more emojitional.

https://github.com/muan/emoji/blob/gh-pages/emojis.json

