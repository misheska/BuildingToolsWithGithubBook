== Hubot, Activities in GitHub, and 3rd party integrations

Though it has now been removed, GitHub used to call itself a tool for
"social coding." Though they have since rebranded, they still provide
access to the social layer inside of GitHub through the Activity API.
This API includes notifications (comments issued to users through
various events), stargazing tools (Facebook has "likes" while GitHub
has "stars" to indicate approval or interest), watching (a way to
track GitHub data) and events (a higher level activity stream useful for
following actions of users). 

Feeds are also a component of the Activity API but we won't cover them
in depth as they are nothing more than an Atom feed and not
interactive beyond that. 

In this chapter we'll investigate the Activity API. GitHubbers use an
extensible chat robot called Hubot to record and automate their tasks,
and we'll use Hubot to interact with the GitHub Activity API.

===== Hubot

If you visit hubot.github.com, you are told that "(Hubot) is a
customizable, kegerator-powered life embetterment robot." What does
that mean?

Hubot is a framework for developing chat robots. For many people, chat
is at best a way to waste time and at worst an annoyance or
distraction. For GitHubbers, chat is central to getting work done.
People collaborate at GitHub using chat but not in the way you might
assume, interspercing discussions with dog and cat pictures.
GitHubbers use chat as an exectuable and recorded layer of
communication that reduces training costs and improves accountability.
New GitHubbers can immediately enter a chat room and see commands used
to operate services central to GitHub. 

You've likely heard of DevOps, a term coined to recognize the
convergence of tools and responsibilities held by modern software
developers. More concretely, software developers no longer operate in
isolated silos where they commit code and an operations team deploys
this code. Modern software developers are expected to excel at not
only coding but at deployment. 

There are good historical reasons to keep a Chinese wall between
developers and operations teams. Developers think of features and
programming languages; operations people think of long term capacity
planning and security. These are very different concerns and there was
good reason to separate these problem donains. But, over time, cracks
appeared in the wall. The primary issue was that it became too easy to
explain away problems by filing bugs against the ops team if you were
a developer, or vice-versa. 

Entirely homegrown, developers and operations teams merged and devops
was born.

Another idea from GitHub: always build tools to manage complexity. At
many places, there is a naive approach to getting things done where
people follow the principle of insanity by doing things over and over
again and again. GitHubbers build tools. Hubot is one of these tools.
Why type "cap deploy" (the deployment command to deploy a server to a
production server) and then re-enter passwords, etc. If you do this,
you lose all of the context of that command: who ran it, when did they
run it, what time did they do it. Sure, you can find this information,
if you have the correct logins, and you have time to download the
massive log files, and you know where to look. GitHubbers created a
better way: a chat room that allows instantaneous communication across
your team and in which resides a robot who can interpret devops
commands (and a robot who is easily programmable). If the robot does
the work for you, you can easily see who asked the robot to do what he
did, when he did it and can see the contextual information as a
conversation between team members as to why. Anyone can parse a chat
log inside a web browser. Though GitHub has many of the smartest
people within the software world working for it, their tools are built
for the lowest common denominator.

==== Deficiencies and Limitations

Hubot requires a server to run. The simplest and cheapest way to run
it is on Heroku. However, for various reasons, this may not be
feasible given your security concerns. There are other ways to do
this, but I found all of them difficult and error prone. 

The documentation for Hubot is sketchy. Hubot definitely requires an
understanding of hubot to use hubot.

Be clear about versions.

==== Creating your Slackbot

Don't name your hubot the same as any of the adapters. That won't
work.

[code,bash]
-----
$ mkdir slacker-hubot
$ cd slacker-hubot/
$ yo hubot
$ npm install hubot-slack --save
$ ./bin/hubot -a slack
-----

===== Creating your slack account

Go to slack.com. You'll need to step through creating an account.

Once you have your slack site created, you need to create a channel.

image::images/hubot-create-channel.png[]

You can name the channel anything you want, but it is often a good
mnemonic to use a name which suggests this is a channel where more
serious work gets done. You can use hubot to indicate this is the
hubot based channel, or any other name you prefer. Once you click on
the link to create a channel, you'll see a popup asking for the name
and an optional description.

image::images/hubot-create-channel-popup.png[]

After you have created the channel, you'll immediately see a link to
"Add a service integration." 

image::images/hubot-add-service-integration.png[]

Slack supports many different service integrations, and one of them is
Hubot.  

image::images/hubot-choose-hubot-integration.png[]

Once you have created your service integration, you will be presented
with your environment variables which you'll need to pass on to your
Hubot. 

image::images/hubot-environment-variables.png[]

There are three variables to be aware of: the token which
allows your hubot to authenticate with the Slack service. This is a
token which can be revoked, and in fact the token from the image above
has been revoked and can no longer be used to authenticate into Slack. 

You also will need to specify the team and the name of your bot. The
Hubot slack adapter uses all of these variables to configure the bot.

==== Starting a hubot locally

As you are testing and developing your bot, you probably want to run
Hubot locally. There are no real downsides to running locally, but
obviously when others start using your bot you will want to run it on
a server which has better uptime than your laptop which is often
packed into your bag when you are heading home on the train, sadly,
exactly the moment when Frank needs to deploy a new build.

To run your bot locally, make sure that you specify the variables on
the command line:

[code,bash]
-----
$ HUBOT_SLACK_BOTNAME=slackbot HUBOT_SLACK_TEAM=inqry HUBOT_SLACK_TOKEN=6siRZXz4vlGJP6cbY ./bin/hubot
-----

If you have copied any of these incorrectly, you'll see an error like 

xxxx


===== Installing on Heroku

You'll need a Heroku account. Heroku offers free plans and everything
we'll do here can be done using a free plan. Next, install the heroku
toolbelt found here: https://toolbelt.heroku.com/. This provides a set
of tools useful for managing Heroku applications.

Once your chatbot is ready you can deploy to Heroku. You'll need to
add the same environment variables using the heroku tools.

[code,bash]
-----
$ heroku config:add HEROKU_URL=https://inqry-chatbot.herokuapp.com/
$ heroku config:add HUBOT_SLACK_TOKEN=6siRZXz4vlGJP6cbY0D4WpUh
$ heroku config:add HUBOT_SLACK_BOTNAME=slackbot
$ heroku config:add HUBOT_SLACK_TEAM=inqry
$ git push heroku master
Fetching repository, done.
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 317 bytes | 0 bytes/s, done.
Total 3 (delta 2), reused 0 (delta 0)

-----> Node.js app detected
-----> Requested node range:  0.10.x
-----> Resolved node version: 0.10.33
-----> Downloading and installing node
-----> Restoring node_modules directory from cache
-----> Pruning cached dependencies not specified in package.json
-----> Exporting config vars to environment
-----> Installing dependencies
       npm WARN package.json hubot-maps@0.0.0 No repository field.
-----> Caching node_modules directory for future builds
-----> Cleaning up node-gyp and npm artifacts
-----> Building runtime environment
-----> Discovering process types
       Procfile declares types -> web

-----> Compressing... done, 6.8MB
-----> Launching... done, v9
       https://inqry-chatbot.herokuapp.com/ deployed to Heroku

To git@heroku.com:inqry-chatbot.git
   d32e2db..3627218  master -> master

-----

If you see an issue, you can always run the heroku log command to view
logs for your application `heroku logs -t`.

[code,bash]
----
$ heroku logs -t
2014-11-18T07:07:18.716943+00:00 app[web.1]: Successfully 'connected'
as slackbot
2014-11-18T07:07:18.576287+00:00 app[web.1]: Tue, 18 Nov 2014 07:07:18
GMT connect deprecated limit: Restrict request size at location of
read at
node_modules/hubot/node_modules/express/node_modules/connect/lib/middleware/multipart.js:86:15
2014-11-18T07:07:19.052014+00:00 app[web.1]: [Tue Nov 18 2014 07:07:19
GMT+0000 (UTC)] INFO Data for hubot brain retrieved from Redis
2014-11-18T07:07:19.012425+00:00 app[web.1]: [Tue Nov 18 2014 07:07:19
GMT+0000 (UTC)] INFO Discovered redis from REDISTOGO_URL environment
variable
2014-11-18T07:07:19.047427+00:00 app[web.1]: [Tue Nov 18 2014 07:07:19
GMT+0000 (UTC)] INFO Successfully authenticated to Redis
2014-11-18T07:07:19.195698+00:00 heroku[web.1]: State changed from
starting to up
2014-11-18T07:07:36.856287+00:00 heroku[router]: at=info method=GET
path="/" host=inqry-chatbot.herokuapp.com
request_id=e0d4ee64-3823-4673-bf4d-1de2e5acf9ef fwd="54.204.130.199"
dyno=web.1 connect=1ms service=8ms status=404 bytes=218
----

When you send commands into your chat room you will notice events
inside of Heroku. This is a good way to verify that your bot is wired
into Slack properly.

You might also want to publish this repository into GitHub. Heroku
acts as a full git hosting system but you could use a GitHub account
as your staging environment where team members develop new features of
your chat bot, and then pull locally and push into Heroku.


=== NOTES 

Notifications
	* Watched repositories
	  ** Issues and comments
	  ** PRs and comments
	  ** Comments on any commits
	* Even if not watching, notifications come for:
	  ** @mentions
	  ** issue assignments
	  ** commits user authors or commits
	  ** any discussion participation
	* use notification or repo scope
	* x-poll-header: use this to know when to retry. Obey this.
	  ** Do clients support this	     	      	 
	* Look for "reason" payload. Indicates why the notification was sent
	* API
	  ** list GET
	  ** list for repo GET
	  ** mark as read PUT
	  ** mark as read for all in repo PUT
	  ** view thread GET
	  ** mark thread as read PATCH
	  ** set thread subscription   
	     ** booleans: subscribed or ignored
	  ** delete thread subscription DELETE

Starring
	* List stargazers (ro)
	* list repositories being starred (ro)
	* check if you are starring repo (ro)
	  ** If yes, 204, else 404. No body!
	* star repo (write)
	  ** Put request, content-length should be zero.
	* unstar repo (write)
	  ** Delete request
Watching
	Clarify what the difference is between watching and notifications. 
	  ** Show difference in data and how you get there.
	  ** Subscribe to a repo and then interact with a repo @mention.
	Is this simply legacy support and redundant?
	/repos/:owner/:repo/subscribers (list watchers)
	/users/:username/subscriptions (list repos being watched)
	/user/subscriptions (my watch list)
	/repos/:owner/:repo/subscription (get repo subscription)
	  ** if yes, JSON
	  ** if no, 404
	PUT /repos/:owner/:repo/subscription
	  ** modify subscription
	DELETE /repos/:owner/:repo/subscription
	  ** delete subscription

Events
	Optimized for etag, which improves polling. No impact on rate limits if 
	All events have similar structure
	    ** type: Event
	    ** public: true/false
	    ** payload hash
	      ** repo
	      ** actor
	      ** org
	    ** dates


Feeds
	