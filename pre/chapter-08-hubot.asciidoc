== Hubot, Activities in GitHub, and 3rd party integrations

Though the phrase has now been removed from their marketing materials,
GitHub used to call itself a tool for "social coding." Their identity
has been reworded, but they still provide 
access to the social layer inside of GitHub through the Activity API.
This API includes notifications (comments issued to users through
various events), stargazing tools (Facebook has "likes" while GitHub
has "stars" to indicate approval or interest), watching (a way to
track GitHub data) and events (a higher level activity stream useful for
following actions of users). 

The activity API section also includes "feeds." While feeds are
grouped within the Activity API, they are not programmatic in the same
way that an API is, and we won't cover them in depth here.  Feeds are
actually Atom feeds and not interactive beyond that. Atom feeds are
similar to RSS feeds: a static feed you can subscribe to with an Atom
client. 

In this chapter we'll investigate the Activity API. GitHubbers use an
extensible chat robot called Hubot to record and automate their tasks,
and we'll use Hubot to interact with the GitHub Activity API. Hubot is
not only an exciting tool for automating and interacting with
complicated software development systems, but provide a novel way of
collaboration, especially within remote teams. Through the use of
various APIs, including the GitHub API, chat robots can interact with
developers, and developers can control remote systems. All of this
provides a chat log, which makes it easy to understand what happened
when a post-mortems occurs. Perhaps most importantly, it is much
easier to  on-board new engineers quickly; new developers can on-board
themselves by reading actual conversations between team  members and
robots, rather than  asking someone to spend a day creating training
materials and training someone. As Fred Brooks elegantly documented in
his book "The Mythical Man Month", adding new people to an
organization almost always destroys ship schedules like no other
factor. Hubot minimized this impact immensely, and was crucial to
scaling the growth of both people and products at a fast growing startup
like GitHub. 

===== Hubot

If you visit hubot.github.com, you are told that "(Hubot) is a
customizable, kegerator-powered life embetterment robot." What does
that mean?

Hubot is a framework for developing chat robots. For many people, chat
is at best a way to waste time and at worst an annoyance or
distraction. For GitHubbers, chat is central to getting work done.
People collaborate at GitHub using chat but not in the way you might
assume, interspercing highly technical discussions of GitHub tools and
systems with dog and cat pictures. GitHubbers use chat as an
exectuable and recorded layer of communication that reduces training
costs and improves accountability. New GitHubbers can immediately
enter a chat room and see commands used to operate services central to
GitHub.

You've likely heard of DevOps, a term coined to recognize the
convergence of tools and responsibilities held by modern software
developers. More concretely, software developers no longer operate in
isolated silos where they commit code and an operations team deploys
this code. Modern software developers are expected to excel at not
only coding but at deployment as well. 

There are good historical reasons to keep a Chinese wall between
developers and operations teams. Developers think of features and
programming languages; operations people think of long term capacity
planning and security. These are very different concerns and there was
good reason to separate these problem donains. But, over time, cracks
appeared in the wall. The primary issue was that it became too easy to
explain away problems by filing bugs against the ops team if you were
a developer, or vice-versa. 

Entirely homegrown, developers and operations teams merged and devops
was born.

Another idea from GitHub: always build tools to manage complexity. At
many places, there is a naive approach to getting things done where
people follow the principle of insanity by repeating extremely
complicated tasks over and over again and again, never addressing
quality issues that come up when people fatigue and are
multitasking. GitHubbers do it differently: they build tools when they
see rote tasks like this. Hubot is one of these tools. 

If you have worked with the Ruby on Rails framework, you might know
about http://capistranorb.com:[Capistrano]. Capistrano was (and still
is) an important tool, because it automated a complicated series of
steps. But, GitHub took the idea further than other places. When a
developer types "cap deploy" (the deployment command to deploy a
server to a production server), there is an issue of accountability.
When this command is run from that developer's laptop, the context of
that command is lost (or at least hard to recover): who ran it, when did they 
run it, what time did they do it. Sure, you can find this information,
if you have the correct logins, and you have time to download the
massive log files, and you know where to look. GitHubbers created a
better way: a chat room that allows instantaneous communication across
your team and in which resides a robot who can interpret devops
commands (and a robot who is easily programmable). If the robot does
the work for you, you can easily see who asked the robot to do what he
did, when he did it and can see the contextual information as a
conversation between team members as to why. Anyone can understand a
conversational chat log; not anyone can parse SSH server logs. Though
GitHub has many of the smartest people within the software world
working for it, their tools are built for the lowest common denominator.

==== Deficiencies and Limitations

Hubot requires a server which hosts it and requires a chat endpoint on
which the chat rooms are hosted. Hubot is written in NodeJS and
requires a hosting service that supports NodeJS. Chat endpoints are
connected using adapters.

The simplest and cheapest hosting service is to use Heroku.
However, for various reasons, this may not be feasible given your
security concerns. There are other ways to do this, but I found all of
them difficult and error prone.  

Many chat endpoints are supported: you can use almost any popular chat
service or protocol: IRC, XMPP and many commercial services like
Gchat, Basecamp, even Twitter. Slack is a relatively new entrant into
the world of chat services, but despite their youth, the Slack API is
solid and connecting third party clients to their chat service is
simple and straightforward. We'll use Slack as our chat endpoint.

The documentation for Hubot is sketchy. Hubot definitely requires an
understanding of hubot to use hubot.

Be clear about versions.

==== Creating your Slackbot

Don't name your hubot the same as any of the adapters. That won't
work.

[code,bash]
-----
$ mkdir slacker-hubot
$ cd slacker-hubot/
$ yo hubot
$ npm install hubot-slack --save
$ ./bin/hubot -a slack
-----

===== Creating your slack account

Go to slack.com. You'll need to step through creating an account.

Once you have your slack site created, you need to create a channel.

image::images/hubot-create-channel.png[]

You can name the channel anything you want, but it is often a good
mnemonic to use a name which suggests this is a channel where more
serious work gets done. You can use hubot to indicate this is the
hubot based channel, or any other name you prefer. Once you click on
the link to create a channel, you'll see a popup asking for the name
and an optional description.

image::images/hubot-create-channel-popup.png[]

After you have created the channel, you'll immediately see a link to
"Add a service integration." 

image::images/hubot-add-service-integration.png[]

Slack supports many different service integrations, and one of them is
Hubot.  

image::images/hubot-choose-hubot-integration.png[]

Once you have created your service integration, you will be presented
with your environment variables which you'll need to pass on to your
Hubot. 

image::images/hubot-environment-variables.png[]

There are three variables to be aware of: the token which
allows your hubot to authenticate with the Slack service. This is a
token which can be revoked, and in fact the token from the image above
has been revoked and can no longer be used to authenticate into Slack. 

You also will need to specify the team and the name of your bot. The
Hubot slack adapter uses all of these variables to configure the bot.

==== Starting a hubot locally

As you are testing and developing your bot, you probably want to run
Hubot locally. There are no real downsides to running locally, but
obviously when others start using your bot you will want to run it on
a server which has better uptime than your laptop which is often
packed into your bag when you are heading home on the train, sadly,
exactly the moment when Frank needs to deploy a new build.

To run your bot locally, make sure that you specify the variables on
the command line:

[code,bash]
-----
$ HUBOT_SLACK_BOTNAME=slackbot HUBOT_SLACK_TEAM=inqry HUBOT_SLACK_TOKEN=6siRZXz4vlGJP6cbY ./bin/hubot
-----

If you have copied any of these incorrectly, you'll see an error like 

xxxx


===== Installing on Heroku

Let's consider installing using Slack.

===== Extending
===== Using with base camp
===== Running locally
===== Reviewing logs

======= Heroku

You'll need a Heroku account. Heroku offers free plans and everything
we'll do here can be done using a free plan. Next, install the heroku
toolbelt found here: https://toolbelt.heroku.com/. This provides a set
of tools useful for managing Heroku applications.

Once your chatbot is ready you can deploy to Heroku. You'll need to
add the same environment variables using the heroku tools.

[code,bash]
-----
$ heroku config:add HEROKU_URL=https://inqry-chatbot.herokuapp.com/
$ heroku config:add HUBOT_SLACK_TOKEN=6siRZXz4vlGJP6cbY0D4WpUh
$ heroku config:add HUBOT_SLACK_BOTNAME=slackbot
$ heroku config:add HUBOT_SLACK_TEAM=inqry
$ git push heroku master
Fetching repository, done.
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 317 bytes | 0 bytes/s, done.
Total 3 (delta 2), reused 0 (delta 0)

-----> Node.js app detected
-----> Requested node range:  0.10.x
-----> Resolved node version: 0.10.33
-----> Downloading and installing node
-----> Restoring node_modules directory from cache
-----> Pruning cached dependencies not specified in package.json
-----> Exporting config vars to environment
-----> Installing dependencies
       npm WARN package.json hubot-maps@0.0.0 No repository field.
-----> Caching node_modules directory for future builds
-----> Cleaning up node-gyp and npm artifacts
-----> Building runtime environment
-----> Discovering process types
       Procfile declares types -> web

-----> Compressing... done, 6.8MB
-----> Launching... done, v9
       https://inqry-chatbot.herokuapp.com/ deployed to Heroku

To git@heroku.com:inqry-chatbot.git
   d32e2db..3627218  master -> master

-----

If you see an issue, you can always run the heroku log command to view
logs for your application `heroku logs -t`.

[code,bash]
----
$ heroku logs -t
2014-11-18T07:07:18.716943+00:00 app[web.1]: Successfully 'connected'
as slackbot
2014-11-18T07:07:18.576287+00:00 app[web.1]: Tue, 18 Nov 2014 07:07:18
GMT connect deprecated limit: Restrict request size at location of
read at
node_modules/hubot/node_modules/express/node_modules/connect/lib/middleware/multipart.js:86:15
2014-11-18T07:07:19.052014+00:00 app[web.1]: [Tue Nov 18 2014 07:07:19
GMT+0000 (UTC)] INFO Data for hubot brain retrieved from Redis
2014-11-18T07:07:19.012425+00:00 app[web.1]: [Tue Nov 18 2014 07:07:19
GMT+0000 (UTC)] INFO Discovered redis from REDISTOGO_URL environment
variable
2014-11-18T07:07:19.047427+00:00 app[web.1]: [Tue Nov 18 2014 07:07:19
GMT+0000 (UTC)] INFO Successfully authenticated to Redis
2014-11-18T07:07:19.195698+00:00 heroku[web.1]: State changed from
starting to up
2014-11-18T07:07:36.856287+00:00 heroku[router]: at=info method=GET
path="/" host=inqry-chatbot.herokuapp.com
request_id=e0d4ee64-3823-4673-bf4d-1de2e5acf9ef fwd="54.204.130.199"
dyno=web.1 connect=1ms service=8ms status=404 bytes=218
----

When you send commands into your chat room you will notice events
inside of Heroku. This is a good way to verify that your bot is wired
into Slack properly.

You might also want to publish this repository into GitHub. Heroku
acts as a full git hosting system but you could use a GitHub account
as your staging environment where team members develop new features of
your chat bot, and then pull locally and push into Heroku.


=== NOTES 

Notifications
	* Watched repositories
	  ** Issues and comments
	  ** PRs and comments
	  ** Comments on any commits
	* Even if not watching, notifications come for:
	  ** @mentions
	  ** issue assignments
	  ** commits user authors or commits
	  ** any discussion participation
	* use notification or repo scope
	* x-poll-header: use this to know when to retry. Obey this.
	  ** Do clients support this	     	      	 
	* Look for "reason" payload. Indicates why the notification was sent
	* API
	  ** list GET
	  ** list for repo GET
	  ** mark as read PUT
	  ** mark as read for all in repo PUT
	  ** view thread GET
	  ** mark thread as read PATCH
	  ** set thread subscription   
	     ** booleans: subscribed or ignored
	  ** delete thread subscription DELETE

Starring
	* List stargazers (ro)
	* list repositories being starred (ro)
	* check if you are starring repo (ro)
	  ** If yes, 204, else 404. No body!
	* star repo (write)
	  ** Put request, content-length should be zero.
	* unstar repo (write)
	  ** Delete request
Watching
	Clarify what the difference is between watching and notifications. 
	  ** Show difference in data and how you get there.
	  ** Subscribe to a repo and then interact with a repo @mention.
	Is this simply legacy support and redundant?
	/repos/:owner/:repo/subscribers (list watchers)
	/users/:username/subscriptions (list repos being watched)
	/user/subscriptions (my watch list)
	/repos/:owner/:repo/subscription (get repo subscription)
	  ** if yes, JSON
	  ** if no, 404
	PUT /repos/:owner/:repo/subscription
	  ** modify subscription
	DELETE /repos/:owner/:repo/subscription
	  ** delete subscription

Events
	Optimized for etag, which improves polling. No impact on rate limits if 
	All events have similar structure
	    ** type: Event
	    ** public: true/false
	    ** payload hash
	      ** repo
	      ** actor
	      ** org
	    ** dates


Feeds
