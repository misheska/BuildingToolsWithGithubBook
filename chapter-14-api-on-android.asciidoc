== GitHub API on Android

Android is currently the most popular operating system for mobile
devices, overtaking Symbian OS in 2010, experiencing incredible growth
since its release in 2008. If it is not the case already, mobile OSes like 
Android and iOS will soon be more prevalent than desktop OSes. Though it 
may not occur to many people yet, as more and more people shift to using 
mobile devices, we will see demand for developer tools on mobile devices. 
The GitHub API has a good set of bindings for developing Java and
Android applications. We'll use the egit libraries to develop a small
Android application which posts to our blog hosted on GitHub.

Our blogging application will allow us to login to
GitHub, and then ask us for a quick note describing how we are
feeling. The application will then compose a Jekyll blog post for us
and push the post into our blog on GitHub. 

=== Prerequisites

==== Setting up a Jekyll blog

We are writing an application which adds jekyll blog entries, and we
are writing tests to verify our application works as advertisted, so
we need a sandbox blog against which we can run commands. There are
various ways to create a new Jekyll blog. The simplest is to run a
series of Ruby commands documented here; if you want to know more
about Jekyll, it is covered in more depth in the Jekyll chapter.
There are a few items of note when establishing a Jekyll blog that
have some complexity, things like mapping a hostname properly and using the
correct branch inside git. For our purposes here, however, we won't need
to make sure all that is established. All we need is to make sure that
we have a sandbox repository that has the structure of a jekyll blog.

[source,bash]
-----
$ printf "source 'https://rubygems.org'\n\ngem 'github-pages'\ngem 'hub'" >> Gemfile
$ export BLOG_NAME=mytestblog
$ bundle
$ jekyll new $BLOG_NAME
$ cd $BLOG_NAME
$ hub create
$ git push -u origin master
-----

These commands install the correct libraries for using Jekyll (and one
for our tests as well), generate a new blog using the jekyll command
line tool, and then create a blog on GitHub with those files. On the
second line we specify the name of the blog; you are welcome to change
this to any name you'd like, just make sure the tests match the name.

[WARNING]
When you have finished running these commands, you should close the
terminal window. There are other commands later in this chapter which
should occur in a fresh directory and as such it is best not to run
those commands from within the same directory where you created your
jekyll blog. You've pushed all those files into GitHub, so you could
safely delete the local repository in this directory.

==== Android Development Tools

If you don't have a physical Android device, don't fret. You can follow
along with this chapter without having an actual Android device by doing
development and testing on a virtual device. 

==== Installing the Java SDK

Unfortunately there is no simple shell command to install Java in the
same way as there is for Ruby and NodeJS using RVM or NVM. 
Oracle controls the Java language and distribution of official SDKs,
and they restrict access to downloads other than from java.oracle.com.
Java is freely available, but you need to visit java.oracle.com and
find the correct download for your needs. Android works with either
the 1.6 or 1.7 versions of Java.

==== Installing the Android SDK

==== Creating AVDs for Development

Once you have installed the SDK, you can create a virtual device
called an AVD. AVDs are very useful because you can see any screen
resolution, any SDK version, and can quickly delete and reset the
devices. In addition, AVDs are created "rooted" by default, which
allows you to view the contents of all files, a capability which is
not available on non-rooted devices. This makes debugging AVDs much
easier because, for example, you can inspect SQLite databases using
command line tools rather than from within a compiled Java
application. Even if you have a physical device, it is worth learning
about AVD management. 

To create an AVD, run the `android avd` command from a shell prompt.
You'll see the AVD manager, and can create new devices and manage
existing ones. Mine has multiple AVDs already created; yours will be
empty the first time.

image::images/android-avd.png[]

To create a new AVD, click on the "New.." button and follow the
prompts.

image::images/android-new-avd.png[]

You are generally free to choose whatever settings you like. Google
produces a real device called the Nexus 5. This is the Android
reference device, and is a good option for a generic device with good
support across all features. You can choose this one if you are
confused about which to use. 

Once you have created an AVD, start it up. It will take a few minutes
to boot; AVDs emulate the chipset in software and
booting up can take a few minutes, unfortunately. There are ways to
speed up AVD boot time, like the Genymotion tool, but they are outside
of the scope of this book. After your AVD has completed booting, you
can test to see if it is correctly started and available using the adb
command line tool.

[source,bash]
$ adb devices -l
* daemon not running. starting it now on port 5037 *
* daemon started successfully *
List of devices attached 
0222fdc60910aede       device usb:1D110000 product:hammerhead model:Nexus_5 device:hammerhead

Running the adb command starts a daemon service which communicates
with your device. In this case the daemon reported that I have a
single device attached via USB which is a Nexus 5 device.

==== Creating a New Project

[source,bash]
$ mkdir ghru # GitHub R U?
$ cd ghru
$ android create project --target 13 --name GHRU --path . --activity GitHubRu --package com.githubru

These three commands create a new directory `ghru`, enter the
directory, and then build a simple Android directory structure with
the proper files.

If you have the ant tool installed, you can build this new project
with the `ant debug` command. This will create an APK in the bin
directory called `./bin/Ghru-debug-unaligned.apk`. To install it on
your device run the command `ant debug install`. Then, you can launch
the application by double clicking on the application titled
"GitHubRu".

===== Adding Gradle support

Gradle is a new build system for Java and has become the offical build
system for the Android platform.
Using a simple `build.gradle` file we can build an entire Android
application from the command line. Gradle is well supported with more
advanced editors, so you can always import an Android project using
Gradle and use it with editors like Eclipse or Android Studio. Ant
used to be the default and preferred method of building Java projects
from the command line, but gradle syntax is so simple and powerful and
lightweight that it is now the preferred build system by the Android team.

[source,groovy]
-----
buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:0.6.+'
    }
}

repositories {
    mavenCentral()
}

apply plugin: 'android'

android {
    compileSdkVersion 19
    buildToolsVersion "19.0.1"

    sourceSets { // <1>
      main {
        manifest.srcFile 'AndroidManifest.xml'
        java.srcDirs = ['src']
        resources.srcDirs = ['src']
        res.srcDirs = ['res']
        assets.srcDirs = ['assets']
      }
    }

}

dependencies {
  compile 'org.eclipse.mylyn.github:org.eclipse.egit.github.core:2.1.5' // <2>
}



-----

Gradle build files use some standard boilerplate which you can ignore
here, but there are two items which are worth noting.

<1> Gradle was not designed for Android; it started as a generic java
build tool. We need to specify where the files to compile reside for an android
project using the `sourceSets` variable.
<2> We can install the egit library, our interface to the GitHub API
from within Java, using this simple declaration. Gradle will download
the proper JAR files from the Maven repository and build them into our
application using this dependency declaration.


===== Installing Gradle

To use gradle, you need to install it manually. Gradle does not come
packaged with the Java SDK nor with the Android SDK. There are various
ways to install gradle: either using a built in package manager, or
downloading from the website gradle.org. Gradle is in constant flux as
new versions are released, and I found the easiest way for me to
install it was to download into a directory called "bin" and unzip the
files there. Then, I could specify exactly the version needed, and try
to complete a build. For example, for this project, I found gradle 1.8
worked best and my command was `~/bin/gradle-1.8/bin/gradle
assembleRelease`. If you don't want to type in the full path, you
could set your path using a command like `export
PATH=~/bin/gradle-1.8/bin:$PATH` which would make the 1.8 version of
gradle available using just the `gradle` command.

===== Default Android Main

When we use the above commands to create a new android application, it
creates a sample entry point which is the starting point of our
Android application. 

[source,java]
-----
package com.githubru;

import android.app.Activity;
import android.os.Bundle;

public class MainActivity extends Activity
{
    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
    }
}

-----

When the application is launched, the
Android OS will launch this activity and then call the `onCreate`
method for us. Inside this method, our application calls our parent's
implementation of `onCreate`, and then inflates the layout for our
application. This layout corresponds to an automatically generated XML
file which resides in our layouts directory called `main.xml`. 

[source,java]
-----
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    >
<TextView
    android:layout_width="fill_parent"
    android:layout_height="wrap_content"
    android:text="Hello World, MainActivity"
    />
</LinearLayout>


-----

You may have complicated feelings about XML files (I know I do), but
the Android layout XML files are a straightforward way to design
layouts declaratively, and many GUI tools provide sophisticated
ways to manage them. We'll manage ours by hand as they are exceedingly
simple.

==== Preparing our application for Calabash testing

Calabash requires the *internet* permission added to your
AndroidManifest.xml file. Calabash is a set of technologies
combined together to permit testing. One of these pieces is a wrapper around
your application (built on Robotium) that communicates with
Ruby over HTTP calls, and as such, your application must permit
network communication. To enable this, edit the `AndroidManifest.xml`
file to have the internet permission (look for the line labled
*uses-permission*): 

[source,yaml]
-----
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
      package="com.whereimat"
      android:versionCode="1"
      android:versionName="1.0">
    <application android:label="@string/app_name"
                 android:icon="@drawable/ic_launcher">
      <uses-permission android:name="android.permission.INTERNET" />
        <activity android:name=".MainActivity"
                  android:label="@string/app_name">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>
</manifest>

-----

==== Writing tests

Practicing test driven development, we write tests for our application before
writing the code. There are many options for writing
tests on Java and Android. JUnit is a popular testing tool which
permits writing unit tests. Robotium is another testing tool which
focuses on a different aspect of testing, user interface tests. We'll
use a wrapper around Robotium called Calabash for Android which allows
us to write in a high level domain specific language. I find that
writing Calabash tests is a simpler way to write tests using APIs
because Calabash tests interact with the entire application, rather
than only the internals like unit testing. With unit testing you can
be required to mock out network interactions, and as such, often miss
subtle changes in APIs if your mocks are not synchronized with the
API itself, a cumbersome and error prone process. Calabash uses a
simple DSL for writing tests which is readable and elegant. Most
importantly, Calabash scripts are not compiled, so refactoring and
changing tests does not require the code and compile loop involved in
writing tests using pure Java with JUnit. 

Calabash also has a console mode which allows you to 
interactively refine your tests. You jump into a console and query
a running application using simple ruby commands. This is a
powerful way to experiement with the calabash ruby API and allows you
to build tests quickly once you have determined the correct code to use.

Calabash makes testing easy; your code can be complicated, 
but tests should not be an onerous task. Calabash test scripts do
require more overhead and take longer to run because they are
instantiating and running a new app for each test (unlike unit tests
which can isolate a test to a small piece of code), but you can
mitigate the impact of this on your development flow by using
continuous integration tools or using a service like AppThwack.com to
run tests in the cloud.

Calabash runs using ruby. You already have ruby installed, so to
install calabash, run these commands:

[source,bash]
$ printf "source 'https://rubygems.org'\n\ngem 'calabash-android', '0.4.20'\ngem 'httparty'" >> Gemfile
$ bundle install
$ calabash-android gen

The `Gemfile` you just created should now look like this:

[source,java]
-----
source 'https://rubygems.org'

gem 'calabash-android', '0.4.20'
gem "httparty"

-----

We've also now installed calabash and created the folder structure to hold
our tests along with some helper scripts. The `calabash-android gen`
command will write out a default calabash feature file. This is
boilerplate which we should change, so make the file named
`features/my_first.feature` look like this: 

[source,yaml]
-----
Feature: Login and post

  Scenario: As a valid user I can log into my app and post to my blog
    When I enter the username
    And I enter the password
    And I press button number 1
    Then I wait up to 10 seconds to see "Logged into GitHub"
    Then I choose my blog
    And I enter my current mood status
    And I press button number 1
    Then I wait up to 10 seconds to see "Successful jekyll post"
    And I have a new jekyll post with my mood status

-----

You may not know how this works or what it does behind the scenes, but
the nice thing about Calabash scripts are that they are very readable
by humans without knowing any of those details. This test enters
credentials into the application, presses the first button, then waits
to make sure a login message is displayed, then enters in some text
into a field and presses another button and then expects to see the
text "Successful jekyll post". The last line is an
expectation that we will have created a post inside our GitHub
repository; we will do this using ruby code to pull the file from the
repository and verify it. Whereas the other tests all verify or take
action inside our Android application (like clicking a button), this
line represents a verification happening outside of our
Android application. Calabash allows us to test from whatever vantage
point works best given the situation. 

When using calabash, you need to understand two types of files: "feature"
files and "step" files. Feature files define human readable actions
comprising a test. Step files define the code, written in Ruby, behind
these actions. Step files are entirely optional as there are many default steps
defined inside of Calabash that suit many app actions. You can find a
full list of default "canned" calabash steps here:
https://github.com/calabash/calabash-android/blob/master/ruby-gem/lib/calabash-android/canned_steps.md
Though you are not required to write steps and can often avoid writing ruby
code entirely when writing calabash tests for Android applications,
steps files are very useful when you want to refactor a long
set of actions into a smaller piece and reuse it, or when you need to
do something in Ruby that is not possible in a meta DSL (domain
specific language) like Calabash. For example, in this case we will be
using username and passwords retrieved from our environment rather
than storing them inside our source files. Keeping passwords inside
our source repositories is never a good idea.

Gradle and the Gradle Android plugin establish several useful "tasks" for you,
one of which is `assembleRelease`. That task builds a release version of your
application for you. We need to then resign the APK (the Android
application package format), and then we specify the `run` subtask
with a path to the APK to run our tests. 

[source,bash]
-----
$ gradle assembleDebug
$ bundle exec calabash-android resign build/apk/ghru-release-unsigned.apk 
$ bundle exec calabash-android run build/apk/ghru-release-unsigned.apk 
-----

We have not yet built the code to make these tests pass, and in addition,
we have not yet implemented the step definitions for our feature
tests. So, we see calabash provide us with boilerplate code which we
will copy into our step definition files to complete the test suite.

image::images/android-calabash-failures.png[]

[WARNING]
You can run calabash using just the abbreviated `calabash-android` command instead of `bundle
exec calabash-android`. But, there are good reasons to use the full
command. Adding bundle exec means that you are running your commands
within the bundler context, loading the gems which you specified in
the Gemfile. If you don't use this prefix, things might work, or they
might not. At the time of this writing, there was a bug with the
newest version of Calabash for Android (0.4.21). To rectify this, we
specify 0.4.20 in our Gemfile. If we run without `bundle exec` then we
will not load the correct version of the calabash gems if another
newer version of calabash was previously installed (as it was in my
case). You'll see this if you run `calabash-android version` even once
you've bundled with an older version.

Copy and paste the output from our initial run into the file
`features/step_definitions/calabash_steps.rb`. This is our starting
point, with pending indicated for the places we will be adding our
code. Once the boilerplate is pasted in, modify it to enter
text into several Android text widgets. These ruby commands for
calabash are available in the Ruby API document:
https://github.com/calabash/calabash-android/blob/master/documentation/ruby_api.md

As you can see from the following code, step definitions are sometimes
just regular expression matches of the features, but can also include
vanilla ruby code. At the top of the file we store some variables for
usage later in the tests. Specifically, we will store a status message
as a random choice from a moods array, and then later verify that we
successfully posted that status message into GitHub by reusing that variable.
The `set_title_and_mood` method establishes the correct filename
format for a Jekyll blog post (we'll do this same formatting in our
Java code later). Then we write a method which uses the Calabash Ruby
API to verify a UI element exists by the ID (these are the IDs created
inside our XML layout files), and if so, sets the field to the text
provided. After this our steps are very basic and uniform except for
the last item. Our last item verifies that we successfully stored the
data inside our GitHub repository by making a basic HTTP call using
the Httparty ruby gem and then looking inside the retrieved content
to make sure it matches the mood we saved earlier.

[source,ruby]
-----
require 'calabash-android/calabash_steps'
require 'httparty'

def set_title_and_mood
  moods = %w{ happy sad angry blue energized }
  @mood = "Feeling #{moods[(rand()*moods.length).to_i]} today"
  @title = @mood.downcase.strip.gsub(' ', '-').gsub(/[^\w-]/, '')
  date = (ENV['date'] ? Time.parse(ENV['date']) : Time.now).strftime('%Y-%m-%d')
  @filename = "_posts/#{date}-#{@title}.md"
end

def check_and_set( id, text )
  check_element_exists "edittext id:'#{id}'"
  query "edittext id:'#{id}'", :setText => text
end

When(/^I enter the username$/) do
  check_and_set( "username", ENV['GH_USERNAME'] )
end

When(/^I enter the password$/) do
  check_and_set( "password", ENV['GH_PASSWORD'] )
end

Then(/^I choose my blog$/) do
  check_and_set( "repository", ENV['GH_REPO'] )
end

Then(/^I enter my current mood status$/) do
  set_title_and_mood()
  check_and_set( "post", @mood )
end

And(/^I have a new jekyll post with my mood status$/) do
  url = "https://raw.githubusercontent.com/#{ENV['GH_USERNAME']}/#{ENV['GH_REPO']}/#{ENV['GH_BRANCH']||'master'}/#{@filename}"
  puts "Checking #{url} for content..."
  response = HTTParty.get( url )
  assert( response.body.include?( @mood ), "Post unsuccessful" )
end


-----

Then we run from the command line using this command `GH_USER=foobar
GH_PASS=barfoo GH_REPO=mytestblog calabash-android run
build/apk/ghru-release-unsigned.apk`. Our tests will still fail to pass,
but now we are establishing a baseline success story for the
real functionality of our future app.

image::images/android-calabash-failures2.png[]

==== Implementing the Login Screen

So, let's start building our application. Obviously we need to put a
username and password field into our application. Jumping into our XML
layout files and editing gives us this file:

[source,xml]
-----
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    >
<TextView
    android:layout_width="fill_parent"
    android:layout_height="wrap_content"
    android:text="GitHub Username:"
    />
<EditText
    android:layout_width="fill_parent"
    android:layout_height="wrap_content"
    android:id="@+id/username"
    />

<TextView
    android:layout_width="fill_parent"
    android:layout_height="wrap_content"
    android:text="GitHub Password:"
    />

<EditText
    android:layout_width="fill_parent"
    android:layout_height="wrap_content"
    android:id="@+id/password"
    />

<Button
    android:layout_width="fill_parent"
    android:layout_height="wrap_content"
    android:text="Login"
    android:id="@+id/login"
    />

<TextView
    android:layout_width="fill_parent"
    android:layout_height="wrap_content"
    android:text="GitHub Password:"
    android:id="@+id/login_status"
    />

</LinearLayout>


-----

We also need a layout once we have logged in. Create a file called
`logged_in.xml` inside the `res/layout` directory. Once logged in, 
the user is presented with a layout asking them to choose which
repository to save into, asks them to enter their blog post
into a large text field and then click a button to submit 
that blog post. We also leave an empty status box beneath the button to
provide context while saving the post.

[source,xml]
-----
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    >
  <TextView
      android:layout_width="fill_parent"
      android:layout_height="wrap_content"
      android:text="Logged into GitHub"
      android:layout_weight="0"
      />

  <EditText
      android:layout_width="fill_parent"
      android:layout_height="wrap_content"
      android:hint="Enter the blog repository"
      android:id="@+id/repository"
      android:layout_weight="0"
      />
  
  <EditText
      android:gravity="top"
      android:layout_width="fill_parent"
      android:layout_height="fill_parent"
      android:hint="Enter your blog post"
      android:id="@+id/post"
      android:layout_weight="1"
      />
  
  <Button
      android:layout_width="fill_parent"
      android:layout_height="wrap_content"
      android:layout_weight="0"
      android:id="@+id/submit"
      android:text="Send blog post"/>
    
  <TextView
      android:layout_width="fill_parent"
      android:layout_height="wrap_content"
      android:id="@+id/post_status"
      android:layout_weight="0"
      android:text=""/>
  
</LinearLayout>


-----

Our `MainActivity` now can implement the functionality to use these
two layouts.

[source,java]
-----
package com.githubru;

import android.app.Activity;
import android.os.Bundle;
import android.widget.Button;
import android.widget.LinearLayout;
import android.widget.EditText;
import android.widget.TextView;
import android.view.View;

public class MainActivity extends Activity
{
    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main); 

        Button login = (Button)findViewById( R.id.login ); // <1>
        login.setOnClickListener(new View.OnClickListener() {
                public void onClick(View v) {
                    login(); // <2>
                }
            });
    }

    private void login() {
        setContentView(R.layout.logged_in); // <3>

        Button submit = (Button)findViewById( R.id.submit );
        submit.setOnClickListener(new View.OnClickListener() {
                public void onClick(View v) {
                    doPost(); // <4>
                }
            });
    }

    private void doPost() {
        TextView tv = (TextView)findViewById( R.id.post_status ); // <5>
        tv.setText( "Successful jekyll post" );
    }

}

-----

This code mocks out the functionality we will be building and shows us
exactly what the UI will look like once that code is completed.

<1> We register a click handler for our login button.
<2> When the login button is clicked, we call the `login()` function
<3> Once we have logged in, we setup a new layout with UI elements suitable for making a blog post
<4> We then setup another click handler for the submit button; when
clicked, we call the `doPost()` function.
<5> Our `doPost()` function updates the status message at the bottom
of our application.

Even though our code is not functional yet, this application will
compile. This is a good time to play with this application and verify
the UI looks appropriate. Were we to click the
login button, we would see that our blog post form looks like this.

image::images/android-calabash-logged-in.png[]

Our tests will pass completely right now except for the final
test which checks GitHub to verify a file was correctly posted. We can
now proceed to writing code to login to GitHub and write a file into
our Jekyll repository.

==== Code to Login to GitHub

Let's first work on the `login()` method. From the Egit libary
reference: 

https://github.com/eclipse/egit-github/tree/master/org.eclipse.egit.github.core

The code to login to GitHub is as simple as can be:

[source,java]
-----
//Basic authentication
GitHubClient client = new GitHubClient();
client.setCredentials("user", "passw0rd");
-----

Unfortunately the context in which the code
runs makes as much a difference as the code. Android requires that any
code which makes network connections run inside a background thread.
Android applications, in order to maintain responsive UI behavior,
disallow any long running processes (or indeterminate processes, like
network activity) from running on the main UI thread. If your eyes are
starting to spin at the thought of learning about threading using
Java, dispell your worries. The Android SDK provides a great class for
managing background thread code called `AsyncTask`. We derive from
this interface and override at least one method which runs our
background thread code (called `doInBackground()` coincidentally).

[source,java]
-----
...
public class MainActivity extends Activity
{
    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main); 

        Button login = (Button)findViewById( R.id.login ); 
        login.setOnClickListener(new View.OnClickListener() {
                public void onClick(View v) {
                    EditText utv = (EditText)findViewById( R.id.username ); // <1>
                    EditText ptv = (EditText)findViewById( R.id.password );
                    String username = (String)utv.getText().toString();
                    String password = (String)ptv.getText().toString();
                    TextView status = (TextView)findViewById( R.id.login_status ); // <2>
                    status.setText( "Logging in, please wait..." );
                    new LoginTask().execute( username, password ); // <3>
                }
            });
    }

    private void loggedIn() {

        setContentView(R.layout.logged_in); 

        Button submit = (Button)findViewById( R.id.submit );
        submit.setOnClickListener(new View.OnClickListener() {
                public void onClick(View v) {
                    doPost(); 
                }
            });
    }

    class LoginTask extends AsyncTask<String, Void, Boolean> {  // <4>
        @Override
            protected Boolean doInBackground(String... credentials) {
            boolean rv = false;
            UserService us = new UserService();
            us.getClient().setCredentials( credentials[0], credentials[1] ); // <5>
            try {
                User user = us.getUser( credentials[0] ); // <6>
                rv = null != user;
            }
            catch( IOException ioe ) {}
            return rv;
        }
        
        @Override
            protected void onPostExecute(Boolean result) {
            if( result ) {
                loggedIn(); // <7>
            }
            else {
                TextView status = (TextView)findViewById( R.id.login_status );
                status.setText( "Invalid login, please check credentials" ); // <8>
            }
        }
    }

    private void doPost() {
        TextView tv = (TextView)findViewById( R.id.post_status ); 
        tv.setText( "Successful jekyll post" );
    }
    
...
-----

We've now implemented the login functionality.

<1> We retrieve the username and password from our UI elements. 
<2> Our UI should notify the user that a login is occurring in a
background task, so we grab the status text element and update the text in it. 
<2> We then start the background thread process to do our login. This
syntax creates a new thread for us with the username and password as
parameters. Android will manage the lifecycle of this thread for us,
meaning starting a new thread, separate from the main UI thread.
<2> Here we define the derived AsyncTask class. The three types in the
generics signature provide a way to parameterize our instantiated task;
we need to provide a username and password to the background task, and
the first type in the signature allows us to pass an array of Strings.
You can see in the actual method definition that the ellipsis notation
provides a way to parameterize a method with a variable number of
arguments (called varargs). Inside our defined method we expect we
will send two Strings in, and we make sure to do that in our call.
<5> Once inside the `doInBackground()` function, we instantiate a
`UserService` class, a wrapper around the GitHub API which interacts
with the user service API call. In order to access this information,
we have to retrieve the client for this service call and provide the
client with the username and password credentials. This is the syntax
to do that.
<6> We wrap the call to `getUser()` in a try block as the function
signature can throw an error (if the network were down, for example).
We don't really need to retrieve information about the user using the
User object, but this call verifies that our username and password are
correct and we store the result of the call in our return value.
GitHub will not use the credentials you set until you make an API
call, so we need to use our credentials to access something in order
to verify those credentials work.
<7> We renamed the `login()` function to more accurately reflect the
fact that when we call this, we are already logged into GitHub.
<8> If our login was a failure, either because of network failure, or
because our credentials were incorrect, we indicate this in the status
message. A user can retry if they wish.

This code will not compile yet, because we need to import the support
classes. The JARs and classes for Egit have already been added to our project
automatically using gradle. Make sure you add these `import`
statements to the top of the file, under the other imports.

[source,java]
-----
...
import android.view.View;
import android.os.AsyncTask;
import org.eclipse.egit.github.core.service.UserService;
import org.eclipse.egit.github.core.User;
import java.io.IOException;
...
-----

==== Code to talk to GitHub

Our last step is to write the code which handles putting content into GitHub.
This is not a simple function, because the GitHub API requires you
build out the structure used internally by Git. A great reference for learning more about
this structure is the free and open source book called "Pro Git" and
specifically the last chapter called "Git Internals".
(http://git-scm.com/book/en/Git-Internals). In a nutshell, the GitHub
API expects you to create a git "tree" and then place a "blob" object
into that tree. You then wrap the tree in a "commit" object and then
create that commit on GitHub using a data service wrapper. In
addition, writing a tree into GitHub requires knowing the base SHA
identifier, so you'll see code which retrieves the last SHA in the
tree associated with our current branch. This code will work
regardless of whether we are pushing code into the master branch, or
into the gh-pages branch, so this utility class works with real
Jekyll blogs. It would be lovely if the GitHub API provided more
"porcelain" (the Git term for user friendly verbs that insulate you
from knowing the internals of Git) instead of only this "plumbing" API, but
having the API work like this does give you full control over manipulating
your repository and data programmatically in any way that you could
possibly need to as it maps exactly to the capabilities you would
have writing to a file stored in a local git repository on your hard drive.

We'll write a helper class called `GitHubHelpers` and add a single
static method which writes a file to our repository.

The GitHub API requires that files written into repositories be
Base64 encoded. The Apache Foundation provides a suite of tools
published to Maven (the same software repository where we grabbed the
egit libraries) which can do this encoding for us. To add this library
to our project, we need to add to our dependencies inside our `build.gradle` file:

[source,java]
-----
...

dependencies {
  compile 'org.eclipse.mylyn.github:org.eclipse.egit.github.core:2.1.5' 
   compile( 'commons-codec:commons-codec:1.9' )
}
...
-----

Our new helper class is verbose but at least provides a simple wrapper
around the complicated GitHub API for us.

[source,java]
-----
package com.githubru;

import org.eclipse.egit.github.core.*;
import org.eclipse.egit.github.core.service.CommitService;
import org.eclipse.egit.github.core.service.DataService;
import org.eclipse.egit.github.core.service.GistService;
import org.eclipse.egit.github.core.service.RepositoryService;
import org.apache.commons.codec.binary.Base64;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.io.IOException;
import java.util.*;

class GitHubHelpers {

    private static String getFilename( String post ) { // <1>
        String title = post.substring( 0, post.length() > 30 ? 30 : post.length() );
        String jekyllfied = title.toLowerCase().replaceAll( "\W+", "-").replaceAll( "\W+$", "" );
        SimpleDateFormat sdf = new SimpleDateFormat( "yyyy-MM-dd-" );
        String prefix = sdf.format( new Date() );
        String filename = "_posts/" + prefix + jekyllfied + ".md";
        return filename;
    }
    
    public static boolean SaveFile( String login, String password, String repoName,
                                    String post ) {
        
        boolean rv = false;
        String commitMessage = "GitHubRu Update";
        String postContentsWithYfm = "---\nlayout: post\npublished: true\n---\n\n" + post; // <2>
        String contentsBase64 = new String( Base64.encodeBase64( postContentsWithYfm.getBytes() ) );  // <3>
        String filename = getFilename( post );

        try {
            // Thank you: https://gist.github.com/Detelca/2337731 // <4>

            // create needed services
            RepositoryService repositoryService = new RepositoryService();
            repositoryService.getClient().setCredentials( login, password );
            CommitService commitService = new CommitService();
            commitService.getClient().setCredentials( login, password );
            DataService dataService = new DataService();
            dataService.getClient().setCredentials( login, password );

            // get some sha's from current state in git
            Repository repository =  repositoryService.getRepository(login, repoName);
            List<RepositoryBranch> branches = repositoryService.getBranches(repository);
            RepositoryBranch theBranch = null;
            RepositoryBranch master = null;
            // Iterate over the branches and find gh-pages or master
            for( RepositoryBranch i : branches ) {
                String theName = i.getName().toString();
                if( theName.equalsIgnoreCase("gh-pages") ) {
                    theBranch = i;
                }
                else if( theName.equalsIgnoreCase("master") ) {
                    master = i;
                }
            }
            if( null == theBranch ) {
                theBranch = master;
            }

            String baseCommitSha = theBranch.getCommit().getSha();
            // create new blob with data

            Random random = new Random();
            Blob blob = new Blob();
            blob.setContent(contentsBase64);
            blob.setEncoding(Blob.ENCODING_BASE64);
            String blob_sha = dataService.createBlob(repository, blob);
            Tree baseTree = dataService.getTree(repository, baseCommitSha);

            // create new tree entry
            TreeEntry treeEntry = new TreeEntry();
            treeEntry.setPath(filename);
            treeEntry.setMode(TreeEntry.MODE_BLOB);
            treeEntry.setType(TreeEntry.TYPE_BLOB);

            treeEntry.setSha(blob_sha);
            treeEntry.setSize(blob.getContent().length());
            Collection<TreeEntry> entries = new ArrayList<TreeEntry>();
            entries.add(treeEntry);
            Tree newTree = dataService.createTree(repository, entries, baseTree.getSha());

            // create commit
            Commit commit = new Commit();
            commit.setMessage( commitMessage );
            commit.setTree(newTree);
            List<Commit> listOfCommits = new ArrayList<Commit>();
            listOfCommits.add(new Commit().setSha(baseCommitSha));
            // listOfCommits.containsAll(base_commit.getParents());
            commit.setParents(listOfCommits);
            // commit.setSha(base_commit.getSha());
            Commit newCommit = dataService.createCommit(repository, commit);

            // create resource
            TypedResource commitResource = new TypedResource();
            commitResource.setSha(newCommit.getSha());
            commitResource.setType(TypedResource.TYPE_COMMIT);
            commitResource.setUrl(newCommit.getUrl());

            // get master reference and update it
            Reference reference = dataService.getReference(repository, "heads/" + theBranch.getName() );
            reference.setObject(commitResource);
            Reference response = dataService.editReference(repository, reference, true) ;

            rv = true;
        }
        catch( IOException ieo ) {
            rv = false;
            ieo.printStackTrace();
        }

        return rv;
    }
}

-----

This class hides the details of the GitHub API, and the specifics of
writing files to Jekyll repositories.

<1> Jekyll posts require that filenames look a very specific way.
Files must be in the `_posts` directory, and should be named with the
date formatted using the formatting string `yyyy-MM-dd` (producing a
string like `2012-12-12`) and then followed by a title all lowercased
and with whitespace replaced by hyphens. The `getFilename()` function
does all this for us, using the first 30 characters of the post body
as a title.
<2> Jekyll files can optionally have YAML Front Matter; we add the
layout and the published flag into the YFM.
<3> As noted above, we convert our content to Base64 using the Apache
foundation helper utility.
<4> We give credit where credit is due: this class was refactored from
a Gist found on GitHub made by a mysterious user named Detelca.

Finally, we can now implement the `doPost()` method inside our
`MainActivity` class.

[source,java]
-----
...
        }
    }

    private void doPost() {
        new PostTask().execute( username, password ); 
    }

    class PostTask extends AsyncTask<String, Void, Boolean> {  

        @Override 
            protected Boolean doInBackground(String... credentials) {
            String username = credentials[0]; 
            String password = credentials[1];

            EditText post = (EditText)findViewById( R.id.post );
            String postContents = post.getText().toString();

            EditText repo = (EditText)findViewById( R.id.repository ); 
            String repoName = repo.getText().toString();

            return GitHubHelpers.SaveFile( username, password, 
                                           repoName, postContents );
        }
        
        @Override
            protected void onPostExecute(Boolean result) {
            TextView status = (TextView)findViewById( R.id.post_status );
            if( result ) {
                status.setText( "Successful jekyll post" );
            }
            else {
                status.setText( "Post failed." ); 
            }
        }
    }


    
-----

Our `doPost()` command now does one thing: instantiates a new
PostTask. As we are performing network operations, we again create a
subclass of `AsyncTask` which handles these operations automatically
on a background thread. We pass in the username and password which we
retrieved earlier along with the post contents and the repository name
we specified. We've isolated our GitHub code into our helper class;
our MainActivity class does only the necessary steps to retrieve items
from UI elements and pass them on to our helper class.

==== Passing our Tests

Now that we have fully implemented our Android application, we can run
our tests.

[source,bash]
----
$ GH_REPO=mytestblog GH_USERNAME=myusername GH_PASSWORD=mypassword bundle exec calabash-android run build/apk/ghru-release-unsigned.apk
----

You'll see them pass with flying colors this time:

image::images/android-calabash-success.png[]

===== Final Notes

This application will allow you to write into a real Jekyll blog,
adding posts, upon which GitHub will regenerate your site. This little
application manages quite a few things: formatting the filename
correctly, encoding the data for submission to GitHub, and all backed
by a simple test to verify functionality. If we had a live Jekyll blog
established, we might consider modifying our test to pull the
generated HTML from our Jekyll site rather than simply looking at a
file stored in the repository. Were we to do this, we would have a
test which verifies the complete end-to-end functionality of our
application. We omitted this extra step here because there is a
waiting process in establishing CNAME records with DNS. Review the
Jekyll chapter for more information.
