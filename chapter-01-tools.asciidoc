== Tools

To use this book, you will need familiarity with some tools that might
be new to you. This book covers the API from various vantage points,
examining the API primarily through the idioms found in many different
languages and their associated client libraries. Each chapter is
designed so that you can follow along without intimacy to the 
language or toolkit. There are two languages and one tool which stand
above the rest which you should actually install and use in order to
get the most out of this book. This chapter documents a minimum set of
tools vital to begin exploring and using the GitHub API.  

These tools are:

* Ruby: a simple, readable programming language used heavily by the
  founders of GitHub 
* NodeJS: JavaScript has been the most ubiquitous web-based client side
  development language for ten years, and NodeJS takes that familiar
  power to the server side, captivating tools authors on GitHub.
* cURL: there are many tools that speak HTTP, but cURL is one of the
  best due to its elegant and useful command line interface that
  matches the minimalist interfaces of the best unix tools.

If you spend a little time installing and familiarizing yourself with
the concepts and practices inherent to these tools, you will have a
solid toolset for exploration of the GitHub API.

Many of you picking up this book already have familiarity with Ruby
or NodeJS. So, the basics and installation of them are in appendices
in the back of the book. If you are new to Ruby or NodeJS, or want a
quick refresh on either of them, please visit the appendices and then
come back to this chapter. We don't spend any time discussing the
syntax of these languages; we expect you have experience with other
languages as a prerequisite and can read imperative code regardless of
the language. These explanatory appendices discuss the history of
these ools within the GitHub story as well as important usage notes
like special files and installation options.

=== cURL: Simple Access to APIs

There are many client libraries which wrap the GitHub API in an
idiomatic interface. These client libraries make your life easier by
removing or limiting your exposure to the complexity of the GitHub
API. But, often you want to quickly access information from the API
without writing a formal program. This is where cURL becomes extremely
handy.

==== API Overview via cURL

The GitHub API is a set of REST services that speak JSON.  Some of
these services are available anonymously without the need for
authentication, while others require a set of credentials.  

.Installing cURL
[NOTE]
If you are running these examples on a Linux box, you should be able
use your native package management tool to install cURL - either a
"sudo yum install curl*" on a RedHat variant or "sudo apt-get
install curl" on an Ubuntu (or Debian) system.  If you are on any
recent version of OSX, you already 
have cURL installed, but it you can't find it, take a look at the
HomeBrew project (http://brew.sh/) or MacPorts project
(http://www.macports.org/).  If you are running on Windows or another
operating system, you best bet is to download cURL from the cURL web
site here: http://curl.haxx.se/download.html 

==== An Introductory API Command

The following cURL command is the simplest command you can use to
retrieve data from the GitHub API. Throughout this chapter, we're going to show a
number of command listings that have been edited help us save space in
the book.   I've left the output of this particular call unedited so
we can walk through the response headers and so you can see how the
GitHub tells you where to look for all of the other services it
provides.

----
$ curl -i https://api.github.com/
HTTP/1.1 200 OK
Server: GitHub.com
Date: Sat, 25 Apr 2015 05:36:16 GMT
Content-Type: application/json; charset=utf-8
Content-Length: 2004
Status: 200 OK
X-RateLimit-Limit: 60
X-RateLimit-Remaining: 58
X-RateLimit-Reset: 1429943754
Cache-Control: public, max-age=60, s-maxage=60
ETag: "a5c656a9399ccd6b44e2f9a4291c8289"
Vary: Accept
X-GitHub-Media-Type: github.v3
X-XSS-Protection: 1; mode=block
X-Frame-Options: deny
Content-Security-Policy: default-src 'none'
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: ETag, Link, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval
Access-Control-Allow-Origin: *
X-GitHub-Request-Id: C0F1CF9E:567A:9610FCB:553B27D0
Strict-Transport-Security: max-age=31536000; includeSubdomains; preload
X-Content-Type-Options: nosniff
Vary: Accept-Encoding
X-Served-By: 13d09b732ebe76f892093130dc088652
----

Let's do a quick walkthrough of this response.  The first thing we
see is a response code.  In this case, our response code is 200 which
signals to us that the request was a success.  Later in this chapter
you will see how GitHub uses other response codes such as HTTP 304 to
send signals to a client.   After the response code, you'll see other
standard headers one would expect in any HTTP response such as the
server sending the response, the date of the response, the Status
header, the Content-Length, and the Content-Type of the response.

Three headers are present in every GitHub API response which tell you
about the GitHub API rate limits.  They are X-RateLimit-Limit,
X-RateLimit-Remaining, and X-RateLimit-Reset.   These limits are
explained in detail in <<developer-api-rates>>.

The X-GitHub-Media-Type header contains information that will come in
handy when you are starting to retrieve text or blob content from the
API.  when you make a request to the GitHub API you can specify the
format you want to work with by sending an Accept header with your request.

After the HTTP response headers shown above, the root directory of the
GitHub API helpfully returns a JSON document listing all of the
services available via the GitHub API.  You can print this out and use
it as a map to the GitHub API.  

----
{
  "current_user_url": "https://api.github.com/user",
  "current_user_authorizations_html_url": "https://github.com/settings/connections/applications{/client_id}",
  "authorizations_url": "https://api.github.com/authorizations",
  "code_search_url": "https://api.github.com/search/code?q={query}{&page,per_page,sort,order}",
  "emails_url": "https://api.github.com/user/emails",
  "emojis_url": "https://api.github.com/emojis",
  "events_url": "https://api.github.com/events",
  "feeds_url": "https://api.github.com/feeds",
  "following_url": "https://api.github.com/user/following{/target}",
  "gists_url": "https://api.github.com/gists{/gist_id}",
  "hub_url": "https://api.github.com/hub",
  "issue_search_url": "https://api.github.com/search/issues?q={query}{&page,per_page,sort,order}",
  "issues_url": "https://api.github.com/issues",
  "keys_url": "https://api.github.com/user/keys",
  "notifications_url": "https://api.github.com/notifications",
  "organization_repositories_url": "https://api.github.com/orgs/{org}/repos{?type,page,per_page,sort}",
  "organization_url": "https://api.github.com/orgs/{org}",
  "public_gists_url": "https://api.github.com/gists/public",
  "rate_limit_url": "https://api.github.com/rate_limit",
  "repository_url": "https://api.github.com/repos/{owner}/{repo}",
  "repository_search_url": "https://api.github.com/search/repositories?q={query}{&page,per_page,sort,order}",
  "current_user_repositories_url": "https://api.github.com/user/repos{?type,page,per_page,sort}",
  "starred_url": "https://api.github.com/user/starred{/owner}{/repo}",
  "starred_gists_url": "https://api.github.com/gists/starred",
  "team_url": "https://api.github.com/teams",
  "user_url": "https://api.github.com/users/{user}",
  "user_organizations_url": "https://api.github.com/user/orgs",
  "user_repositories_url": "https://api.github.com/users/{user}/repos{?type,page,per_page,sort}",
  "user_search_url": "https://api.github.com/search/users?q={query}{&page,per_page,sort,order}"
}
----

Any of these service URLs can be used with the cURL tool to pull more specific information from the GitHub API. For example, if we wanted to know more about the "github" organization, we could use the following cURL command:

----
$ curl https://api.github.com/orgs/github
{
  "login": "github",
  "id": 9919,
  "url": "https://api.github.com/orgs/github",
  "repos_url": "https://api.github.com/orgs/github/repos",
  "events_url": "https://api.github.com/orgs/github/events",
  "members_url": "https://api.github.com/orgs/github/members{/member}",
  "public_members_url": "https://api.github.com/orgs/github/public_members{/member}",
  "avatar_url": "https://avatars.githubusercontent.com/u/9919?v=3",
  "description": "GitHub, the company.",
  "name": "GitHub",
  "company": null,
  "blog": "https://github.com/about",
  "location": "San Francisco, CA",
  "email": "support@github.com",
  "public_repos": 106,
  "public_gists": 0,
  "followers": 0,
  "following": 0,
  "html_url": "https://github.com/github",
  "created_at": "2008-05-11T04:37:31Z",
  "updated_at": "2015-04-25T05:17:01Z",
  "type": "Organization"
}
----

We've removed the `-i` switch from the cURL command so that we no
longer see the headers. We took the URL named "organization_url" and
added the parameter of "github" (replacing the {org} placeholder) to
generate the full URL to the GitHub organization. You can see this
tells us the company blog (https://github.com/about), that the company
is located in San Francisco, and the creation date (which strangely
does not match their blog post which states April 10th was their
official launch date [https://github.com/blog/40-we-launched]). 

===== Why Learn About cURL?

cURL is a great tool for exploring the API. It has a simple interface,
and you can easily write shell scripts which wrap cURL and create a
more complex workflow of requests. cURL, like the HTTP protocol which
it speaks intimately, is a stateless tool, meaning it is challenging
to use cURL only to hit a URL and then use the results to hit a
secondary URL. For this reason, you'll find (and we'll document) how
to use other client libraries to access the GitHub API, as you will
often need to use the resulant response from an initial request to
seed the next response in a long chain of requests and responses. But,
cURL is a great tool for getting to the bare request and seeing
everything behind a request. Anything that you do with a client
library can be done with cURL, and often cURL can be used to confirm
that something works the way you expect it to. Client libraries make
it easy to access these APIs, but they can hide information useful to
debugging. cURL provides an alternative viewpoint to the GitHub API
and the data it exposes, and no matter what client library you use,
cURL is a great complementary tool.

=== Authenticated GitHub API Access

All of the prior examples were performed without authentication into
GitHub. Accessing private information stored inside GitHub requires
authentication. There are two ways to authenticate when using the
GitHub API: raw username/passwords combinations and oAuth tokens. 

==== Username and Password

Using a username and password to retrieve protected information from
the GitHub API is easy and works with any HTTP client that speaks HTTP
authentication. 

* No scoping
* Insecure to ask user to provide user/pw. 
** Will they store it? Will
** they properly delete it when asked?

Proper use of user/pwd is only when you are accessing the API yourself.

==== oAuth

The right way, but more difficult.

All GitHub applications require oAuth.

===== Scopes

Each component, as described above, creates a scope. When your
application asks for access to a user's data, you provide a
scope. This gives users clarity on what information you will be
reading, and gives them better control over how their information is
used, and whether they want to provide this information.

===== Scope Limitations

* Cannot do fine-grained access to certain repositories only.
* Some information requires granting scope to user object, but is not
* really necessary

Beware when you ask for a scope; users will evaluate your application
based on the scopes requested; if they don't think you need that
scope, 

===== Scope Escalation

You can ask for scope at one point which is very limited, and then
later ask for a greater scope. For example, when a user first accesses
your application, you could only get the user scope to create a user
object inside your service, and only when your application needs
repository information for a user, then request to escalate
privileges. At this point the user will need to approve or disapprove
your request, but asking for everything up front (before you have a
relationship with the user) often results in a user abandoning the login.

[[developer-api-rates]]
==== GitHub API Rate Limits

GitHub tries to limit the rate at which users can make requests to the
API.  Anonymous requests, requests that haven't authenticated with
either a username/password or OAuth information, are limited to 60
requests an hour. If you are developing a system to integrate with the
GitHub API on behalf of users, clearly 60 requests per hour isn't
going to be sufficient.

This rate limit is increased to 5000 requests per hour if you are
making an authenticated request to the GitHub API, and while this rate
is two orders of magnitude larger than the anonymous rate limit, it
still presents problems if you intend to use your own GitHub
credentials when making requests on behalf of many users.

For this reason, if your web site or service uses the GitHub API to
request information from the GitHub API, you should consider using
OAuth and make requests to the GitHub API using your user's shared
authentication information. 

[NOTE]
There are actually two rate limits.  The "core" rate limit and the
"search" rate limit.  The rate limits explained in the previous
paragraphs were for the core rate limit.  For search,
requests are limited at 20 requests per minute for authenticated user
requests and 5 request per minute for anonymous requests. The
assumption here is that search is a more infrastructure intensive
request to satisfy and that tighter limits are placed on its usage.

==== Reading Your Rate Limits
Reading your rate limit is straightforward, just make a GET request to
/rate_limit.  This will return a JSON document which tells you the
limit you are subject to, the number of requests you have remaining,
and the timestamp (in seconds since 1970).  Note that this timestamp
has a timezone in Coordinated Universal Time (UTC).

The following command listing uses curl to retrieve the rate limit
for an anonymous request.   This response is abbreviated to save space
in this book, but you'll notice that the quota information is supplied
twice: once in the HTTP response headers and again in the JSON
response.  The rate limit headers are returned with every request to
the GitHub API, so there is little need to make a direct call to the
/rate_limit API.

----
$ curl -i https://api.github.com/rate_limit
HTTP/1.1 200 OK
X-RateLimit-Limit: 60
X-RateLimit-Remaining: 60
X-RateLimit-Reset: 1376252013

{
  "rate": {
    "limit": 60,
    "remaining": 60,
    "reset": 1376252013
  }
}
----

60 requests over the course of an hour isn't very much, and if
you plan on doing anything interesting, you will likely exceed this
limit quickly. If you are hitting up against the 60 requests per
minute limit, you will likely want to investigate making authenticated
requests to the GitHub API.

The following command listing uses curl to retrieve the rate limit for
an authenticated request.  Again, you will note that the rate limit
information is present in both the response body and the HTTP response
headers.

----
$ curl -i -u tobrien https://api.github.com/rate_limit
Enter host password for user 'tobrien': xxxxxxxx
HTTP/1.1 200 OK
X-RateLimit-Limit: 5000
X-RateLimit-Remaining: 4995
X-RateLimit-Reset: 1376251941

{
  "rate": {
    "limit": 5000,
    "remaining": 4995,
    "reset": 1376251941
  }
}
----

[NOTE]
Calls to the Rate Limit API are not deducted from your Rate Limit.
Isn't that nice of them?

===== Conditional Requests to Avoid Rate Limits

If you are querying the GitHub APIs to obtain activity data for a user
or a repository, there's a good chance that mamy of your requests
won't return much activity.  If you check for new activity once every
few minutes, there will be time periods over which no activity has
occurred.  These requests, these constant polls still use up requests
in your rate limit even though there's no new activity to be
delivered.

In these cases, you can send conditional HTTP headers
If-Modified-Since and If-None-Match to tell GitHub to return an HTTP
304 response code telling you that nothing has been modified.  When
you send a request with a conditional header and the GitHub API responds
with a HTTP 304 response code, this request is not deducted from your
rate limit.

The following command listing is an example of passing in the
If-Modified-Since HTTP header to the GitHub API.   Here we've
specified that we're only interested in receiving content if the
Twitter Boostrap repositories has been altered after 7:49 PM GMT on
Sunday, August 11, 2013.  The GitHub API responds with a HTTP 304
response code which also tells us that the last time this repository
changed was a minute earlier than our cutoff date.

----
$ curl -i https://api.github.com/repos/twbs/bootstrap \
          -H "If-Modified-Since: Sun, 11 Aug 2013 19:48:59 GMT"
HTTP/1.1 304 Not Modified
Server: GitHub.com
Date: Sun, 11 Aug 2013 20:11:26 GMT
Status: 304 Not Modified
X-RateLimit-Limit: 60
X-RateLimit-Remaining: 46
X-RateLimit-Reset: 1376255215
Cache-Control: public, max-age=60, s-maxage=60
Last-Modified: Sun, 11 Aug 2013 19:48:39 GMT
----

The GitHub API also understands HTTP caching tags. An ETag, or Entity Tag, is an HTTP
header that is used to control whether or not content that you have
previously cached is the most recent version.  Here's how your systems
would use ETag:

. Your server requests information from an HTTP server.

.  Server returns an ETag header for a version of a content item.

. Your server includes this ETag in all subsequent requests.

.. If the server has a newer version it returns new content + a new
   ETag

.. If the server doesn't have a newer version it returns an HTTP 304

The following command listing demonstrates to commands.  The first
curl call to the GitHub API generates an ETag value, and the second
value passes this ETag value as an If-None-Match header.  You'll note
that the second response is an HTTP 304 which tells the caller that
there is no new content available.

----
$ curl -i https://api.github.com/repos/twbs/bootstrap
HTTP/1.1 200 OK
Cache-Control: public, max-age=60, s-maxage=60
Last-Modified: Sun, 11 Aug 2013 20:25:37 GMT
ETag: "462c74009317cf64560b8e395b9d0cdd"

{
  "id": 2126244,
  "name": "bootstrap",
  "full_name": "twbs/bootstrap",
  ....
}

$ curl -i https://api.github.com/repos/twbs/bootstrap \
          -H 'If-None-Match: "462c74009317cf64560b8e395b9d0cdd"' 

HTTP/1.1 304 Not Modified
Status: 304 Not Modified
Cache-Control: public, max-age=60, s-maxage=60
Last-Modified: Sun, 11 Aug 2013 20:25:37 GMT
ETag: "462c74009317cf64560b8e395b9d0cdd"
----

If you are developing an application that needs to make a significant
number of requests to the GitHub API over a long period of time, you
can use a caching HTTP proxy like Squid to take care of automatically
caching content, storing content alongside ETags, and injecting the
"If-None-Match" header into GitHub API requests. If you do this,
you'll be automating the injection of conditional headers and helping
to reduce the overall load on the GitHub API. If you use an API
library, like Octokit for Ruby, there are some tricks we'll detail
later which can assist in staying beneath the limits.

Use of conditional request headers is encouraged to conserve resources
and make sure that the infrastructure that supports GitHub's API isn't
asked to generated content unnecessarily.

[developer-api-accept]
==== Specifying Response Content Format

When you send a request to the GitHub API, you have some ability to
specify the format of the response you expect.  For example, if you
are requesting content that contains text from a commit's comment
thread, you can use the Accept header to ask for the raw markdown or
for the HTML this markdown generates.  You also have the ability to
specify this version of the GitHub API you are using if there is a new
version in beta. 

To demonstrate the specification of the Accept header, let's take a
look at what happens when we request something without the Accept
header:

----
$ curl -i https://api.github.com/
Content-Type: application/json; charset=utf-8
X-GitHub-Media-Type: github.v3
----

==== Specifying alternative formats

TODO

Besides "raw" and "html" there are two other format options that
influence how Markdown content is delivered via the GitHub API.  If
you specify "text" as a format, the issue body would have been
returned as plaintext.   If you specify "full" then the content will
be rendered multiple times including the raw Markdown, rendered HTML,
and rendered plaintext.

In addition to controlling the format of text content, you can also
retrieve GitHub blobs either as raw binary or as a BASE64 encoded
text.   When retrieving commits, you can also specify that the content
be returned either as a diff or as a patch.  For more information
about these fine-grained controls for formatting, see the GitHub API
documentation here: http://developer.github.com

=== Exploring Account Security

==== Reseting Your Password

To change your password, click on the "Accounting settings" icon at the top right corner within GitHub. You will be taken to the "Profile" section of the account settings; click on the "Account Settings" item within the list on the left and you will see a form in which you can enter a new password and confirmation, plus the old password. If you enter these correctly you will update your password on GitHub.

image::images/creating-account-change-password.png[]

Remember: if you are using HTTPS (instead of SSH) with your GitHub clients (meaning, the programs you use to access files within GitHub, like GitHub for Mac or GitHub for Windows), changing your password on GitHub will mean you need to update your password within those clients as well. If you are using SSH to access files on GitHub (you have setup public/private SSH keys) then you can change your password without worry. We detail this distinction and how to handle setting things up below.

==== Using 2 Factor Authentication

GitHub takes the "octocat" as its mascot, and not so surprisingly their technologies have crept like tentacles into many other sites. One example is the availability of "Login via GitHub" buttons, which permit a third-party site to delegate login and credentialing to GitHub using a technology called oAuth. Less technically, a site can ask users to login on the GitHub site, and then ask GitHub to validate that user's identity and then provide access to the services of the third-party site. When third party sites start trusting GitHub for authentication, it becomes more and more important to protect the credibility of a GitHub login. For various reasons, protecting access with a username and passwords is often an easy attack vector. And, for this reason, GitHub offers, like many other sites offering login services for third party sites, what is commonly referred to as "two factor authentication."

If you are not using two factor authentication on your GitHub account, the theft of your username and password is all that is required to break into your account. And, if you have logged into any other sites using GitHub's login delegation services, then those accounts are as good as compromised as well when someone breaks into your GitHub account. 

Two factor authentication simply means that login to GitHub can require two different unconnected methods of authentication to prove you are who you say you are. If you have enabled two factor authentication, an attacker cannot access your GitHub account with only your username and password. The first time you login to GitHub with two-factor authentication enabled, you will start by entering in the username and password. After this GitHub will, typically, send you a text message with a special one time code required to complete the login process. Without this code, the username and password do no good to a malicious attacker. 

It can be easy to steal a username and password through brute force attacks, or due to the fact that many people reuse passwords across different accounts (so when one is compromised an attacker can start testing the password on any other account the person might own), or even good old fashioned social hacking where a person is tricked into revealing their password over the phone or inside an cleverly worded email. All of these attacks can made on the other side of the world. But, it is much harder for a hacker to obtain physical access to your cell phone, especially when they are halfway around the world. Two factor authentication does not completely prevent unauthorized access to your GitHub account, but it reduces the chances monumentally. 

Spend the time to enable two factor authentication on your GitHub account. It only takes a minute to set up, and the piece of mind is worth it.

==== SSH vs HTTPS

There are two transport options for loading code from GitHub: SSH and HTTPS.

Actually, at the time of this writing there are really three protocols: SSH, 
HTTPS and Subversion. Subversion is there for backwards compatibility with older 
workflows, and actually just maps the SVN protocol on top of Git. The only reason
you would use Subversion with GitHub is that you work in an organization that
requires use of Subversion but also wants to host their code on GitHub. If you work
for such an schizophrenic organization, you might want to start looking for another job right 
away.

Both HTTPS and SSH operate over a secure encrypted channel, but beyond this commonality 
there are very different reasons for using each.

Of the two, SSH is the more secure option. If you are willing to tackle the slight complexity that comes with using SSH, we recommend it. If not, use HTTPS. GitHub recommends HTTPS as their preferred method, but we differ in believing that you'll rest more easily in the long run if you take the trouble to set up SSH access.

===== HTTPS

The only reason you might be unable to use SSH and have no option other than HTTPS is that this protocol can be useful if you are
inside a very restrictive firewall.
HTTPS traffic is almost always permitted (port 443 is a common "secure" port on almost 
any firewall). If you use HTTPS, the "git clone" command will use a URL which starts 
with https://. For example, to load the Ruby on Rails repository from GitHub you would 
use the command `git clone https://github.com/rails/rails.git`.

===== HTTPS Downsides

When you use the HTTPS protocol, note that you will need to enter in
your password to authenticate. The command line git client (which might be what your
editor is using underneath the graphical interface you use to code) does not
have an ability to cache this password. This means each time you push code, or pull 
the latest changes, you will need to re-enter your password. Git is a protocol which 
supports making lots of little changes, so a requirement that you must add another ten 
seconds to your workflow makes HTTPS quickly unusable. GitHub has released a Ruby gem called "hub"
which you can alias in your shell so that when typing "git" your shell actually uses the ruby gem client instead of the native 
command line client; this ruby gem client can cache and use HTTPS passwords. But, this requires
additional setup, convolutes your workflow, and SSH still offers more benefits. 

HTTPS is also a less efficient protocol for transferring files; cloning and interacting with 
repositories using HTTPS is slower for you. 

The only real benefit for HTTPS is for server administrators: it 
is easier to configure a server to provide HTTPS to git repositories than it is to provide those
repositories over SSH. GitHub is doing the work of hosting your git repositories for you, however, so this is not a compelling reason to consider HTTPS.

===== SSH 

SSH offers the same level of security but is much more convenient, more flexible and 
keeps access more secure. You will notice that GitHub offers SSH as the default protocol.

At the center of SSH is a concept called asymmetric cryptography also called 
public key cryptography. To use SSH you generate a public/private keypair. Then, you 
upload the public key into GitHub. You keep the private key on your machine, and 
you keep it private (meaning, don't send it over email, or post it on Facebook).

===== A brief tutorial on using SSH keys

If using SSH sounds complicated, don't fret. To generate a public/private keypair, 
you just need to run this command from a terminal:

[source,bash]
$ ssh-keygen 
Generating public/private rsa key pair.
Enter file in which to save the key (/Users/xrdawson/.ssh/id_rsa): 
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 

This generates two files, a file called ~/.ssh/id_rsa and another called ~/.ssh/id_rsa.pub. 
The first file is the private file and the second (ending with a suffix abbreviation of the word "public") is the public file. 

You will be asked if you want to enter a passphrase which protects usage of your keypair. If
you believe your machine is secure (for example, this is a laptop which uses fingerprint 
recognition to unlock the screen), then you can hit enter and not protect your private key
with a passphrase. If the key is sitting in a less secure position, such as a server on the 
Internet, then you might want to protect the key with a passphrase. If you lose the passphrase, 
you cannot use the key. However, replacing a key is an easy problem to rectify.

===== Putting your SSH public key on GitHub 

To store an SSH public key on GitHub, copy the key contents into your clipboard. On an OSX machine, you 
could use this command:

[source,bash]
$ cat ~/.ssh/id_rsa.pub
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDG56LecqP2ip/odHzAkM3F/TyL5TjS0m6bNEo3p+m7KEU/eJ+ZvrF1/4ALPk59+Ca2NtOwewVs1RZNuV9BuMesTHFAxev6Zx4R56fwL45UuDm1gjpwevxwHe8aS0elek94OcgxYomnnnmB4Og/OIbVYICfaQ4VhE+xVVOF/TXIGkndZG/wBLFg9QwPTQKhOIgVDoTzdj0FZ9qXfhvc7AhGkeOAO+dyeNgfk8ghzRPqyztd14tq6gOVPAMce3mGQsugbcKxgRBbd/7VaWT5hQl5YVtLlcAvM1gHgvU8MNVhrJTKzZxlTNBVBnYy1QxPtB3LF25YL7jAjtMYkuEjmZff xrdawson@Chriss-MacBook-Pro-2.local

Select everything from the "ssh-rsa" to and including the "xrdawson@Chriss-MacBook-Pro-2.local" (which is the name of my MacBook Pro) and then copy it to your clipboard. Then, go to GitHub, click on the "Account Settings" button:

image::images/account-settings.png[]

Then, click on the "SSH" item in the navigation bar on the left. You'll see a list of SSH keys already in the system. You might not have any if you just setup your account. In my account, I have many SSH keys.

image::images/ssh-keylist.png[]

As you can see, I have a key for my OSX Laptop. I have another key for an Ubuntu server I manage, a server which has a user which has access to my repositories. Then, I have another server, this time running on Amazon Web Services, which also has access to my repositories. I have an Android device which has access, as well as a Chromebook running developer mode that has access to my GitHub repositories. Finally, I have a virtual machine (using Vagrant) on my OSX laptop, and this machine has its own access. 

To add your key, click on the "Add SSH Key" button at the very top right of the list of SSH keys. This action will open a form underneath into which you can choose a title for the SSH key and then the contents which you copied to the clipboard. Once the form looks something like this you can click the "Add Key" button.

image::images/ssh-add-key.png[]

===== The big reason why SSH trumps HTTPS

If you takeaway one thing about why SSH is better than HTTPS, let it be this: both HTTPS and SSH make
it easy to add access to your repositories. However, HTTPS makes it really hard to revoke that
access.

With HTTPS managing and securing access to your repository becomes *your* problem. With SSH, 
secure access is *GitHub's* problem. And, they've been thinking about the right ways to do this: 
from requiring re-entry of your password whenever a new SSH public key is added, 
to two factor authentication (utilizing email and your cell phone to verify your identity), GitHub has spent lots of time and money making sure your source code is protected from rogue access.

