== Commit Status

- What this API does
- how it shows up in the UI (screenshot or two)
- Typical uses (CI)
- Atypical uses (CLA bot, others?)

Git repositories are essentially a series of commits.
Each commit contains quite a bit of information: the contents of the source files, who created the commit and when, the author's comments on what changes the commit introduces, and so on.
GitHub's commit-status API adds another layer of metadata to a commit: what various services _say_ about that commit.

This capability primarily shows itself in the pull-request UI, as shown in <<status_pr>>.
Each commit in the pull request is annotated with a symbol indicating its status - a red "&#xd7;" for failure or error, a green "&#x2713;" for success, or an amber "&#x2022;" for pending.
This feature also surfaces at the bottom of the pull-request; if the last commit in the branch is not marked as successful, you get a warning about merging the request. 

[[status_pr]]
.Commit status in the pull-request UI
image::images/commit-status-ui.png[Commit status in the pull-request UI]

As you'd expect, this is most useful for a continuous-integration service.
A program like Jenkins will get a notification when new commits are pushed to a branch, run a build/test cycle using the new code, and post the results through the commit-status API.
An application like this can even include a link back to the build results, so the user can find out which tests failed.

Building and testing is only the beginning, though.
Open-source projects often have a license agreement that you must sign in order to submit a contribution.
These are called "contributor license agreements," and usually contain language about licensing the contribution to the maintainers of the project.
But it's tedious to check every incoming pull request to see if the author has signed the CLA, so a continuous-integration-style service can be used for this.
CLAHub is one such example: it checks to see if all of the authors of the contained commits have signed the CLA, and marks the latest commit as "error" if not.

=== The API

This capability is powered mainly by services that do _not_ belong to GitHub itself, all of which are using an API to create status updates for commits.
In addition to this, the repositories whose commits are being marked generally belong neither to the service nor GitHub, but another entirely separate person.
This is all accomplished through OAuth.

The commit-status API uses the `repo:status` scope, which allows read and write access to commit statuses *without* access to the rest of the contents of the repository.
This scope is contained within the `repo` scope, so if the application already has that level of access it will also be able to work with statuses.

==== Raw statuses

Commit statuses exist as atomic entities, and each commit can have a practically unlimited number of them (the actual number is in the thousands).
You can query for existing statuses by doing a GET request to the API server at `/repos/<user>/<repo>/<ref>/statuses`, and it will return a list of them that looks like this: 

[source,json]
----
[
  {
    "url": "https://api.github.com/repos/…",
    "id": 224503786,
    "state": "success",
    "description": "The Travis CI build passed",
    "target_url": "https://travis-ci.org/libgit2/libgit2/builds/63428108",
    "context": "continuous-integration/travis-ci/push",
    "created_at": "2015-05-21T03:11:02Z",
    "updated_at": "2015-05-21T03:11:02Z"
  },
  …
]
----

Most of this is self-explanatory, but a couple of fields need explaining.
The `state` field can be "success," "failure," "error," or "pending," depending on the state of the service's decision.
The `target_url` is a URL for the specific decision made for this commit (in this case a build/test log).
And the `context` parameter is used for correlating multiple status updates to a single service.

This is useful for getting the raw data involved, but it gets complicated quickly.
How do you decide if a given commit is "good?"
What if there are (in this order) 3 pending statuses, one success, another pending, two failures, and another success?
The `context` field can help you correlate a single service's updates, and you can order them by date to see how each one turned out, but that's a lot of work.
Fortunately, the API server can do it for you.

==== Combined status

If you instead do a GET to `/repos/<user>/<repo>/<ref>/status` (note the last word), you'll instead get a response that looks like this:

[source,json]
----
{
  "state": "success",
  "statuses": [
    {
      "url": "https://api.github.com/repos/…",
      …
    },
    { … }
  ],
  "sha": "6675aaba883952a1c1b28390866301ee5c281d37",
  "total_count": 2,
  "repository": { … },
  "commit_url": "https://api.github.com/repos/…",
  "url": "https://api.github.com/repos/…"
}
----

The `statuses` array contains the very last status update for each context that has submitted them, and the `state` field contains an overall status that takes into account all of the contexts.
Its value is:

- `failure` if any of the contexts posted a `failure` or `error` state
- `pending` if any of the contexts' latest state is `pending` (or if there are no statuses)
- `success` if the latest status for every context is `success`

That's probably useful for most situations.
If you find that your use case calls for different rules, you can always use the `statuses` endpoint to get the raw data and make your own combined status.

=== Let's write an app

How about a live example?
In this chapter, we'll build a simple HTTP service that lets you read and write commit statuses for repositories you have access to.
This system won't be super useful on its own, but if you ever have another service that needs to post commit statuses, you could hand it off to this one.

The language this time is C#, running on the CLR (Common Language Runtime).
At one point in the history of computing this wouldn't have been a good choice for a book like this, since it was only available on Windows.
However, with the advent of Mono (an open-source implementation of the .NET runtime), the open-sourcing of the CLR core, and the availability of free development tools, C# is now a completely valid option for open-source or hobby developers.

==== Requirements

To follow along with this example, you'll need to install a development environment.

If you're running Windows, you'll want to visit https://www.visualstudio.com/[] and download the Community edition of Visual Studio.
Note that Visual Studio has lots of capabilities; for this example, we'll only need the "web developer" components.
(If you have access to a higher tier of VS, or already have it installed, that will work as well.)

On OS X and Linux, as of this writing the easiest way forward is to visit http://www.monodevelop.com/[] and install MonoDevelop.
Mono is an open-source implementation of Microsoft's CLR specification, and MonoDevelop is a development environment that works much like Visual Studio, but is built on Mono, and is completely open-source.
If you try to download MonoDevelop on a Windows or OS X machine, you'll be prompted to install Xamarin Studio instead; this is a newer version of MonoDevelop with more capabilities, and will work just as well for these examples.

==== Libraries

You'll be happy to find out that we won't be writing an entire HTTP server from scratch.
There are a number of open-source packages that do this work for us, and for this project we'll be using Nancy.
Nancy is a project that started as a CLR port of the Sinatra framework for Ruby, and takes its name from Frank Sinatra's daughter Nancy Sinatra.
It's very capable, but also very succinct, as you'll see.

We also won't be directly implementing access to the GitHub API, because GitHub provides a CLR library for that.
It's called octokit.net, and it does all the right things with regard to asynchronicity and type safety.
This is the same library used by the GitHub client for Windows, so it'll definitely do the job for our little application.

==== Initial setup

On Visual Studio, you'll want to install a plugin to make this process smoother – the Nancy project templates.
Visit https://visualstudiogallery.msdn.microsoft.com/[] and search for "nancy.templates".
The 

==== OAuth flow
==== Endpoint handlers

=== Summary

