== Commit Status

- What this API does
- how it shows up in the UI (screenshot or two)
- Typical uses (CI)
- Atypical uses (CLA bot, others?)

Git repositories are essentially a series of commits.
Each commit contains quite a bit of information: the contents of the source files, who created the commit and when, the author's comments on what changes the commit introduces, and so on.
GitHub's commit-status API adds another layer of metadata to a commit: what various services _say_ about that commit.

This capability primarily shows itself in the pull-request UI, as shown in <<status_pr>>.
Each commit in the pull request is annotated with a symbol indicating its status - a red "&#xd7;" for failure or error, a green "&#x2713;" for success, or an amber "&#x2022;" for pending.
This feature also surfaces at the bottom of the pull-request; if the last commit in the branch is not marked as successful, you get a warning about merging the request. 

[[status_pr]]
.Commit status in the pull-request UI
image::images/commit-status-ui.png[Commit status in the pull-request UI]

As you'd expect, this is most useful for a continuous-integration service.
A program like Jenkins will get a notification when new commits are pushed to a branch, run a build/test cycle using the new code, and post the results through the commit-status API.
An application like this can even include a link back to the build results, so the user can find out which tests failed.

Building and testing is only the beginning, though.
Open-source projects often have a license agreement that you must sign in order to submit a contribution.
These are called "contributor license agreements," and usually contain language about licensing the contribution to the maintainers of the project.
But it's tedious to check every incoming pull request to see if the author has signed the CLA, so a continuous-integration-style service can be used for this.
CLAHub is one such example: it checks to see if all of the authors of the contained commits have signed the CLA, and marks the latest commit as "error" if not.

=== The API

This capability is powered mainly by services that do _not_ belong to GitHub itself, all of which are using an API to create status updates for commits.
In addition to this, the repositories whose commits are being marked generally belong neither to the service nor GitHub, but another entirely separate person.
This is all accomplished through OAuth.

The commit-status API uses the `repo:status` scope, which allows read and write access to commit statuses *without* access to the rest of the contents of the repository.
This scope is contained within the `repo` scope, so if the application already has that level of access it will also be able to work with statuses.

==== Raw statuses

Commit statuses exist as atomic entities, and each commit can have a practically unlimited number of them (the actual number is in the thousands).
You can query for existing statuses by doing a GET request to the API server at `/repos/<user>/<repo>/<ref>/statuses`, and it will return a list of them that looks like this: 

[source,json]
----
[
  {
    "url": "https://api.github.com/repos/…",
    "id": 224503786,
    "state": "success",
    "description": "The Travis CI build passed",
    "target_url": "https://travis-ci.org/libgit2/libgit2/builds/63428108",
    "context": "continuous-integration/travis-ci/push",
    "created_at": "2015-05-21T03:11:02Z",
    "updated_at": "2015-05-21T03:11:02Z"
  },
  …
]
----

Most of this is self-explanatory, but a couple of fields need explaining.
The `state` field can be "success," "failure," "error," or "pending," depending on the state of the service's decision.
The `target_url` is a URL for the specific decision made for this commit (in this case a build/test log).
And the `context` parameter is used for correlating multiple status updates to a single service.

This is useful for getting the raw data involved, but it gets complicated quickly.
How do you decide if a given commit is "good?"
What if there are (in this order) 3 pending statuses, one success, another pending, two failures, and another success?
The `context` field can help you correlate a single service's updates, and you can order them by date to see how each one turned out, but that's a lot of work.
Fortunately, the API server can do it for you.

==== Combined status

If you instead do a GET to `/repos/<user>/<repo>/<ref>/status` (note the last word), you'll instead get a response that looks like this:

[source,json]
----
{
  "state": "success",
  "statuses": [
    {
      "url": "https://api.github.com/repos/…",
      …
    },
    { … }
  ],
  "sha": "6675aaba883952a1c1b28390866301ee5c281d37",
  "total_count": 2,
  "repository": { … },
  "commit_url": "https://api.github.com/repos/…",
  "url": "https://api.github.com/repos/…"
}
----

The `statuses` array contains the very last status update for each context that has submitted them, and the `state` field contains an overall status that takes into account all of the contexts.
Its value is:

- `failure` if any of the contexts posted a `failure` or `error` state
- `pending` if any of the contexts' latest state is `pending` (or if there are no statuses)
- `success` if the latest status for every context is `success`

That's probably useful for most situations.
If you find that your use case calls for different rules, you can always use the `statuses` endpoint to get the raw data and make your own combined status.

=== Let's write an app

How about a live example?
In this chapter, we'll build a simple HTTP service that lets you create commit statuses for repositories you have access to, using the OAuth web flow for authorization.
The system we'll build will be fairly limited in scope, but it's a great starting point for customizing to your specific needs.

The language this time is C#, running on the CLR (Common Language Runtime).
At one point in the history of computing this wouldn't have been a good choice for a book like this, since it was only available on Windows, and the language and libraries were fairly limited.
However, with the advent of Mono (an open-source implementation of the .NET runtime), the open-sourcing of the CLR core, and the availability of free development tools, C# is now a completely valid option for open-source or hobby developers.

==== Requirements

To follow along with this example, you'll need to install a development environment.

If you're running Windows, you'll want to visit https://www.visualstudio.com/[] and download the Community edition of Visual Studio.
Note that Visual Studio has lots of capabilities; for this example, we'll only need the "web developer" components.
(If you have access to a higher tier of VS, or already have it installed, that will work as well.)

On OS X and Linux, as of this writing the easiest way forward is to visit http://www.monodevelop.com/[] and install MonoDevelop.
Mono is an open-source implementation of Microsoft's CLR specification, and MonoDevelop is a development environment that works much like Visual Studio, but is built on Mono, and is completely open-source.
If you try to download MonoDevelop on a Windows or OS X machine, you'll be prompted to install Xamarin Studio instead; this is a newer version of MonoDevelop with more capabilities, and will work just as well for these examples.

==== Libraries

You'll be happy to find out that we won't be writing an entire HTTP server from scratch.
There are a number of open-source packages that do this work for us, and for this project we'll be using Nancy.
Nancy is a project that started as a CLR port of the Sinatra framework for Ruby, and takes its name from Frank Sinatra's daughter Nancy Sinatra.
It's very capable, but also very succinct, as you'll see.

We also won't be directly implementing access to the GitHub API, because GitHub provides a CLR library for that.
It's called octokit.net, and it does all the right things with regard to asynchronicity and type safety.
This is the same library used by the GitHub client for Windows, so it'll definitely do the job for our little application.



==== Following along

If you'd like to follow along with the code examples, here's how to set up a project with all the necessary elements.

===== Visual Studio

In order to make things just a little smoother, you'll want to install a plugin: the Nancy project templates.
Visit https://visualstudiogallery.msdn.microsoft.com/[] and search for "nancy.templates".
As of this writing, there appears to be some difficulty with file formats, so when you download it, it comes as a ZIP file.
If this has been resolved by the time you're reading this, simply double-click the file to install the templates; if not, you'll have to rename it to have a `.vsix` extension first.

The next step is to create a new project using one of the newly-installed templates.
Go to "File>New Project…" and select "Visual C#>Web>Nancy Application with ASP.NET Hosting" from the template list (as shown in <<vs_new_project>>.
Make sure the path and name settings at the bottom are to your liking, and click OK.

[[vs_new_project]]
.Creating a Nancy application in Visual Studio
image::images/vs-new-project.png[]

The next step is to change the target CLR framework version to something that will build Octokit.
Right-click on the project's node in the Solution Explorer, and select "Properties."
In the "Application" section, set Target Framework to be ".NET 4.5" (or later), and save.
You may be prompted to re-load the solution.

The very last step is to add NuGet packages for Octokit and Nancy.
Right-click on the project node in Solution Explorer, and select "Manage NuGet Packages…"
Do a search for "Nancy", and upgrade it if necessary – there's a chance the Nancy project template specifies an out-of-date version.
Then do a search for "Octokit," and install that.
At this point, you should have an empty solution, configured and ready for our example code.
To run it with debugging, go to "Debug>Start Debugging…," or hit F5. 
Visual Studio will start the server under a debugger, and open an IE instance on http://localhost:12008/[], which should give you the default Nancy 404 page.

===== Xamarin Studio

If you're using Xamarin Studio or MonoDevelop, your flow is slightly different.
There are no Nancy-specific project templates for these IDEs, so you'll just start with an empty web project.
Go to "File>New>Solution…", and choose "ASP.NET>Empty ASP.NET Project" from the template chooser, as shown in <<xamarin_new_project>>.

[[xamarin_new_project]]
.Creating an empty ASP.NET application in Xamarin Studio
image::images/xamarin-new-project.png[]

The rest of the wizard steps are about the project name and location; feel free to call and put this project however you like.

Next, update the target framework setting.
Control- or right-click on the node in the solution explorer that corresponds with your project (_not_ your solution), and select "Options" from the menu.
Under "Build>General," set the Target Framework to "Mono / .NET 4.5" (or later) and click OK.

Lastly, install the Nancy and Octokit NuGet packages.
Go to "Project>Add NuGet Packages…" in the menu to open the package manager.
Search for Nancy, check the box next to it, search for Octokit, check its box, and click "Add Packages" at the bottom right.
Once the process is complete, your project is ready for our example code.
To run it under the debugger, go to "Run>Start Debugging…," or type ⌘-Enter.
Xamarin will start the server and open a browser window to http://127.0.0.1:80080[], which at this point will just show the default 404 page.

==== First steps

First, let's get our Nancy application up and running.
Here's what it looks like to do perform a simple request using Nancy and Octokit.

[source,cs]
----
using Nancy;
using Octokit;
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Linq;
using System.Web;

namespace NancyApp
{
    public class Handler : NancyModule // <1>
    {
        private readonly GitHubClient client =
            new GitHubClient(new ProductHeaderValue("MyHello")); // <2>

        public Handler()
        {
            Get["/{user}", true] = async (parms, ct) => // <3>
                {
                    var user = await client.User.Get(parms.user.ToString()); // <4>
                    return String.Format("{0} people love {1}!",
                                         user.Followers, user.Name); // <5>
                };
        }
    }
}    
----

<1> Here we derive a class from `NancyModule`, which is all you have to do to start receiving and processing HTTP requests in Nancy.
<2> The `GitHubClient` class is the entry point for Octokit.
    Here we create an instance with a placeholder product name, which we'll use later on.
<3> The constructor for the module sets up route mappings.
    We map `/{user}` to a lambda function using the `Get` dictionary that comes with `NancyModule`.
    The second parameter to the index operator says that the handler will be asynchronous.
<4> Here we see how to get the `{user}` part of the request URL, and how to query the GitHub User API using Octokit.
    Note that we have to `await` the result of the network query, since it may take some time.
<5> Nancy request handlers can simply return a text string, which will be marked as HTML for the viewing browser.
    Here we return a simple string with the user's real name and number of followers.

[aside]
====
The `async` and `await` keywords bear special mention.
These comprise a syntactic nicety that encapsulates a series of functions that are running on an event loop.
The code looks like it runs in order, but really when the `await` keyword is reached, the system starts an asynchronous request, and returns control back to the main event loop.
Once the request has finished, and the promise is fulfilled, the event loop will then call back into the code that's expecting the return value of the `await` keyword, with all the scope variables intact.
This feature was introduced in .NET 4.0 (which was released in 2012), and it lets you write asynchronous code almost as though it were synchronous.
This is but one of the features that make C# the favorite of many developers.
====

This example is a bit more complicated than "hello, world," but it's still fairly succinct and clear.
This bodes well, because we're about to introduce some complexity.

==== OAuth flow

In order to post a status update for a commit, we're going to have to ask the user for permission.
Apart from asking for their username and password (which gives way too much control, and if two-factor authentication is enabled may not even be enough), the only way to do this is OAuth, which is not straightforward.

Here's a simple outline of the OAuth process, from our little server's point of view:

. We need an authorization token, because we don't have one, or the one we have is expired.
  This is just a string of characters, but we can't generate it ourselves, so we ask GitHub for one.
  This involves redirecting the user to a GitHub API endpoint, with the kind of permission we're asking for and some other details as query parameters.
. The user's browser then tells them that an application is requesting some permissions, and they can either allow or deny them.
. If the user allows this access, their browser redirects them to a URL we specified in step 1.
  A "code" is passed as a query parameter; this is not the access token we want, but a time-limited key to get one.
  (The granted access is stored on the GitHub end, so we can skip the user-gated part of this process in the future.)
. From inside the handler for this request, we can use a REST API to get the access token.
  Once we have it, we can skip this whole process the next time the user accesses our server, so we should store it somewhere safe.
. Now we have permission, and we can use the GitHub API with authentication.

OAuth seems convoluted, but its design achieves several goals.
First, permission can be scoped – an application is almost never given full access to the user's account and data.
Second, the whole exchange is secure; at least one part of this has to go through the user, and cannot be automated.
Third, the access token is never transmitted to the user's browser, which avoids a class of security vulnerabilities.

Here's how we implement the OAuth flow in our tiny little server.
First, once we have a token, we should store it so we're not going through the entire redirect cycle for every user request.
We're going to put it in a cookie, though since this goes back and forth to the user's browser, a production application would probably use a database.
Nancy can help us with this, but first we have to enable it, and the way this is accomplished is by using a bootstrapper.
We're going to add this class to our application:

[source,cs]
----

using Nancy;
using Nancy.Bootstrapper;
using Nancy.Session;
using Nancy.TinyIoc;

namespace NancyApp
{
    public class Bootstrapper : DefaultNancyBootstrapper
    {
        protected override void ApplicationStartup(TinyIoCContainer container,
                                                   IPipelines pipelines)
        {
            CookieBasedSessions.Enable(pipelines);
        }
    }
}
----

Nancy will automatically detect a bootstrapper class, and use it to initialize our server.
Now, from within a `NancyModule`, we can use the `Session` property to store and retrieve values that are transmitted as cookies.

Next, we have to include our application's ID and secret in some of the requests, so we embed them in the code by adding these fields to the `Handler` class:

[source,cs]
----
        private const string clientId = "<clientId>";
        private const string clientSecret = "<clientSecret>";
----

Obviously, you should use values from your own API application if you're following along.
After that, we'll need a helper method that kicks off the process:

[source,cs]
----
        private Response RedirectToOAuth()
        {
            var csrf = Guid.NewGuid().ToString();
            Session["CSRF:State"] = csrf; // <1>
            Session["OrigUrl"] = this.Request.Path; // <2>

            var request = new OauthLoginRequest(clientId)
                {
                    Scopes = { "repo:status" }, // <3>
                    State = csrf
                };
            var oauthLoginUrl = client.Oauth.GetGitHubLoginUrl(request);
            return Response.AsRedirect(oauthLoginUrl.ToString()); // <4>
        }
----

<1> CSRF stands for "cross-site request forgery."
    This is a mechanism by which we can be sure the OAuth request process really did originate from our site.
    The GitHub OAuth API will pass this value back to us when the user authorizes access, so we store it in the cookie for later reference.
<2> Storing the original URL in the session cookie is a UX feature; once the OAuth process has completed, we want to send the user back to what they were _trying_ to do in the first place.
<3> This is the permission set we're asking for.
    Note that we're also including our CSRF token; this is so GitHub can give it back to us later for verification.
<4> Here we use Octokit to generate the redirect URL, and send the user's browser there.

`RedirectToOAuth` is a method that can be called from any route handler in our module, if it's discovered that the token is missing or invalid.
We'll see how it's called a bit later, but for now let's follow the rest of the OAuth process.

In our GitHub application settings (check https://github.com/settings/developers[] for a list of your applications), we specify an authorization URL.
In this case, we've specified `localhost:8080/authorize`, and that's where GitHub will redirect the user's browser if they authorize our application.
Here's the handler for that endpoint, which has been inserted into the module constructor:

[source,cs]
----
            Get["/authorize", true] = async (parms, ct) =>
                {
                    var csrf = Session["CSRF:State"] as string;
                    Session.Delete("CSRF:State");
                    if (csrf != Request.Query["state"]) // <1>
                    {
                        return HttpStatusCode.Unauthorized;
                    }

                    var queryCode = Request.Query["code"].ToString();
                    var tokenReq =  new OauthTokenRequest(clientId, // <2>
                                                          clientSecret,
                                                          queryCode);
                    var token = await client.Oauth.CreateAccessToken(tokenReq);
                    Session["accessToken"] = token.AccessToken; // <3>

                    var origUrl = Session["OrigUrl"].ToString();
                    Session.Delete("OrigUrl");
                    return Response.AsRedirect(origUrl); // <4>
                };
----

<1> Here we verify the CSRF token we generated before.
    If it doesn't match, something shady is happening, so we return a 401.
<2> This is the REST call that converts our OAuth code to an access token.
    In order to verify that this really is our application asking for the token, we pass in both the client ID and secret, as well as the code given to us by GitHub.
<3> This is where we store the resulting token in the session cookie.
    Again, this wouldn't be a good idea for a real application, but for our purposes it'll do.
<4> Here we redirect the user back to what they were originally trying to do, with as little disruption as possble.

Once all that is done, we've got our token and are able to continue on our merry way.
All our handlers have to do to trigger an OAuth sequence is to call `RedirectToOAuth()` if it's necessary, and we'll automatically return the user to where they were when the process completes.

==== Status handler

Having done all that, let's see what it takes to create a new commit status.
We're going to add this snippet to our Nancy module constructor:

[source,cs]
----

            Get["/{user}/{repo}/{sha}/{status}", true] = async (parms, ct) => // <1>
                {
                    var accessToken = Session["accessToken"] as string;
                    if (string.IsNullOrEmpty(accessToken))
                        return RedirectToOAuth();
                    client.Credentials = new Credentials(accessToken);

                    CommitState newState = Enum.Parse(typeof(CommitState), // <2>
                                                      parms.status,
                                                      true);
                    try
                    {
                        var newStatus = new NewCommitStatus // <3>
                        {
                            State = newState,
                            Context = "example-api-app",
                            TargetUrl = new Uri(Request.Url.SiteBase),
                        };
                        await client.Repository.CommitStatus.Create(parms.user, // <4>
                                                                    parms.repo,
                                                                    parms.sha,
                                                                    newStatus);
                    }
                    catch (NotFoundException) // <5>
                    {
                        return HttpStatusCode.NotFound;
                    }

                    var template = @"Done! Go to <a href=""https://" // <6>
                    + @"api.github.com/repos/{0}/{1}/commits/{2}/status"
                    + @""">this API endpiont</a>";
                    return String.Format(template,
                                         parms.user, parms.repo, parms.sha);
                };
----

<0> Note the request path for this handler: a GET request to `localhost:8080/user/repo/<sha>` will create a new status.
    This is easy to test with the browser, but also makes it easy for web crawlers to unknowingly trigger this API.
    For this example it's okay, but for a real application you'd probably want to require this to be a POST request.
<1> Here we're trying to parse the last segment of the request URL into a member of the `CommitState` enumeration.
    Octokit tries to maintain type safety for all of its APIs, so strings aren't accepted for this API.
<2> The `NewCommitStatus` object encapsulates all the things you can set when creating a new status.
    Here we set the state we parsed earlier, a hopefully-unique context value that identifies our service, and a not-very-useful target URL (which should explain how the result was derived).
<3> This is the REST call to create the new status, which is asynchronous.
<4> There are a number of exceptions that could be thrown from the API, but the biggest one we want to handle is the `NotFoundException`, which has been translated from the HTTP 404 status.
    Here we translate it back to make for a nice experience for the user.
<5> If we succeed, we render a snippet of HTML and return it from our handler.
    Nancy will set the content-type for responses to HTML by default, so the user will get a nice clickable link.

That's it!
If you've typed all this into a project of your own, you should be able to run it under the debugger, or host it in an ASP.NET server, and create commit statuses for your projects by opening URLs in your browser.
We noted this a bit earlier, but it bears repeating: this particular example responds to GET requests for ease of testing, but for a real service like this you'd probably want creation of statuses to use a POST request.

=== Summary

If you've read this far, you've learned how the commit-status API can help you write services that augment the use of pull requests on GitHub.
These usually take a form like continuous integration, but there are many other possibilities that are enabled by this API.

You've gotten a basic introduction to OAuth, and how it works on the server side.
There's definitely a lot more to learn, but the basic flow you've seen works, and solves quite a few hard problems.

You've gained a passing knowledge of C#, including its package system, at least one IDE, lambda functions, extended constructors, and more.
C# has become a very capable language in recent years, and it should come as no surprise that many developers choose it first for their projects.

You've learned about Nancy, a lightweight toolkit for building HTTP services.
And you've had an introduction to Octokit, a type-safe implementation of a REST API, with built-in asynchrony and OAuth helpers.
