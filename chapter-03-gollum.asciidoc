== Gollum

Wikis have revolutionized the way we create and digest
information. It turns out they are a great complement to technical
projects (code repositories) because they allow non-technical
users to contribute information without disturbing developers. Gollum
is GitHub's open source version of a wiki. Just as Git has
revolutionized collaborative editing of code, Gollum wikis layer the
benefits of Git onto a proven publishing workflow. The true power of
Gollum wikis reveal themselves when you see how tightly integrated
with GitHub they are. You can quickly build and associate a wiki with
any repository, and create a collaborative documentation system around
any repository hosted on GitHub. And, you can pull in information from
git repositories with ease, linking documentation with live code.

In this chapter we'll explore the basics of using Gollum, creating a
wiki on GitHub and then understanding how to edit it on GitHub, and as
a repository on our local machine. We will then create a Gollum wiki by
hand from the command line, and show the bare minimum set of files to
call something a Gollum repository. Finally, we will build a simple
image organization tool which allows us to edit a Gollum wiki in an
entirely different way, but still publishes information into GitHub as
a regular Gollum wiki, exploring a little bit of the internals of Git
along the way.

=== "The Story of Smeagol..."

Gollum wikis are simply an agreed upon file structure. At its most
basic form, a Gollum wiki is a git repository with a single file,
`Home.ext` (`ext` would be any of the supported wiki markup formats,
which we will talk about later). 

First, let's learn how to create a gollum wiki from the GitHub
interface, and then later we'll move into creating one from scratch as
a git repository.

==== Repository Linked Wikis

Any repository, public or private, can have an associated Gollum wiki.
To create a wiki linked to a GitHub repository, visit the repository
page and then look in the rightmost colum. You'll see an icon which
looks like a book, next to which will be the word "Wiki." 

image::images/gollum-wiki.png[Integrated Gollum Wiki in the Sidebar]

Clicking on this link will bring you to a page where you are asked to
create a wiki for the first time. GitHub will ask you to create the
"Home" page, which is the starting point in a Gollum wiki. GitHub will
automatically create a page template with the project name; you can
customize this information to suit your own needs. Clicking on the
"Save Page" will save your first page and create the wiki for you.

image::images/gollum-wiki-create.png[Starting a Gollum Wiki]

Your wiki is now as public as your repository is public. Public
repositories have public wikis, accessible to anyone. Private
repositories have private wikis, accessible only to those users or
organizations which have rights to edit the repository data. 

Wikis are powerful collaboration tools because they use a special
language which compiles into HTML. Let's review the options for Gollum
wikis.

==== Markup and Structure

Gollum files can be written in any of the supported "Github Markup" formats, which
includes ASCIIdoc, Creole, Markdown, Org Mode, Pod, RDoc,
ReStructuredText, Textile, and MediaWiki. The variety of markup
languages brings flexibility but it can be confusing to know which one
to use. Markdown (and its variant cousins) is the most popular markup
language on GitHub, and is well liked on other popular sites like
Stack Overflow. If you are unsure which language to use, Markdown is a
safe bet because it is ubiquitous across GitHub. The <<Jekyll>>
chapter has a much deeper overview of Markdown.

If you do choose Markdown, In addition to the standard vanilla
Markdown language tags, Gollum adds its own set wiki specific tags. There 
are often subtle (or conflicting) differences from other Wiki markup
so it is worth reviewing the
https://github.com/gollum/gollum/wiki:[Gollum repository documentation
page]. We'll go over the most important ones here.

===== Links 

Let's summarize a bit of Gollum syntax. Links are a good place to start.

* Links use the syntax `[[Link]]`. 
* You can add a link title using the bar character:
  `[[http://foobar.com|A link to foobar]]`. 
* Links can be either external or internal links. 
* A link like `[[Review Images]]` will be converted to a relative link
  to the page `review-images.ext` (where ext is the preferred
  extension you are using with your wiki, most likely Markdown). 

Wikis are generally a collection of pages
linked together in myriad ways, and this assumption about the
structure of links makes writing pages easier. 

As we mentioned, there are differences between Gollum wiki tags and other wikis despite
having similar syntax. One such example is MediaWiki, where links with
titles use the opposite ordering `[[A link to
foobar|http://foobar.com]]`, so caveat emptor.

===== Inserting Images

Images are inserting into your document using the same tag format
`[[ceo.png]]`: this adds the correct HTML tags to include an image
named ceo.png inside your page. This basic syntax is often extended
for additional funtionality. For example, to add a frame
and an alt tag, you could use syntax like `[[ceo.png|frame|alt=Our CEO
relaxing on the beach]]`. This creates the proper HTML tags for the
same image, but this time adds a frame and alt text (helpful for
better context and screenreaders). Review the documentation on the
Gollum repository for more details about the breadth of the image
options. 

===== Code Snippets

Gollum (the wiki) was invented at GitHub, a company dedicated to
improving the lives of software developers, so it stands to reason
Gollum wikis would support code snippets. To include a snippet of
code, use three backticks, followed by the language name, and close
the block of code using three more backticks.

[source,ruby]
----
```ruby
def hello
  puts "hello"
end
```
----

A more interesting way of embedding code inside a Gollum repository is
to use the file include syntax. Again, use a triple backtick, followed
by the file type and then a reference to the code snippet inside a
GitHub repository. You'll need to include the branch as well.

[source,ruby]
------
```html:github:xrd/TeddyHyde/blob/master/Gemfile```
------

This will pull the file on GitHub located inside the "TeddyHyde" repository for
user "xrd" on the master branch named "Gemfile"  and publish it with
syntax hilighted into your wiki as if you had used this markup.

[source,ruby]
-------
```ruby
source 'https://rubygems.org'

gem "nokogiri"
gem "rspec"
gem 'calabash-android', :git => 'git://github.com/calabash/calabash-android.git'
```
-------

Unfortunately, you cannot specify a specific SHA commit to retrieve
moments in history within the git repository, but this is still a
powerful way to expose a file inside a Gollum wiki. If you need to do
that, the best way might be to create a branch from a specific SHA
commit, and then reference that branch when including the file.

[source,bash]
$ git checkout 0be3e4475db2697b8
$ git checkout -b at_sha_0be3e4475db2697b8
$ echo "gem 'rails' # Adding rails to Gemfile" >> Gemfile
$ git commit -m "Added rails to Gemfile" -a
$ git push origin at_sha_0be3e4475db2697b8

This would generate a new branch based on an older commit, and push up
the branch. Then, you could reference this inside your wiki with the
following include

[source,ruby]
------
```html:github:xrd/TeddyHyde/blob/at_sha_0be3e4475db2697b8/Gemfile```
------

Note that we've referenced the branch named after the specific SHA
hash we want. 

===== Gollum Structural Components

Gollum includes capabilities to add sidebars, headers, and footers. If
you include a file called `_Sidebar.ext` inside your repository,
you'll see it as a sidebar for every file rendered. Sidebars are
automatically added to any file and any file from subdirectories that
do not have their own sidebar files. If you wanted to add sidebars
specific to a subdirectory, add another file in the subdirectory and
this file will override the top level sidebar file. 

===== No Styling or JavaScript

Finally, for security reasons, Gollum strips out all CSS and
JavaScript from raw markup files. You can include your own JavaScript
or CSS file when running Gollum locally using the `--custom-css` or
`--custom-js` switches, but there is no way to include these files on a
Wiki when your Gollum wiki is hosted on GitHub.

Now that we have investigated the structure and format of using Gollum
wikis, we can dig into the power tools that come with Gollum.

=== Moving Gollum to Your Laptop

Though many people edit Gollum wikis exclusively from within the
GitHub online editor, there is a real flexibility and power when
hosting your wiki locally and editing it from your laptop. To do this
you need to install the command line tools for Gollum.

[source,bash]
-------
$ gem install gollum
-------

You will then see the `gollum` command in your path.

[NOTE]
There is a difference between the `gollum` command (what you run from
the command line) and the suite of technologies that make up Gollum as
a project. To differentiate between them, remember that we are talking
about the suite when the word is capitalized ("Gollum"), and the command line
tool when the word is lowercased and fixed width font (`gollum`).

What additional options are opened up when running locally? Let's take
a deeper look.

==== Alternative Editing Options

When you run your Gollum wiki from your laptop instead of viewing and
editing on GitHub exclusively, you then get a few additional options
for editing.

* Gollum wikis are editable locally
  within a web browser: run the `gollum` command locally on your laptop
  (which spawns a mini web server hosting your wiki) and then browse to
  http://localhost:4567. 
* Gollum wikis can be edited at
  the file system level using your favorite editor, allowing you the
  flexibility of staying within the same workflow you use to edit any
  other file within a local repository. 

You might use a hybrid approach to editing your Gollum wiki, switching
back and forth  between editing within the web browser interface and
jumping into the command line and using your editor to create or
modify files when you need to use "power commands." And, it is nice to
know you can use any simple text processing language to make
programmatic changes to your wiki once you have it locally on your
laptop as a Git repository.

==== Editing with the Command Line

Gollum wiki content reflects only the files inside the repository; another way
to say this is that files in your working directory but not yet
committed are not used by Gollum. To illustrate this, let's go through the steps
to add a sidebar to our wiki. Adding a sidebar means you need to create a file 
called _Sidebar.md. This is a special file which Gollum recognizes and
generates a sidebar for you; the first part of the name is fixed, but
you can change the extension to whatever extension you prefer for your
wiki files. If we use the "open" command (available on Mac or Linux)
to open the Wiki in our default browser, you will see that only once
we have committed the change to our repository do we actually see the
sidebar. 

[source,bash]
-----
$ gollum & # Start gollum, will run on port 4567.
$ printf "## Warning\nPlease note this is subject to change" > _Sidebar.md
$ open http://localhost:4567/ # We won't see our sidebar yet...
$ git add _Sidebar.md 
$ open http://localhost:4567/ # We still don't see our sidebar...
$ git commit -m "Add sidebar"
$ open http://localhost:4567/ # Eureka, now we will see our sidebar!
-----

If you edit within the web browser interface, the underlying Grit
libraries do all the work to commit new files into the repository. If
you use the command line, you'll need to remember to commit files
manually to see them inside your wiki.

We now can display and allow editing from our locally running Gollum
server. This Gollum server actually can be made to be accessible to
anyone who can access your laptop's IP address. So, we could permit
editing by others in our office. But, what if we want to disallow
editing unless the user has permission to do so? We need an
authentication mechanism. 

==== Adding Authentication 

As Gollum is built on top of Sinatra (a ruby library which we will
discuss in more detail shortly) you can utilize authentication gems
like `omnigollum` or write your own authentication handler and run
gollum inside that.
http://stackoverflow.com/questions/9634703/strong-access-control-for-gollum/13357591#13357591:[This 
thread on StackOverflow] explains how to install your own handler:
 
[source,ruby]
-------
# authentication.rb
module Precious
  class App < Sinatra::Base
    use Rack::Auth::Basic, "Restricted Area" do |username, password|
      [username, password] == ['admin', 'admin']
    end
  end
end
-------

And, then run it using this command:

[source,bash]
-----
gollum --config authentication.rb
-----

You'll then be prompted for the username and password, and can use
"admin" and "admin". 

Why "Precious" as the module name? If you peek into the Gollum code
itself, you'll see that the Gollum libraries use a namespace called
"Precious" (the word used to refer to the ring by the character Gollum in the
Lord of the Rings books) as the base class for the Gollum wrapper
around Sinatra. This code extends the instance of Sinatra running your
Gollum wiki and adds an authentication layer. 

[WARNING]
A word of caution when using the gollum command in server mode to edit
files locally inside a web browser. If you start the gollum server
from the command line you do have the capability to edit the files
from any computer within the same network. In other words, you could
find your IP address and use that address from your Chromebook or your
tablet to view and edit your wiki. However, remember that the gollum
server command does not have an authentication system built into it,
which means that gollum thinks anyone accessing the wiki is the same
user that started the gollum command. This is fine if you are in the
other room editing on your tablet while gollum runs on your work
laptop. However, the gollum server is not a good solution for offering
a wiki up to many people within a subnet. If multiple people edit
files, there is no way that gollum can track the different user
contributions in the change log. This is not a problem when editing
your Gollum wiki inside GitHub.com: the GitHub site knows who you are
and properly assigns your changes to your username inside the
change log.  

We've played a bit with the gollum command line tools. Let's put these
skills to use and make our own special gollum tool.

=== Building a Gollum Editor

Once you understand Git repositories, you can see the power of Gollum
as a wiki format: as everything is built on Git, you can manage your
wiki using all the great tools that come with Git. We've explored
how easy it is to edit Gollum wikis: from within the command line,
from the web browser, or from within GitHub. However, there might be
times when you need to provide an entirely customized editing modality. As long
as you write files into the repository in the way the gollum libraries
understand, you can write your own editing interface to suit your own
needs. Let's experiment with this idea and build a new editing
interface for Gollum wikis.

[WARNING]
Gollum is a tool that provides flexibility by allowing local usage:
this can be very handy when you are on a plane and don't want to pay
for Wi-Fi. However, at the time of this writing there is a bug
where images are not displayed, so although you can fully edit files
using the local `gollum` command, you will not be be able to view them
when viewing your wiki on you local machine. To view image files
correctly, publish them into GitHub. 

==== Hacking Gollum

Team software development often revolves around this idealized
scenario: a business person develops the structure of the application
with higher-up stakeholders, these ideas are passed down to a UI/UX
designer who then creates wireframes and mockups of the interactions,
and then a software developer takes these wireframes and builds the
software. Put another way, program managers figure out what features provide
the most value to users, which then trickles down into the wireframes
as real interactions. Many hidden blocking paths are fleshed out here,
places where the application would confuse the user, and time is saved
because the software developer does not have to waste time building
something that would not work anyway. By the time it reaches the
developer, the UI interaction is streamlined and the costly and
inflexible stage of building software has all the inefficiencies
optimized away. The developer can simply work on a piece of software
and know there are no changes, changes which would be extremely costly
to implement.  

In practice, this process is almost never so smooth. What typically happens
is the business people don't completely understand all the
requirements when they document the structure they want, so after they
have committed to a structure they later ask for changes, which
trickle down into the designs. The "final and approved" mockups have
to be changed and this then needs to be communicated to the developer,
who has already started building something that was "set in stone."
Or, the developer, as she is building the software, realizes there are 
missing steps to get to places inside the application, and needs
to communicate this back to the designer. If you have multiple people
doing software development on a project, this information then needs
to fan out to them if their areas are affected by these changes. This
information must traverse many different people, with many different
methods of communication.  

Wikis are a great way to store this kind of information. Information
which changes. Information which must be retrieved by many people and
edited by many people. What better than to manage these informational
transitions than a change tracking system like Git, and what better
way to absorb this information than a Wiki built on top of Git, hosted
on GitHub. 

==== Wireframe Review Tool

Let's build a simple tool which stores these types of changes. We'll
build an image editor that hosts changes  to UI mockups. This will
give our executives a place where they can see changes and
updates. This will allow our UI designer a place to store their images
and annotate them with vital information. And, we'll have a place
where developers can retrieve information without reviewing their
email and wondering "Do I have the most up-to-date mockups?" We'll
buid a special interface which allows quickly editing and reviewing
these files locally.  And all of it can be published into GitHub for
review (though we won't allow editing of the information there, since
GitHub has its own editing modality.) 

Gollum is built on Ruby and uses the Grit library underneath. Using
Ruby makes sense because we can leverage the existing Grit and Gollum
libraries. We'll also use Sinatra, the same web application library we
used in the last chapter.

[NOTE]
The `gollum` command is, in fact, a customized wrapper around Sinatra.

This will be a dual purpose repository. We can use the repository with
gollum as a standard wiki. And, we can use it with our application to
enter data in a more powerful way than gollum permits from its default
interface. The data will still be compatible with gollum and will be
hosted on GitHub.

To begin, initialize our repository.

[source,bash]
$ mkdir images
$ cd images
$ git init .
$ printf "### Our home" > Home.md
$ git add Home.md
$ git commit -m "Initial checking"

We've just created a wiki compatible with gollum. Let's see what it
looks like inside gollum. run the `gollum` command then open
`http://localhost:4567/` in your browser.

image::images/gollum-first-view.png[Gollum running locally]

As you can see, this tiny set of commands was enough to create the
basics of the gollum wiki structure.

Create our sinatra script called `image.rb`, and then we can install
the necessary gems and run our server application.

[source,ruby]
require 'sinatra'
require 'gollum-lib'
wiki = Gollum::Wiki.new(".")
get '/pages' do
  "All pages: \n" + wiki.pages.collect { |p| p.path }.join( "\n" )
end

[source,bash]
$ printf "source 'https://rubygems.org'\n\ngem 'sinatra'\ngem 'gollum-lib'" >> Gemfile
$ bundle install
$ ruby image.rb
$ open http://localhost:4567 # or whatever URL is reported from Sinatra

Once you open this in your browser, you'll see a report of the files
that exist in our Gollum wiki right now. We've only added one file,
the `Home.md` file.

==== Programmatically Handling Images

Let's add to our server. We want to support uploading ZIP files into
our system that we will then unpack and add to our repository, as well
as adding a list of these files to our wiki. Modify our image.rb
script to look like this:

[source,ruby]
-----
require 'sinatra'
require 'gollum-lib'
require 'tempfile'
require 'zip/zip'

def index( message=nil )
  response = File.read(File.join('.', 'index.html'))
  response.gsub!( "<!-- message -->\n", "<h2>Received and unpacked #{message}</h2>" ) if message
  response
end

wiki = Gollum::Wiki.new(".")
get '/' do
  index()
end

post '/unpack' do
  @repo = Rugged::Repository.new('.')
  @index = Rugged::Index.new

  zip = params[:zip][:tempfile]
  Zip::ZipFile.open( zip ) { |zipfile|
    zipfile.each do |f|
      contents = zipfile.read( f.name )
      filename = f.name.split( File::SEPARATOR ).pop
      if contents and filename and filename =~ /(png|jp?g|gif)$/i
        puts "Writing out: #{filename}"
      end
    end
  }
  index( params[:zip][:filename] )
end  

-----

We'll need an `index.html` file as well, so add that.

[source,ruby]
-----
<html>
<body>
<!-- message -->
<form method='POST' enctype='multipart/form-data' action='/unpack'>
Choose a zip file: 
<input type='file' name='zip'/>
<input type='submit' name='submit'>
</form>
</body>
</html>

-----

This server
script receives a POST request at the `/unpack` mount point and
retrieves a ZIP file from the parameters passed into the script. It
then opens the ZIP file (stored as a temp file on the server side),
iterates over each file in the ZIP, strips the full path from the
filename, and then prints out that filename (if it looks like an image)
to our console. Regardless of whether we are accessing the 
root of our server, or have just posted to the `/unpack` mount point,
we always need to render our index page. When we do render it after
unzipping, we replace a comment stored in the index file with a status
message indicating the script received the correct file we posted.

We need to add an additional ruby library to enable this application,
so update the required gems using the following commands, and then re-run
our Sinatra server script.

[source,bash]
$ printf "gem 'rubyzip'\n" >> Gemfile
$ bundle install
$ ruby image.rb

Then, we can open `http://localhost:4567/` and test uploading a file
full of images. You'll see output similar to this in your console
after uploading a file.

[source,bash]
----
...
[2014-05-07 10:08:49] INFO  WEBrick 1.3.1
[2014-05-07 10:08:49] INFO  ruby 2.0.0 (2013-05-14)
[x86_64-darwin13.0.0]
== Sinatra/1.4.5 has taken the stage on 4567 for development with
backup from WEBrick
[2014-05-07 10:08:49] INFO  WEBrick::HTTPServer#start: pid=46370
port=4567
Writing out: IMG1234.png
Writing out: IMG5678.png
Writing out: IMG5678.png
...
----

==== Leveraging the Rugged Library

Our end goal for this script is to add files to our Gollum wiki, which
means adding files to the repository which backs our Gollum wiki.
The Rugged library handles the grunt work of this type of task easily. 
Rugged is the successor to the original Ruby library for Git (called
Grit). Gollum, at the time of this writing uses the Grit libraries,
which also provide a binding to the libgit2 library, a "portable, pure
C implementation of the Git core methods." Grit has been abandoned
(though there are unofficial maintainers) and the Gollum team intends
to use Rugged as the long term library backing Gollum. Rugged 
is written in Ruby and, if you like Ruby, is a more elegant way to
interface with a Git repository than raw git commands. As you might
expect, Rugged is maintained by several employees of GitHub.

To change our script to modify our Git repository, modify the `puts`
statement inside the zip loop to call a new method called
`write_file_to_repo`. And, at the end of the zip block, add a method
called `build_commit` which builds the commit from our new files. Our
new file (omitting the unchanged code at the head of the file) looks
like this.

[source,ruby]
-----
post '/unpack' do
  @repo = Rugged::Repository.new('.')
  @index = Rugged::Index.new

  zip = params[:zip][:tempfile]
  Zip::ZipFile.open( zip ) { |zipfile|
    zipfile.each do |f|
      contents = zipfile.read( f.name )
      filename = f.name.split( File::SEPARATOR ).pop
      if contents and filename and filename =~ /(png|jp?g|gif)$/i
        write_file_to_repo contents, filename # Write the file
      end
    end
    build_commit() # Build a commit from the new files
  }
  index( params[:zip][:filename] )
end  

def get_credentials
  contents = File.read File.join( ENV['HOME'], ".gitconfig" )
  @email = $1 if contents =~ /email = (.+)$/
  @name = $1 if contents =~ /name = (.+)$/
end

def build_commit
  get_credentials()
  options = {}
  options[:tree] = @index.write_tree(@repo)
  options[:author] = { :email => @email, :name => @name, :time => Time.now }
  options[:committer] = { :email => @email, :name => @name, :time => Time.now }
  options[:message] ||= "Adding new images"
  options[:parents] = @repo.empty? ? [] : [ @repo.head.target ].compact
  options[:update_ref] = 'HEAD'

  Rugged::Commit.create(@repo, options)
  
end

def write_file_to_repo( contents, filename )
  oid = @repo.write( contents, :blob )
  @index.add(:path => filename, :oid => oid, :mode => 0100644)
end
-----

As you can see from the code above, Rugged handles a lot of the grunt
work required when creating a commit inside a Git repository. Rugged has a
simple interface to creating a blob inside your Git repository
(`write`), adding files to the index (the `add` method), and
then has a simple and clean interface to build the tree object
(`write_tree`) and then build the commit (`Rugged::Commit.create`). 

The astute observers among you will notice a method called
`get_credentials` which loads up your credentials from a file located
in your home directory called `.gitconfig`. You probably have this if
you have used Git for anything at all on your machine, but if this
file is missing, this method will fail. On my machine this file looks
like the following code snippet. The `get_credentials` method simply loads up this
file and parses it for the name and email address. If you wanted to
load the credentials using another method, or even hard code them, you
can just modify this method to suit your needs. The instance variables
`@email` and `@name` are then used in the `build_commit()` method.

[source,ini]
----
[user]
        name = Chris Dawson
        email = xrdawson@gmail.com
[credential]
        helper = cache --timeout=3600
...
----

Just to double check that everything worked properly, let's verify
that things are working correctly after uploading a ZIP file. Jumping
into a terminal window after uploading a new file, imagine running
these commands:

[source,bash]
----
$ git status
----

To our surprise, we will see something like this:

[source,bash]
-----
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

  deleted:    images/3190a7759f7f6688b5e08526301e14d115292a6e/IMG_20120825_164703.jpg
  deleted:    images/3190a7759f7f6688b5e08526301e14d115292a6e/IMG_20130704_151522.jpg
  deleted:    images/3190a7759f7f6688b5e08526301e14d115292a6e/IMG_20130704_174217.jpg

-----

We just added those files; why is Git reporting them as deleted?

To understand why this happens, remember that in Git there are three
places where files can reside: the working directory, the staging
area or index, and the repository itself. Your working directory is
the set of local files which you are working on. The `git status`
command describes itself as "show the working tree status." Rugged
operates on the repository itself, and our Rugged calls above operated
on the index and then built a commit. This is important to note
because our files will not exist in our working directory if we only
write them using the Rugged calls, and if we do this, we cannot
reference them inside our wiki page when we are running Gollum
locally. We'll fix this in the next section.

We've now added the files to our repository, but we have not exposed
these files inside our wiki. Let's modify our server script to write
out each file to a wiki page for review. As we mentioned in the
previous section, we need to make sure that we write the files to both
the working index and the repository (using the Rugged library `write`
call). Then we can generate a Review file which details all the images
uploaded.

==== Optimizing for Image Storage

Often while a designer is receiving feedback from stakeholders, they
will incorporate that feedback into the UI comps, and then resend the
set of comps, with only a tiny change in one file, where the remaining
dozens or even hundreds of files have been left unchanged. We might
assume that our code, as it writes these files to a different path on
disk inside the repository (the path is the parent SHA hash to make it
unique) and we could therefore be adding the same 
file multiple times, and creating a big wasteful repository. However,
the nature of git permits us to add the same file multiple times
without incurring any additional storage cost beyond the first
addition. When a file is added to git repository, a SHA hash is
generated from the file contents. For example, generating the SHA hash
from an empty file will always return the same SHA
hash.footnote:[This is explained
beautifully in the blog
http://alblue.bandlem.com/2011/08/git-tip-of-week-objects.html.]

[source,bash]
-----
$ echo -en "blob 0\0" | shasum
e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
$ printf '' | git hash-object -w --stdin
e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
-----

Adding a zip file with a bunch of files where only one
or two differs from the prior zip file means that Git will properly
reference the same file multiple times. Unfortunately, GitHub does not provide
an interface for reviewing statistics of Wikis in the same way that
they do for regular repositories. We can, however, review our
repository size from within the local repository by running the
count-objects Git subcommand. As an example, I uploaded a ZIP file
with two images inside of it. I then use the 
count-objects command and see this:

[source,bash]
-------
$ git gc
...
$ git count-objects -v
count: 0
size: 0
in-pack: 11
packs: 1
size-pack: 2029
prune-packable: 0
garbage: 0
size-garbage: 0
-------

Inspecting the first ZIP file, I see these statistics about it.

[source,bash]
-----
$ unzip -l ~/Downloads/Photos\ \(4\).zip 
Archive:  /Users/xrdawson/Downloads/Photos (4).zip
  Length     Date   Time    Name
 --------    ----   ----    ----
  1189130  01-01-12 00:00   IMG_20130704_151522.jpg
   889061  01-01-12 00:00   IMG_20130704_174217.jpg
 --------                   -------
  2078191                   2 files
-----

I then use another ZIP file which has one additional file, with the
other two included files exactly identical.

[source,bash]
-----
unzip -l ~/Downloads/Photos\ \(5\).zip 
Archive:  /Users/xrdawson/Downloads/Photos (5).zip
  Length     Date   Time    Name
 --------    ----   ----    ----
  1189130  01-01-12 00:00   IMG_20130704_151522.jpg
   566713  01-01-12 00:00   IMG_20120825_164703.jpg
   889061  01-01-12 00:00   IMG_20130704_174217.jpg
 --------                   -------
  2644904                   3 files

-----

Then, I upload the second ZIP file. If I re-run the count-object
command (after running `git gc`, a command which packs files
efficiently and makes our output more human readable), I see this:

[source,bash]
----
$ git gc
...
$ git count-objects -v
count: 0
size: 0
in-pack: 17
packs: 1
size-pack: 2578
prune-packable: 0
garbage: 0
size-garbage: 0
----

Notice that our packed size has only changed by about half a MB, which
is the compressed size of the additional third file, but more
importantly, there was no impact from the other two files on our
repository size, even though they were added at different paths. 

If we upload the secondary file yet again, we will regenerate and
commit a new version of the `Review.md` file, but no new files will
need to be created inside our Git repository object store from the
images directory (even though their paths have changed), so our 
impact on the repository will be minimal.

[source,bash]
-----
$ git gc
...
$ git count-objects -v
count: 0
size: 0
in-pack: 21
packs: 1
size-pack: 2578
prune-packable: 0
garbage: 0
size-garbage: 0
-----

As you can see, our packed-size has barely changed, an indication that
the only changes were a new Git tree object and commit object. We
still do have the files located in our repository at a variety of
paths so our review pages will work no matter what revision we are accessing.

[source,bash]
-----
$ find images
images
images/7507409915d00ad33d03c78af0a4004797eec4b4
images/7507409915d00ad33d03c78af0a4004797eec4b4/IMG_20120825_164703.jpg
images/7507409915d00ad33d03c78af0a4004797eec4b4/IMG_20130704_151522.jpg
images/7507409915d00ad33d03c78af0a4004797eec4b4/IMG_20130704_174217.jpg
images/7f9505a4bafe8c8f654e22ea3fd4dab8b4075f75
images/7f9505a4bafe8c8f654e22ea3fd4dab8b4075f75/IMG_20120825_164703.jpg
images/7f9505a4bafe8c8f654e22ea3fd4dab8b4075f75/IMG_20130704_151522.jpg
images/7f9505a4bafe8c8f654e22ea3fd4dab8b4075f75/IMG_20130704_174217.jpg
images/b4be28e5b24bfa46c4942d756a3a07efd24bc234
images/b4be28e5b24bfa46c4942d756a3a07efd24bc234/IMG_20130704_151522.jpg
images/b4be28e5b24bfa46c4942d756a3a07efd24bc234/IMG_20130704_174217.jpg
-----

Git and Gollum can efficiently store the same file at different paths
without overloading the repository.

==== Reviewing on GitHub

The raison d'etre for this wiki is to annotate a development project.
If you follow the instructions above and create a new wiki for a
repository, you'll then be able to push up the changes we've made
using our `image.rb` script. Once you have created a new wiki, look
for a box on the right which says "Clone this wiki locally". 

image::images/gollum-local-clone-url.png[Gollum git clone URL]

Copy that link, and then enter a terminal window where we can then add a remote
URL to our local repository which allows us to synchronize our
repositories and publish our images into GitHub. Gollum wikis have a
simple URL structure based on the original clone URL: just add the
word `.wiki` to the end of the clone URL (but before the final `.git`
extension). So, if our original clone URL of the repository is
`git@github.com:xrd/webiphany.com.git` our clone URL for the
associated wiki will be `git@github.com:xrd/webiphany.com.wiki.git`.
Once we have the URL, we can add it as a remote to our local
repository using the following commands.

[source,bash]
-----
$ git remote add origin git@github.com:xrd/webiphany.com.wiki.git
$ git pull # This will require us to merge the changes...
$ git push
-----

When we pull, we will be asked to merge our changes since GitHub
created a `Home.md` file which did not exist in our local repository.
We can just accept the merge as-is. The `git push` publishes our
changes. If we then visit the wiki, we'll see an additional file
listed under the pages sidebar to the right. Clicking on the review
page, we can see the images we've added most recently.

image::images/gollum-android-project1-review.png[Images displayed within a Gollum wiki]

Not sure why our designer is providing us with an image of a couch,
but I am sure he has his reasons.

Once have published the file, we can click on the "Review" link in the
sidebar to see the most current version of the "Review" page. We also
can review the revisions of this file by clicking on the "3 Commits"
(or whatever number of commits have occurred with this file).
link right underneath the page title. Jumping onto that page shows us
the full history of this file.

image::images/gollum-android-project1-revisions.png[A view on the revisions from within GitHub]

Clicking on any of the SHA hashes will display the page at that
revision in our history and show us the state of the document at any given
moment in history. Unfortunately, jumping back and forth between
revisions requires two clicks, one from the review page to the list of
revisions, and then another click to jump into the revision we want,
but this permits us to review changes between the comps provided from
our designer. 

It would be nice if GitHub provided a simple way to jump
from a revision to the parent (older) revision, but they don't expose
this in their site as of this writing. We can fix this, however, by generating
our own special link inside the review page itself which will
magically know about how to navigate to a previous version of the page.

==== Improving Revision Navigation

In our example, we only have three revisions right now, and all share the same commit
message ("Adding new images"). This is not very descriptive and makes
it challenging to understand the differences between revisions,
critical when we are trying to understand how things have changed
between comps. We can improve this easily.

First, let's add a commit message field to our upload form.

[source,html]
-----
<html>
<body>
<!-- message -->
<form method='POST' enctype='multipart/form-data' action='/unpack'>
Choose a zip file: 
<input type='file' name='zip'/>
<input type='text' name='message' placeholder='Enter commit message'/>
<input type='submit' name='submit'>
</form>
</body>
</html>

-----

Then, let's adjust the commit message inside our `image.rb` script,
which is a one line change to the options hash, setting the value of
it to the parameter we are now passing in for "commit".

[source,ruby]
-----
  ...
options[:committer] = { :email => @email, :name => @name, :time => Time.now }
options[:message] = params[:message]
options[:parents] = @repo.empty? ? [] : [ @repo.head.target ].compact
  ...
-----

Now, if our designer posts a new version of the UI comps, they can
specify what changes were made, and we have a record of that in our
change log, exposed on the revisions section of our wiki hosted on GitHub.

#### Fixing Linking Between Comp Pages

We noted that there is no quick way to jump between comps once we are
inside a review revision. However, if you recall we used the parent
SHA hash to build out our image links. We can use this to build out a
navigation inside our comp page when we are on a revision page while
viewing the history.

Again, it is a simple change: one line within the `write_review_file`
method. After the block which creates each link to the image files,
add a line which builds a link to the parent document
via its SHA hash using the parent SHA found in our Rugged object under
`@repo.head.target`. This link will allow us to navigate to prior
revisions in our history.

[source,ruby]
-----
  ...
files.each do |f|
  contents += "### #{f} \n[[#{dir}/#{f}]]\n\n"
end
contents += "[Prior revision (only when viewing history)](#{@repo.head.target})\n\n"

File.write review_filename, contents
oid = @repo.write( contents, :blob )
  ...
-----

Now, when we view the Review file history, we see a file with a link
at the bottom to the link to each prior version. Is it possible to
provide a link to the next version in our history? Unfortunately, we
have no way to predict the SHA hash of the next commit made to the
repository, so we cannot build this link inside our `Review.md` file
with our ruby script. However, we do get something just as good for
free because we can simply use the back button to jump back to the
prior page in the history stack of our browser. It would be nice if we
could generate this link alongside the link we placed into the wiki
markup, and we could do this using a link that runs an onclick handler
delegating to a JavaScript command like
`window.history.back()`, but Gollum foils us again by
stripping JavaScript from our markup files as we noted before. This is a good thing
generally, as we don't want to permit rogue markup inside our wiki
pages, but it does limit our options in this situation.

Unfortunately, these links do not work when you are viewing the review file itself
(clicking on them brings you to a page which asks you to create this
as a new page). Gollum, unlike Jekyll, does not support Liquid
tags which would permit building a link using the username and
repository. Right now we don't have access to these variables, so our
link needs to be relative, which works when we are in history review,
but not in the normal review. It does not affect viewing the files so
this would require educating your stakeholders on the limitations of
this link.

=== Summary

In this chapter we learned how to create a Gollum wiki from
scratch, both on GitHub and as a fresh repository from the comman
line. We then looked at the different ways to use the `gollum` command
line tool and learned why this is a nice option when we want to run
our own Gollum server. Finally, we built a customized Gollum
image-centric editor using the Rugged library for Ruby.

In the next chapter we'll switch gears completely, and build a GUI
application for searching GitHub issues. And we'll do it in Python.
